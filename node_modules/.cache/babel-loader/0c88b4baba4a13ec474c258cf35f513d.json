{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promisify = void 0;\nvar util_1 = require(\"util\");\nObject.defineProperty(exports, \"promisify\", {\n  enumerable: true,\n  get: function get() {\n    return util_1.promisify;\n  }\n});\n// /**\n//  * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into an ES6-compatible Promise.\n//  * Promisify provides a default callback of the form (error, result) and rejects when `error` is not null. You can also\n//  * supply thisArg object as the second argument which will be passed to `apply`.\n//  */\n// // HACK: This can't be properly typed without variadic kinds https://github.com/Microsoft/TypeScript/issues/5453\n// export function promisify<T>(originalFn: (...args: any[]) => void, thisArg?: any): (...callArgs: any[]) => Promise<T> {\n//     const promisifiedFunction = async (...callArgs: any[]): Promise<T> => {\n//         return new Promise<T>((resolve, reject) => {\n//             const callback = (err: Error | null, data?: T) => {\n//                 err === null || err === undefined ? resolve(data) : reject(err);\n//             };\n//             originalFn.apply(thisArg, [...callArgs, callback]);\n//         });\n//     };\n//     return promisifiedFunction;\n// }","map":null,"metadata":{},"sourceType":"script"}