{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar ethereumjs_account_1 = require(\"ethereumjs-account\");\nvar bloom_1 = require(\"./bloom\");\nvar evm_1 = require(\"./evm/evm\");\nvar message_1 = require(\"./evm/message\");\nvar txContext_1 = require(\"./evm/txContext\");\nvar Block = require('ethereumjs-block');\n/**\n * @ignore\n */\nfunction runTx(opts) {\n  return __awaiter(this, void 0, void 0, function () {\n    var state, result, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (opts === undefined) {\n            throw new Error('invalid input, opts must be provided');\n          }\n          // tx is required\n          if (!opts.tx) {\n            throw new Error('invalid input, tx is required');\n          }\n          // create a reasonable default if no block is given\n          if (!opts.block) {\n            opts.block = new Block();\n          }\n          if (new BN(opts.block.header.gasLimit).lt(new BN(opts.tx.gasLimit))) {\n            throw new Error('tx has a higher gas limit than the block');\n          }\n          state = this.pStateManager;\n          return [4 /*yield*/, state.checkpoint()];\n        case 1:\n          _a.sent();\n          _a.label = 2;\n        case 2:\n          _a.trys.push([2, 5,, 7]);\n          return [4 /*yield*/, _runTx.bind(this)(opts)];\n        case 3:\n          result = _a.sent();\n          return [4 /*yield*/, state.commit()];\n        case 4:\n          _a.sent();\n          return [2 /*return*/, result];\n        case 5:\n          e_1 = _a.sent();\n          return [4 /*yield*/, state.revert()];\n        case 6:\n          _a.sent();\n          throw e_1;\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.default = runTx;\nfunction _runTx(opts) {\n  return __awaiter(this, void 0, void 0, function () {\n    var block, tx, state, basefee, gasLimit, fromAccount, txContext, message, evm, results, gasRefund, finalFromBalance, minerAccount, keys, _i, keys_1, k;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          block = opts.block;\n          tx = opts.tx;\n          state = this.pStateManager;\n          /**\n           * The `beforeTx` event\n           *\n           * @event Event: beforeTx\n           * @type {Object}\n           * @property {Transaction} tx emits the Transaction that is about to be processed\n           */\n          return [4 /*yield*/, this._emit('beforeTx', tx)\n          // Validate gas limit against base fee\n          ];\n\n        case 1:\n          /**\n           * The `beforeTx` event\n           *\n           * @event Event: beforeTx\n           * @type {Object}\n           * @property {Transaction} tx emits the Transaction that is about to be processed\n           */\n          _a.sent();\n          basefee = tx.getBaseFee();\n          gasLimit = new BN(tx.gasLimit);\n          if (gasLimit.lt(basefee)) {\n            throw new Error('base fee exceeds gas limit');\n          }\n          gasLimit.isub(basefee);\n          return [4 /*yield*/, state.getAccount(tx.getSenderAddress())];\n        case 2:\n          fromAccount = _a.sent();\n          if (!opts.skipBalance && new BN(fromAccount.balance).lt(tx.getUpfrontCost())) {\n            throw new Error(\"sender doesn't have enough funds to send tx. The upfront cost is: \" + tx.getUpfrontCost().toString() + (\" and the sender's account only has: \" + new BN(fromAccount.balance).toString()));\n          } else if (!opts.skipNonce && !new BN(fromAccount.nonce).eq(new BN(tx.nonce))) {\n            throw new Error(\"the tx doesn't have the correct nonce. account has nonce of: \" + new BN(fromAccount.nonce).toString() + \" tx has nonce of: \" + new BN(tx.nonce).toString());\n          }\n          // Update from account's nonce and balance\n          fromAccount.nonce = ethereumjs_util_1.toBuffer(new BN(fromAccount.nonce).addn(1));\n          fromAccount.balance = ethereumjs_util_1.toBuffer(new BN(fromAccount.balance).sub(new BN(tx.gasLimit).mul(new BN(tx.gasPrice))));\n          return [4 /*yield*/, state.putAccount(tx.getSenderAddress(), fromAccount)\n          /*\n           * Execute message\n           */];\n\n        case 3:\n          _a.sent();\n          txContext = new txContext_1.default(tx.gasPrice, tx.getSenderAddress());\n          message = new message_1.default({\n            caller: tx.getSenderAddress(),\n            gasLimit: gasLimit,\n            to: tx.to.toString('hex') !== '' ? tx.to : undefined,\n            value: tx.value,\n            data: tx.data\n          });\n          state._wrapped._clearOriginalStorageCache();\n          evm = new evm_1.default(this, txContext, block);\n          return [4 /*yield*/, evm.executeMessage(message)];\n        case 4:\n          results = _a.sent();\n          /*\n           * Parse results\n           */\n          // Generate the bloom for the tx\n          results.bloom = txLogsBloom(results.execResult.logs);\n          // Caculate the total gas used\n          results.gasUsed = results.gasUsed.add(basefee);\n          gasRefund = evm._refund;\n          if (gasRefund) {\n            if (gasRefund.lt(results.gasUsed.divn(2))) {\n              results.gasUsed.isub(gasRefund);\n            } else {\n              results.gasUsed.isub(results.gasUsed.divn(2));\n            }\n          }\n          results.amountSpent = results.gasUsed.mul(new BN(tx.gasPrice));\n          return [4 /*yield*/, state.getAccount(tx.getSenderAddress())];\n        case 5:\n          // Update sender's balance\n          fromAccount = _a.sent();\n          finalFromBalance = new BN(tx.gasLimit).sub(results.gasUsed).mul(new BN(tx.gasPrice)).add(new BN(fromAccount.balance));\n          fromAccount.balance = ethereumjs_util_1.toBuffer(finalFromBalance);\n          return [4 /*yield*/, state.putAccount(ethereumjs_util_1.toBuffer(tx.getSenderAddress()), fromAccount)\n          // Update miner's balance\n          ];\n\n        case 6:\n          _a.sent();\n          return [4 /*yield*/, state.getAccount(block.header.coinbase)\n          // add the amount spent on gas to the miner's account\n          ];\n\n        case 7:\n          minerAccount = _a.sent();\n          // add the amount spent on gas to the miner's account\n          minerAccount.balance = ethereumjs_util_1.toBuffer(new BN(minerAccount.balance).add(results.amountSpent));\n          if (!!new BN(minerAccount.balance).isZero()) return [3 /*break*/, 9];\n          return [4 /*yield*/, state.putAccount(block.header.coinbase, minerAccount)];\n        case 8:\n          _a.sent();\n          _a.label = 9;\n        case 9:\n          if (!results.execResult.selfdestruct) return [3 /*break*/, 13];\n          keys = Object.keys(results.execResult.selfdestruct);\n          _i = 0, keys_1 = keys;\n          _a.label = 10;\n        case 10:\n          if (!(_i < keys_1.length)) return [3 /*break*/, 13];\n          k = keys_1[_i];\n          return [4 /*yield*/, state.putAccount(Buffer.from(k, 'hex'), new ethereumjs_account_1.default())];\n        case 11:\n          _a.sent();\n          _a.label = 12;\n        case 12:\n          _i++;\n          return [3 /*break*/, 10];\n        case 13:\n          return [4 /*yield*/, state.cleanupTouchedAccounts()\n          /**\n           * The `afterTx` event\n           *\n           * @event Event: afterTx\n           * @type {Object}\n           * @property {Object} result result of the transaction\n           */];\n\n        case 14:\n          _a.sent();\n          /**\n           * The `afterTx` event\n           *\n           * @event Event: afterTx\n           * @type {Object}\n           * @property {Object} result result of the transaction\n           */\n          return [4 /*yield*/, this._emit('afterTx', results)];\n        case 15:\n          /**\n           * The `afterTx` event\n           *\n           * @event Event: afterTx\n           * @type {Object}\n           * @property {Object} result result of the transaction\n           */\n          _a.sent();\n          return [2 /*return*/, results];\n      }\n    });\n  });\n}\n/**\n * @method txLogsBloom\n * @private\n */\nfunction txLogsBloom(logs) {\n  var bloom = new bloom_1.default();\n  if (logs) {\n    for (var i = 0; i < logs.length; i++) {\n      var log = logs[i];\n      // add the address\n      bloom.add(log[0]);\n      // add the topics\n      var topics = log[1];\n      for (var q = 0; q < topics.length; q++) {\n        bloom.add(topics[q]);\n      }\n    }\n  }\n  return bloom;\n}","map":null,"metadata":{},"sourceType":"script"}