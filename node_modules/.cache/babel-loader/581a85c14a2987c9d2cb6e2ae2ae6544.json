{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar evm_1 = require(\"../evm\");\nvar exceptions_1 = require(\"../../exceptions\");\nvar assert = require('assert');\n// The following blake2 code has been taken from (license: Creative Commons CC0):\n// https://github.com/dcposch/blakejs/blob/410c640d0f08d3b26904c6d1ab3d81df3619d282/blake2s.js\n// The modifications include:\n//  - Avoiding the use of context in F\n//  - F accepts number of rounds as parameter\n//  - Expect 2 64-byte t values, xor them both\n//  - Take modulo 10 for indices of SIGMA\n//  - Added type annotations\n//  - Moved previously global `v` and `m` variables inside the F function\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA(v, a, b) {\n  var o0 = v[a] + v[b];\n  var o1 = v[a + 1] + v[b + 1];\n  if (o0 >= 0x100000000) {\n    o1++;\n  }\n  v[a] = o0;\n  v[a + 1] = o1;\n}\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC(v, a, b0, b1) {\n  var o0 = v[a] + b0;\n  if (b0 < 0) {\n    o0 += 0x100000000;\n  }\n  var o1 = v[a + 1] + b1;\n  if (o0 >= 0x100000000) {\n    o1++;\n  }\n  v[a] = o0;\n  v[a + 1] = o1;\n}\n// Little-endian byte access\nfunction B2B_GET32(arr, i) {\n  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;\n}\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G(v, mw, a, b, c, d, ix, iy) {\n  var x0 = mw[ix];\n  var x1 = mw[ix + 1];\n  var y0 = mw[iy];\n  var y1 = mw[iy + 1];\n  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  var xor0 = v[d] ^ v[a];\n  var xor1 = v[d + 1] ^ v[a + 1];\n  v[d] = xor1;\n  v[d + 1] = xor0;\n  ADD64AA(v, c, d);\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c];\n  xor1 = v[b + 1] ^ v[c + 1];\n  v[b] = xor0 >>> 24 ^ xor1 << 8;\n  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;\n  ADD64AA(v, a, b);\n  ADD64AC(v, a, y0, y1);\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a];\n  xor1 = v[d + 1] ^ v[a + 1];\n  v[d] = xor0 >>> 16 ^ xor1 << 16;\n  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;\n  ADD64AA(v, c, d);\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c];\n  xor1 = v[b + 1] ^ v[c + 1];\n  v[b] = xor1 >>> 31 ^ xor0 << 1;\n  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;\n}\n// Initialization Vector\nvar BLAKE2B_IV32 = new Uint32Array([0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19]);\nvar SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3];\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {\n  return x * 2;\n}));\nfunction F(h, m, t, f, rounds) {\n  var v = new Uint32Array(32);\n  var i = 0;\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = h[i];\n    v[i + 16] = BLAKE2B_IV32[i];\n  }\n  // 128 bits of offset\n  v[24] = v[24] ^ t[0];\n  v[25] = v[25] ^ t[1];\n  v[26] = v[26] ^ t[2];\n  v[27] = v[27] ^ t[3];\n  // last block flag set ?\n  if (f) {\n    v[28] = ~v[28];\n    v[29] = ~v[29];\n  }\n  // message words\n  var mw = new Uint32Array(32);\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    mw[i] = B2B_GET32(m, 4 * i);\n  }\n  // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n  for (i = 0; i < rounds; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    var ri = i % 10 * 16;\n    B2B_G(v, mw, 0, 8, 16, 24, SIGMA82[ri + 0], SIGMA82[ri + 1]);\n    B2B_G(v, mw, 2, 10, 18, 26, SIGMA82[ri + 2], SIGMA82[ri + 3]);\n    B2B_G(v, mw, 4, 12, 20, 28, SIGMA82[ri + 4], SIGMA82[ri + 5]);\n    B2B_G(v, mw, 6, 14, 22, 30, SIGMA82[ri + 6], SIGMA82[ri + 7]);\n    B2B_G(v, mw, 0, 10, 20, 30, SIGMA82[ri + 8], SIGMA82[ri + 9]);\n    B2B_G(v, mw, 2, 12, 22, 24, SIGMA82[ri + 10], SIGMA82[ri + 11]);\n    B2B_G(v, mw, 4, 14, 16, 26, SIGMA82[ri + 12], SIGMA82[ri + 13]);\n    B2B_G(v, mw, 6, 8, 18, 28, SIGMA82[ri + 14], SIGMA82[ri + 15]);\n  }\n  for (i = 0; i < 16; i++) {\n    h[i] = h[i] ^ v[i] ^ v[i + 16];\n  }\n}\nexports.F = F;\nfunction default_1(opts) {\n  assert(opts.data);\n  var data = opts.data;\n  if (data.length !== 213) {\n    return {\n      returnValue: Buffer.alloc(0),\n      gasUsed: opts.gasLimit,\n      exceptionError: new exceptions_1.VmError(exceptions_1.ERROR.OUT_OF_RANGE)\n    };\n  }\n  var lastByte = data.slice(212, 213)[0];\n  if (lastByte !== 1 && lastByte !== 0) {\n    return {\n      returnValue: Buffer.alloc(0),\n      gasUsed: opts.gasLimit,\n      exceptionError: new exceptions_1.VmError(exceptions_1.ERROR.OUT_OF_RANGE)\n    };\n  }\n  var rounds = data.slice(0, 4).readUInt32BE(0);\n  var hRaw = data.slice(4, 68);\n  var mRaw = data.slice(68, 196);\n  var tRaw = data.slice(196, 212);\n  // final\n  var f = lastByte === 1;\n  var gasUsed = new BN(opts._common.param('gasPrices', 'blake2Round'));\n  gasUsed.imul(new BN(rounds));\n  if (opts.gasLimit.lt(gasUsed)) {\n    return evm_1.OOGResult(opts.gasLimit);\n  }\n  var h = new Uint32Array(16);\n  for (var i = 0; i < 16; i++) {\n    h[i] = hRaw.readUInt32LE(i * 4);\n  }\n  var m = new Uint32Array(32);\n  for (var i = 0; i < 32; i++) {\n    m[i] = mRaw.readUInt32LE(i * 4);\n  }\n  var t = new Uint32Array(4);\n  for (var i = 0; i < 4; i++) {\n    t[i] = tRaw.readUInt32LE(i * 4);\n  }\n  F(h, m, t, f, rounds);\n  var output = Buffer.alloc(64);\n  for (var i = 0; i < 16; i++) {\n    output.writeUInt32LE(h[i], i * 4);\n  }\n  return {\n    gasUsed: gasUsed,\n    returnValue: output\n  };\n}\nexports.default = default_1;","map":null,"metadata":{},"sourceType":"script"}