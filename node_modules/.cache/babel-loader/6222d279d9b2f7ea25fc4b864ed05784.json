{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assert = void 0;\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar _ = require(\"lodash\");\nvar validUrl = require(\"valid-url\");\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\nvar schemaValidator = new json_schemas_1.SchemaValidator();\nexports.assert = {\n  isBigNumber: function isBigNumber(variableName, value) {\n    var isBigNumber = utils_1.BigNumber.isBigNumber(value);\n    exports.assert.assert(isBigNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber', value));\n  },\n  isNumberLike: function isNumberLike(variableName, value) {\n    var isBigNumber = utils_1.BigNumber.isBigNumber(value);\n    var isNumber = typeof value === 'number';\n    exports.assert.assert(isBigNumber || isNumber, exports.assert.typeAssertionMessage(variableName, 'BigNumber | number', value));\n  },\n  isValidBaseUnitAmount: function isValidBaseUnitAmount(variableName, value) {\n    exports.assert.isBigNumber(variableName, value);\n    var isNegative = value.isLessThan(0);\n    exports.assert.assert(!isNegative, \"\".concat(variableName, \" cannot be a negative number, found value: \").concat(value.toNumber()));\n    var hasDecimals = value.decimalPlaces() !== 0;\n    exports.assert.assert(!hasDecimals, \"\".concat(variableName, \" should be in baseUnits (no decimals), found value: \").concat(value.toNumber()));\n  },\n  isString: function isString(variableName, value) {\n    exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n  },\n  isFunction: function isFunction(variableName, value) {\n    exports.assert.assert(_.isFunction(value), exports.assert.typeAssertionMessage(variableName, 'function', value));\n  },\n  isHexString: function isHexString(variableName, value) {\n    exports.assert.assert(_.isString(value) && HEX_REGEX.test(value), exports.assert.typeAssertionMessage(variableName, 'HexString', value));\n  },\n  isETHAddressHex: function isETHAddressHex(variableName, value) {\n    exports.assert.assert(_.isString(value), exports.assert.typeAssertionMessage(variableName, 'string', value));\n    exports.assert.assert(utils_1.addressUtils.isAddress(value), exports.assert.typeAssertionMessage(variableName, 'ETHAddressHex', value));\n  },\n  doesBelongToStringEnum: function doesBelongToStringEnum(variableName, value, stringEnum /* There is no base type for every string enum */) {\n    var enumValues = _.values(stringEnum);\n    var doesBelongToStringEnum = _.includes(enumValues, value);\n    var enumValuesAsStrings = _.map(enumValues, function (enumValue) {\n      return \"'\".concat(enumValue, \"'\");\n    });\n    var enumValuesAsString = enumValuesAsStrings.join(', ');\n    exports.assert.assert(doesBelongToStringEnum, \"Expected \".concat(variableName, \" to be one of: \").concat(enumValuesAsString, \", encountered: \").concat(value));\n  },\n  hasAtMostOneUniqueValue: function hasAtMostOneUniqueValue(value, errMsg) {\n    exports.assert.assert(_.uniq(value).length <= 1, errMsg);\n  },\n  isNumber: function isNumber(variableName, value) {\n    exports.assert.assert(_.isFinite(value), exports.assert.typeAssertionMessage(variableName, 'number', value));\n  },\n  isNumberOrBigNumber: function isNumberOrBigNumber(variableName, value) {\n    if (_.isFinite(value)) {\n      return;\n    } else {\n      exports.assert.assert(utils_1.BigNumber.isBigNumber(value), exports.assert.typeAssertionMessage(variableName, 'number or BigNumber', value));\n    }\n  },\n  isBoolean: function isBoolean(variableName, value) {\n    exports.assert.assert(_.isBoolean(value), exports.assert.typeAssertionMessage(variableName, 'boolean', value));\n  },\n  isWeb3Provider: function isWeb3Provider(variableName, value) {\n    utils_1.logUtils.warn('DEPRECATED: Please use providerUtils.standardizeOrThrow() instead');\n    var isWeb3Provider = _.isFunction(value.send) || _.isFunction(value.sendAsync);\n    exports.assert.assert(isWeb3Provider, exports.assert.typeAssertionMessage(variableName, 'Provider', value));\n  },\n  doesConformToSchema: function doesConformToSchema(variableName, value, schema, subSchemas) {\n    if (value === undefined) {\n      throw new Error(\"\".concat(variableName, \" can't be undefined\"));\n    }\n    if (subSchemas !== undefined) {\n      schemaValidator.addSchema(subSchemas);\n    }\n    var validationResult = schemaValidator.validate(value, schema);\n    var hasValidationErrors = validationResult.errors && validationResult.errors.length > 0;\n    var msg = hasValidationErrors ? \"Expected \".concat(variableName, \" to conform to schema \").concat(schema.id, \"\\nEncountered: \").concat(JSON.stringify(value, null, '\\t'), \"\\nValidation errors: \").concat(validationResult.errors.join(', ')) : '';\n    exports.assert.assert(!hasValidationErrors, msg);\n  },\n  doesMatchRegex: function doesMatchRegex(variableName, value, regex) {\n    exports.assert.assert(regex.test(value), exports.assert.typeAssertionMessage(variableName, String(regex), value));\n  },\n  isWebUri: function isWebUri(variableName, value) {\n    var isValidUrl = validUrl.isWebUri(value) !== undefined;\n    exports.assert.assert(isValidUrl, exports.assert.typeAssertionMessage(variableName, 'web uri', value));\n  },\n  isUri: function isUri(variableName, value) {\n    var isValidUri = validUrl.isUri(value) !== undefined;\n    exports.assert.assert(isValidUri, exports.assert.typeAssertionMessage(variableName, 'uri', value));\n  },\n  isBlockParam: function isBlockParam(variableName, value) {\n    if (Number.isInteger(value) && value >= 0) {\n      return;\n    }\n    if (value === 'earliest' || value === 'latest' || value === 'pending') {\n      return;\n    }\n    throw new Error(exports.assert.typeAssertionMessage(variableName, 'BlockParam', value));\n  },\n  isArray: function isArray(variableName, value) {\n    if (!Array.isArray(value)) {\n      throw new Error(exports.assert.typeAssertionMessage(variableName, 'Array', value));\n    }\n  },\n  assert: function assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  },\n  typeAssertionMessage: function typeAssertionMessage(variableName, type, value) {\n    return \"Expected \".concat(variableName, \" to be of type \").concat(type, \", encountered: \").concat(value);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}