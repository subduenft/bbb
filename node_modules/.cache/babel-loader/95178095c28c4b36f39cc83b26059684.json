{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WyvernProtocol = void 0;\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar web3_wrapper_1 = require(\"@0x/web3-wrapper\");\nvar ethABI = require(\"ethereumjs-abi\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar authenticated_proxy_1 = require(\"./abi_gen/authenticated_proxy\");\nvar wyvern_atomicizer_1 = require(\"./abi_gen/wyvern_atomicizer\");\nvar wyvern_d_a_o_1 = require(\"./abi_gen/wyvern_d_a_o\");\nvar wyvern_exchange_1 = require(\"./abi_gen/wyvern_exchange\");\nvar wyvern_proxy_registry_1 = require(\"./abi_gen/wyvern_proxy_registry\");\nvar wyvern_token_1 = require(\"./abi_gen/wyvern_token\");\nvar schemas_1 = require(\"./schemas\");\nvar types_1 = require(\"./types\");\nvar assert_1 = require(\"./utils/assert\");\nvar constants_1 = require(\"./utils/constants\");\nvar decorators_1 = require(\"./utils/decorators\");\nvar signature_utils_1 = require(\"./utils/signature_utils\");\nvar utils_2 = require(\"./utils/utils\");\nvar WyvernProtocol = /*#__PURE__*/function () {\n  function WyvernProtocol(provider, config) {\n    _classCallCheck(this, WyvernProtocol);\n    assert_1.assert.isWeb3Provider('provider', provider);\n    this._provider = provider;\n    this._web3Wrapper = new web3_wrapper_1.Web3Wrapper(provider, {\n      gasPrice: config.gasPrice\n    });\n    var exchangeContractAddress = config.wyvernExchangeContractAddress || WyvernProtocol.getExchangeContractAddress(config.network);\n    this.wyvernExchange = new wyvern_exchange_1.WyvernExchangeContract(exchangeContractAddress, provider);\n    var proxyRegistryContractAddress = config.wyvernProxyRegistryContractAddress || WyvernProtocol.getProxyRegistryContractAddress(config.network);\n    this.wyvernProxyRegistry = new wyvern_proxy_registry_1.WyvernProxyRegistryContract(proxyRegistryContractAddress, provider);\n    var daoContractAddress = config.wyvernDAOContractAddress || WyvernProtocol.getDAOContractAddress(config.network);\n    this.wyvernDAO = new wyvern_d_a_o_1.WyvernDAOContract(daoContractAddress, provider);\n    var tokenContractAddress = config.wyvernTokenContractAddress || WyvernProtocol.getTokenContractAddress(config.network);\n    this.wyvernToken = new wyvern_token_1.WyvernTokenContract(tokenContractAddress, provider);\n    var atomicizerContractAddress = config.wyvernAtomicizerContractAddress || WyvernProtocol.getAtomicizerContractAddress(config.network);\n    this.wyvernAtomicizer = new wyvern_atomicizer_1.WyvernAtomicizerContract(atomicizerContractAddress, provider);\n  }\n  _createClass(WyvernProtocol, [{\n    key: \"setProvider\",\n    /**\n     * Sets a new web3 provider for wyvernProtocol.js. Updating the provider will stop all\n     * subscriptions so you will need to re-subscribe to all events relevant to your app after this call.\n     * @param   provider    The Web3Provider you would like the wyvernProtocol.js library to use from now on.\n     * @param   networkId   The id of the network your provider is connected to\n     */\n    value: function setProvider(provider, networkId) {\n      this._web3Wrapper.setProvider(provider);\n      this.wyvernExchange._invalidateContractInstances();\n      this.wyvernExchange._setNetworkId(networkId);\n      this.wyvernProxyRegistry._invalidateContractInstance();\n      this.wyvernProxyRegistry._setNetworkId(networkId);\n    }\n    /**\n     * Get user Ethereum addresses available through the supplied web3 provider available for sending transactions.\n     * @return  An array of available user Ethereum addresses.\n     */\n  }, {\n    key: \"getAvailableAddressesAsync\",\n    value: function getAvailableAddressesAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var availableAddresses;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._web3Wrapper.getAvailableAddressesAsync();\n            case 2:\n              availableAddresses = _context.sent;\n              return _context.abrupt(\"return\", availableAddresses);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Signs an orderHash and returns its elliptic curve signature.\n     * This method currently supports TestRPC, Geth and Parity above and below V1.6.6\n     * @param   orderHash       Hex encoded orderHash to sign.\n     * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address\n     *          must be available via the Web3.Provider supplied to wyvernProtocol.js.\n     * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.\n     */\n  }, {\n    key: \"signOrderHashAsync\",\n    value: function signOrderHashAsync(orderHash, signerAddress) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var msgHashHex, nodeVersion, isParityNode, isTestRpc, orderHashBuff, msgHashBuff, signature, validVParamValues, ecSignatureVRS, isValidVRSSignature, ecSignatureRSV, isValidRSVSignature;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              assert_1.assert.isHexString('orderHash', orderHash);\n              /* await assert.isSenderAddressAsync('signerAddress', signerAddress, this._web3Wrapper); */\n              _context2.next = 3;\n              return this._web3Wrapper.getNodeVersionAsync();\n            case 3:\n              nodeVersion = _context2.sent;\n              isParityNode = utils_2.utils.isParityNode(nodeVersion);\n              isTestRpc = utils_2.utils.isTestRpc(nodeVersion);\n              if (isParityNode || isTestRpc) {\n                // Parity and TestRpc nodes add the personalMessage prefix itself\n                msgHashHex = orderHash;\n              } else {\n                orderHashBuff = ethUtil.toBuffer(orderHash);\n                msgHashBuff = ethUtil.hashPersonalMessage(orderHashBuff);\n                msgHashHex = ethUtil.bufferToHex(msgHashBuff);\n              }\n              _context2.next = 9;\n              return this._web3Wrapper.signMessageAsync(signerAddress, msgHashHex);\n            case 9:\n              signature = _context2.sent;\n              // HACK: There is no consensus on whether the signatureHex string should be formatted as\n              // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n              // return the signature params in different orders. In order to support all client implementations,\n              // we parse the signature in both ways, and evaluate if either one is a valid signature.\n              validVParamValues = [27, 28];\n              ecSignatureVRS = signature_utils_1.signatureUtils.parseSignatureHexAsVRS(signature);\n              if (!_.includes(validVParamValues, ecSignatureVRS.v)) {\n                _context2.next = 16;\n                break;\n              }\n              isValidVRSSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureVRS, signerAddress);\n              if (!isValidVRSSignature) {\n                _context2.next = 16;\n                break;\n              }\n              return _context2.abrupt(\"return\", ecSignatureVRS);\n            case 16:\n              ecSignatureRSV = signature_utils_1.signatureUtils.parseSignatureHexAsRSV(signature);\n              if (!_.includes(validVParamValues, ecSignatureRSV.v)) {\n                _context2.next = 21;\n                break;\n              }\n              isValidRSVSignature = WyvernProtocol.isValidSignature(orderHash, ecSignatureRSV, signerAddress);\n              if (!isValidRSVSignature) {\n                _context2.next = 21;\n                break;\n              }\n              return _context2.abrupt(\"return\", ecSignatureRSV);\n            case 21:\n              throw new Error(types_1.WyvernProtocolError.InvalidSignature);\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n  }, {\n    key: \"awaitTransactionMinedAsync\",\n    value: function awaitTransactionMinedAsync(txHash) {\n      var pollingIntervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var timeoutMs = arguments.length > 2 ? arguments[2] : undefined;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this = this;\n        var timeoutExceeded, txReceiptPromise;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              timeoutExceeded = false;\n              if (timeoutMs) {\n                setTimeout(function () {\n                  return timeoutExceeded = true;\n                }, timeoutMs);\n              }\n              txReceiptPromise = new Promise(function (resolve, reject) {\n                var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!timeoutExceeded) {\n                            _context3.next = 3;\n                            break;\n                          }\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return _context3.abrupt(\"return\", reject(types_1.WyvernProtocolError.TransactionMiningTimeout));\n                        case 3:\n                          _context3.next = 5;\n                          return this._web3Wrapper.getTransactionReceiptIfExistsAsync(txHash);\n                        case 5:\n                          transactionReceipt = _context3.sent;\n                          if (transactionReceipt && this._abiDecoder) {\n                            utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                            logsWithDecodedArgs = _.map(transactionReceipt.logs, this._abiDecoder.tryToDecodeLogOrNoop.bind(this._abiDecoder));\n                            transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), {\n                              logs: logsWithDecodedArgs\n                            });\n                            resolve(transactionReceiptWithDecodedLogArgs);\n                          }\n                        case 7:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }, _callee3, this);\n                  }));\n                }, pollingIntervalMs, function () {\n                  return {};\n                });\n              });\n              return _context4.abrupt(\"return\", txReceiptPromise);\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n    }\n    /**\n     * Gets the authenticated proxy contract for a specific account address\n     * @param accountAddress address to retrieve the proxy contract from\n     */\n  }, {\n    key: \"getAuthenticatedProxy\",\n    value: function getAuthenticatedProxy(accountAddress) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var proxyAddress;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.wyvernProxyRegistry.proxies(accountAddress).callAsync();\n            case 2:\n              proxyAddress = _context5.sent;\n              return _context5.abrupt(\"return\", new authenticated_proxy_1.AuthenticatedProxyContract(proxyAddress, this._provider));\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n  }], [{\n    key: \"getExchangeContractAddress\",\n    value: function getExchangeContractAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernExchange;\n    }\n  }, {\n    key: \"getProxyRegistryContractAddress\",\n    value: function getProxyRegistryContractAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernProxyRegistry;\n    }\n  }, {\n    key: \"getTokenContractAddress\",\n    value: function getTokenContractAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernToken;\n    }\n  }, {\n    key: \"getDAOContractAddress\",\n    value: function getDAOContractAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernDAO;\n    }\n  }, {\n    key: \"getAtomicizerContractAddress\",\n    value: function getAtomicizerContractAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernAtomicizer;\n    }\n  }, {\n    key: \"getTokenTransferProxyAddress\",\n    value: function getTokenTransferProxyAddress(network) {\n      return constants_1.constants.DEPLOYED[network].WyvernTokenTransferProxy;\n    }\n    /**\n     * Verifies that the elliptic curve signature `signature` was generated\n     * by signing `data` with the private key corresponding to the `signerAddress` address.\n     * @param   data          The hex encoded data signed by the supplied signature.\n     * @param   signature     An object containing the elliptic curve signature parameters.\n     * @param   signerAddress The hex encoded address that signed the data, producing the supplied signature.\n     * @return  Whether the signature is valid for the supplied signerAddress and data.\n     */\n  }, {\n    key: \"isValidSignature\",\n    value: function isValidSignature(data, signature, signerAddress) {\n      assert_1.assert.isHexString('data', data);\n      assert_1.assert.doesConformToSchema('signature', signature, schemas_1.schemas.ecSignatureSchema);\n      assert_1.assert.isETHAddressHex('signerAddress', signerAddress);\n      var isValidSignature = signature_utils_1.signatureUtils.isValidSignature(data, signature, signerAddress);\n      return isValidSignature;\n    }\n    /**\n     * Generates a pseudo-random 256-bit salt.\n     * The salt can be included in an 0x order, ensuring that the order generates a unique orderHash\n     * and will not collide with other outstanding orders that are identical in all other parameters.\n     * @return  A pseudo-random 256-bit number that can be used as a salt.\n     */\n  }, {\n    key: \"generatePseudoRandomSalt\",\n    value: function generatePseudoRandomSalt() {\n      // BigNumber.random returns a pseudo-random number between 0 & 1 with a passed in number of decimal places.\n      // Source: https://mikemcl.github.io/bignumber.js/#random\n      var randomNumber = utils_1.BigNumber.random(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT);\n      var factor = new utils_1.BigNumber(10).pow(constants_1.constants.MAX_DIGITS_IN_UNSIGNED_256_INT - 1);\n      var salt = randomNumber.times(factor).integerValue();\n      return salt;\n    }\n    /**\n     * Checks if the supplied hex encoded order hash is valid.\n     * Note: Valid means it has the expected format, not that an order with the orderHash exists.\n     * Use this method when processing orderHashes submitted as user input.\n     * @param   orderHash    Hex encoded orderHash.\n     * @return  Whether the supplied orderHash has the expected format.\n     */\n  }, {\n    key: \"isValidOrderHash\",\n    value: function isValidOrderHash(orderHash) {\n      // Since this method can be called to check if any arbitrary string conforms to an orderHash's\n      // format, we only assert that we were indeed passed a string.\n      assert_1.assert.isString('orderHash', orderHash);\n      var schemaValidator = new json_schemas_1.SchemaValidator();\n      var isValidOrderHash = schemaValidator.isValid(orderHash, schemas_1.schemas.orderHashSchema);\n      return isValidOrderHash;\n    }\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n  }, {\n    key: \"toUnitAmount\",\n    value: function toUnitAmount(amount, decimals) {\n      assert_1.assert.isValidBaseUnitAmount('amount', amount);\n      assert_1.assert.isNumber('decimals', decimals);\n      var aUnit = new utils_1.BigNumber(10).pow(decimals);\n      var unit = amount.div(aUnit);\n      return unit;\n    }\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n  }, {\n    key: \"toBaseUnitAmount\",\n    value: function toBaseUnitAmount(amount, decimals) {\n      assert_1.assert.isBigNumber('amount', amount);\n      assert_1.assert.isNumber('decimals', decimals);\n      var unit = new utils_1.BigNumber(10).pow(decimals);\n      var baseUnitAmount = amount.times(unit);\n      var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n      if (hasDecimals) {\n        throw new Error(\"Invalid unit amount: \".concat(amount.toString(), \" - Too many decimal places\"));\n      }\n      return baseUnitAmount;\n    }\n    /**\n     * Computes the orderHash for a supplied order.\n     * @param   order   An object that conforms to the Order or SignedOrder interface definitions.\n     * @return  The resulting orderHash from hashing the supplied order.\n     */\n  }, {\n    key: \"getOrderHashHex\",\n    value: function getOrderHashHex(order) {\n      var orderHashHex = utils_2.utils.getOrderHashHex(order);\n      return orderHashHex;\n    }\n    /**\n     * Computes the assetHash for a supplied asset.\n     */\n  }, {\n    key: \"getAssetHashHex\",\n    value: function getAssetHashHex(assetHash, schema) {\n      var assetHashHex = utils_2.utils.getAssetHashHex(assetHash, schema);\n      return assetHashHex;\n    }\n  }]);\n  return WyvernProtocol;\n}();\nWyvernProtocol.NULL_ADDRESS = constants_1.constants.NULL_ADDRESS;\nWyvernProtocol.MAX_UINT_256 = new utils_1.BigNumber(2).pow(256).minus(1);\n/**\n * Encodes the replacementPattern for a supplied ABI and replace kind\n * @param   abi AnnotatedFunctionABI\n * @param   replaceKind Parameter kind to replace\n * @return  The resulting encoded replacementPattern\n */\nWyvernProtocol.encodeReplacementPattern = function (abi) {\n  var replaceKind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.FunctionInputKind.Replaceable;\n  var encodeToBytes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var output = [];\n  var data = [];\n  var dynamicOffset = abi.inputs.reduce(function (len, _ref) {\n    var type = _ref.type;\n    var match = type.match(/\\[(.+)\\]$/);\n    return len + (match ? parseInt(match[1], 10) * 32 : 32);\n  }, 0);\n  abi.inputs.map(function (_ref2) {\n    var kind = _ref2.kind,\n      type = _ref2.type,\n      value = _ref2.value;\n    return {\n      bitmask: kind === replaceKind ? 255 : 0,\n      type: ethABI.elementaryName(type),\n      value: value !== undefined ? value : WyvernProtocol.generateDefaultValue(type)\n    };\n  }).reduce(function (offset, _ref3) {\n    var bitmask = _ref3.bitmask,\n      type = _ref3.type,\n      value = _ref3.value;\n    // The 0xff bytes in the mask select the replacement bytes. All other bytes are 0x00.\n    var cur = Buffer.alloc(ethABI.encodeSingle(type, value).length).fill(bitmask);\n    if (ethABI.isDynamic(type)) {\n      if (bitmask) {\n        throw new Error('Replacement is not supported for dynamic parameters.');\n      }\n      output.push(Buffer.alloc(ethABI.encodeSingle('uint256', dynamicOffset).length));\n      data.push(cur);\n      return offset + cur.length;\n    }\n    output.push(cur);\n    return offset;\n  }, dynamicOffset);\n  // 4 initial bytes of 0x00 for the method hash.\n  var methodIdMask = Buffer.alloc(4);\n  var mask = Buffer.concat([methodIdMask, Buffer.concat(output.concat(data))]);\n  return encodeToBytes ? \"0x\".concat(mask.toString('hex')) : mask.map(function (b) {\n    return b ? 1 : 0;\n  }).join('');\n};\n/**\n * Encodes the atomicized replacementPattern for a supplied ABI and replace kind\n * @param   abis array of AnnotatedFunctionABI\n * @param   replaceKind Parameter kind to replace\n * @return  The resulting encoded replacementPattern\n */\nWyvernProtocol.encodeAtomicizedReplacementPattern = function (abis) {\n  var replaceKind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.FunctionInputKind.Replaceable;\n  var allowReplaceByte = '1';\n  var doNotAllowReplaceByte = '0';\n  /* Four bytes for method ID. */\n  var maskArr = [doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte, doNotAllowReplaceByte];\n  var encodedUint256 = ethABI.encodeSingle(ethABI.elementaryName('uint256'), WyvernProtocol.generateDefaultValue('uint256'));\n  var dataLocationSize = encodedUint256.length;\n  var dynamicArgumentLengthSize = encodedUint256.length;\n  // See https://solidity.readthedocs.io/en/develop/abi-spec.html#examples\n  // Prepare dymanic types to be passed in (they need locations of their data parts). 4 for addresses, values, calldata lengths, calldatas\n  maskArr.push(doNotAllowReplaceByte.repeat(dataLocationSize * 4));\n  // Length of addresses array\n  maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n  // Addresses should not be replaced\n  var encoded = ethABI.encodeSingle(ethABI.elementaryName('address'), WyvernProtocol.generateDefaultValue('address'));\n  maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n  // Length of values array\n  maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n  // Add the values...\n  encoded = ethABI.encodeSingle(ethABI.elementaryName('uint'), WyvernProtocol.generateDefaultValue('uint'));\n  maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n  // Length of calldata lengths array\n  maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n  // ... and calldata lengths\n  maskArr.push(doNotAllowReplaceByte.repeat(encoded.length * abis.length));\n  // Length of replacementPatterns\n  maskArr.push(doNotAllowReplaceByte.repeat(dynamicArgumentLengthSize));\n  // Raw replacementPatterns\n  var replacementBytes = [];\n  abis.map(function (abi) {\n    var replacement = WyvernProtocol.encodeReplacementPattern(abi, replaceKind, false);\n    replacementBytes.push(replacement);\n  });\n  var concatenatedReplacementPatterns = replacementBytes.join('');\n  maskArr.push(concatenatedReplacementPatterns);\n  if (concatenatedReplacementPatterns.length % 32 !== 0) {\n    // Pad replacementPatterns to nearest multiple of 32\n    maskArr.push(doNotAllowReplaceByte.repeat(32 - concatenatedReplacementPatterns.length % 32));\n  }\n  var mask = maskArr.reduce(function (x, y) {\n    return x + y;\n  }, '');\n  var ret = [];\n  /* Encode into bytes. */\n  var _iterator = _createForOfIteratorHelper(mask),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var char = _step.value;\n      var byte = char === allowReplaceByte ? 255 : 0;\n      var buf = Buffer.alloc(1);\n      buf.writeUInt8(byte, 0);\n      ret.push(buf);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return '0x' + Buffer.concat(ret).toString('hex');\n};\n/**\n * Computes the default value for a type\n * @param type The ABI type to calculate a default value for\n * @return The default value for that type\n */\nWyvernProtocol.generateDefaultValue = function (type) {\n  switch (type) {\n    case 'address':\n    case 'bytes20':\n      /* Null address is sometimes checked in transfer calls. */\n      // But we need to use 0x000 because bitwise XOR won't work if there's a 0 in the actual address, since it will be replaced as 1 OR 0 = 1\n      return '0x0000000000000000000000000000000000000000';\n    case 'bytes32':\n      return '0x0000000000000000000000000000000000000000000000000000000000000000';\n    case 'bool':\n      return false;\n    case 'int':\n    case 'uint':\n    case 'uint8':\n    case 'uint16':\n    case 'uint32':\n    case 'uint64':\n    case 'uint256':\n      return 0;\n    default:\n      throw new Error('Default value not yet implemented for type: ' + type);\n  }\n};\n__decorate([decorators_1.decorators.syncWyvernProtocolErrorHandler], WyvernProtocol, \"getOrderHashHex\", null);\nexports.WyvernProtocol = WyvernProtocol;","map":null,"metadata":{},"sourceType":"script"}