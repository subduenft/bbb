{"ast":null,"code":"var TrieNode = require('./trieNode');\nvar ethUtil = require('ethereumjs-util');\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\n\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n    cb(null, p);\n  });\n};\n\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n        return cb(null, node.value);\n      }\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n        key = key.slice(embeddedNode.key.length);\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n      cld = node.value;\n      key = key.slice(node.key.length);\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n  cb(new Error('Unexpected end of proof'));\n};","map":null,"metadata":{},"sourceType":"script"}