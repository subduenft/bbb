{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requireOrderCalldataCanMatch = exports.requireOrdersCanMatch = exports.MAX_ERROR_LENGTH = void 0;\nvar constants_1 = require(\"./constants\");\nexports.MAX_ERROR_LENGTH = 120;\n/**\n * This file reproduces Solidity methods to make debugging easier\n */\nvar Side;\n(function (Side) {\n  Side[Side[\"Buy\"] = 0] = \"Buy\";\n  Side[Side[\"Sell\"] = 1] = \"Sell\";\n})(Side || (Side = {}));\nvar SaleKind;\n(function (SaleKind) {\n  SaleKind[SaleKind[\"FixedPrice\"] = 0] = \"FixedPrice\";\n  SaleKind[SaleKind[\"DutchAuction\"] = 1] = \"DutchAuction\";\n})(SaleKind || (SaleKind = {}));\nvar SaleKindInterface = {\n  Side: Side,\n  SaleKind: SaleKind,\n  validateParameters: function validateParameters(saleKind, expirationTime) {\n    return saleKind === SaleKind.FixedPrice || expirationTime > 0;\n  },\n  canSettleOrder: function canSettleOrder(listingTime, expirationTime) {\n    var now = Math.round(Date.now() / 1000);\n    return listingTime < now && (expirationTime === 0 || now < expirationTime);\n  }\n};\n/**\n * Debug the `ordersCanMatch` part of Wyvern\n * @param buy Buy order for debugging\n * @param sell Sell order for debugging\n */\nfunction requireOrdersCanMatch(client, _a) {\n  var buy = _a.buy,\n    sell = _a.sell,\n    accountAddress = _a.accountAddress;\n  return __awaiter(this, void 0, void 0, function () {\n    var result;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4 /*yield*/, client.wyvernExchange.ordersCanMatch_([buy.exchange, buy.maker, buy.taker, buy.feeRecipient, buy.target, buy.staticTarget, buy.paymentToken, sell.exchange, sell.maker, sell.taker, sell.feeRecipient, sell.target, sell.staticTarget, sell.paymentToken], [buy.makerRelayerFee, buy.takerRelayerFee, buy.makerProtocolFee, buy.takerProtocolFee, buy.basePrice, buy.extra, buy.listingTime, buy.expirationTime, buy.salt, sell.makerRelayerFee, sell.takerRelayerFee, sell.makerProtocolFee, sell.takerProtocolFee, sell.basePrice, sell.extra, sell.listingTime, sell.expirationTime, sell.salt], [buy.feeMethod, buy.side, buy.saleKind, buy.howToCall, sell.feeMethod, sell.side, sell.saleKind, sell.howToCall], buy.calldata, sell.calldata, buy.replacementPattern, sell.replacementPattern, buy.staticExtradata, sell.staticExtradata).callAsync({\n            from: accountAddress\n          })];\n        case 1:\n          result = _b.sent();\n          if (result) {\n            return [2 /*return*/];\n          }\n\n          if (!(+buy.side == +SaleKindInterface.Side.Buy && +sell.side == +SaleKindInterface.Side.Sell)) {\n            throw new Error(\"Must be opposite-side\");\n          }\n          if (!(buy.feeMethod == sell.feeMethod)) {\n            throw new Error(\"Must use same fee method\");\n          }\n          if (!(buy.paymentToken == sell.paymentToken)) {\n            throw new Error(\"Must use same payment token\");\n          }\n          if (!(sell.taker == constants_1.NULL_ADDRESS || sell.taker == buy.maker)) {\n            throw new Error(\"Sell taker must be null or matching buy maker\");\n          }\n          if (!(buy.taker == constants_1.NULL_ADDRESS || buy.taker == sell.maker)) {\n            throw new Error(\"Buy taker must be null or matching sell maker\");\n          }\n          if (!(sell.feeRecipient == constants_1.NULL_ADDRESS && buy.feeRecipient != constants_1.NULL_ADDRESS || sell.feeRecipient != constants_1.NULL_ADDRESS && buy.feeRecipient == constants_1.NULL_ADDRESS)) {\n            throw new Error(\"One order must be maker and the other must be taker\");\n          }\n          if (!(buy.target == sell.target)) {\n            throw new Error(\"Must match target\");\n          }\n          if (!(buy.howToCall == sell.howToCall)) {\n            throw new Error(\"Must match howToCall\");\n          }\n          if (!SaleKindInterface.canSettleOrder(+buy.listingTime, +buy.expirationTime)) {\n            throw new Error(\"Buy-side order is set in the future or expired\");\n          }\n          if (!SaleKindInterface.canSettleOrder(+sell.listingTime, +sell.expirationTime)) {\n            throw new Error(\"Sell-side order is set in the future or expired\");\n          }\n          // Handle default, which is likely now() being diff than local time\n          throw new Error(\"Error creating your order. Check that your system clock is set to the current date and time before you try again.\");\n      }\n    });\n  });\n}\nexports.requireOrdersCanMatch = requireOrdersCanMatch;\n/**\n * Debug the `orderCalldataCanMatch` part of Wyvern\n * @param buy Buy order for debugging\n * @param sell Sell Order for debugging\n */\nfunction requireOrderCalldataCanMatch(client, _a) {\n  var buy = _a.buy,\n    sell = _a.sell;\n  return __awaiter(this, void 0, void 0, function () {\n    var result;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4 /*yield*/, client.wyvernExchange.orderCalldataCanMatch(buy.calldata, buy.replacementPattern, sell.calldata, sell.replacementPattern).callAsync()];\n        case 1:\n          result = _b.sent();\n          if (result) {\n            return [2 /*return*/];\n          }\n\n          throw new Error(\"Unable to match offer data with auction data.\");\n      }\n    });\n  });\n}\nexports.requireOrderCalldataCanMatch = requireOrderCalldataCanMatch;","map":null,"metadata":{},"sourceType":"script"}