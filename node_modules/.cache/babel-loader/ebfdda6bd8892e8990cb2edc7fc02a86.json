{"ast":null,"code":"'use strict';\n\nvar forEach = require('for-each');\nvar isES5 = typeof Object.defineProperty === 'function';\nvar gPO = Object.getPrototypeOf;\nvar sPO = Object.setPrototypeOf;\nvar hasProto = require('has-proto')() || typeof gPO === 'function' && gPO([]) === Array.prototype;\nif (!isES5 || !hasProto) {\n  throw new TypeError('util.promisify requires a true ES5+ environment, that also supports `__proto__` and/or `Object.getPrototypeOf`');\n}\nvar getOwnPropertyDescriptors = require('object.getownpropertydescriptors');\nif (typeof Promise !== 'function') {\n  throw new TypeError('`Promise` must be globally available for util.promisify to work.');\n}\nvar oDP = Object.defineProperty;\nvar $Promise = Promise;\nvar $TypeError = TypeError;\nvar safeConcat = require('safe-array-concat');\nvar callBound = require('call-bind/callBound');\nvar $slice = callBound('Array.prototype.slice');\nvar hasSymbols = require('has-symbols/shams')();\n\n// eslint-disable-next-line no-restricted-properties\nvar kCustomPromisifiedSymbol = hasSymbols ? Symbol['for']('nodejs.util.promisify.custom') : null;\nvar kCustomPromisifyArgsSymbol = hasSymbols ? Symbol('customPromisifyArgs') : null;\nmodule.exports = function promisify(orig) {\n  if (typeof orig !== 'function') {\n    var error = new $TypeError('The \"original\" argument must be of type function');\n    error.code = 'ERR_INVALID_ARG_TYPE';\n    error.toString = function value() {\n      return this.name + '[' + this.code + ']: ' + this.message;\n    };\n    throw error;\n  }\n  if (hasSymbols && orig[kCustomPromisifiedSymbol]) {\n    var customFunction = orig[kCustomPromisifiedSymbol];\n    if (typeof customFunction !== 'function') {\n      var customError = $TypeError('The [util.promisify.custom] property must be of type function.');\n      customError.code = 'ERR_INVALID_ARG_TYPE';\n      customError.toString = function value() {\n        return this.name + '[' + this.code + ']: ' + this.message;\n      };\n      throw customError;\n    }\n    oDP(customFunction, kCustomPromisifiedSymbol, {\n      configurable: true,\n      enumerable: false,\n      value: customFunction,\n      writable: false\n    });\n    return customFunction;\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['stdout', 'stderr'] for child_process.exec.\n  var argumentNames = orig[kCustomPromisifyArgsSymbol];\n  var promisified = function fn() {\n    var args = $slice(arguments);\n    var self = this; // eslint-disable-line no-invalid-this\n    return new $Promise(function (resolve, reject) {\n      orig.apply(self, safeConcat(args, function (err) {\n        var values = arguments.length > 1 ? $slice(arguments, 1) : [];\n        if (err) {\n          reject(err);\n        } else if (typeof argumentNames !== 'undefined' && values.length > 1) {\n          var obj = {};\n          forEach(argumentNames, function (name, index) {\n            obj[name] = values[index];\n          });\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      }));\n    });\n  };\n  if (typeof sPO === 'function' && typeof gPO === 'function') {\n    sPO(promisified, gPO(orig));\n  } else {\n    promisified.__proto__ = orig.__proto__; // eslint-disable-line no-proto\n  }\n\n  oDP(promisified, kCustomPromisifiedSymbol, {\n    configurable: true,\n    enumerable: false,\n    value: promisified,\n    writable: false\n  });\n  var descriptors = getOwnPropertyDescriptors(orig);\n  forEach(descriptors, function (k, v) {\n    try {\n      oDP(promisified, k, v);\n    } catch (e) {\n      // handle nonconfigurable function properties\n    }\n  });\n  return promisified;\n};\nmodule.exports.custom = kCustomPromisifiedSymbol;\nmodule.exports.customPromisifyArgs = kCustomPromisifyArgsSymbol;","map":null,"metadata":{},"sourceType":"script"}