{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DynamicBytesDataType = void 0;\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar blob_1 = require(\"../abstract_data_types/types/blob\");\nvar constants_1 = require(\"../utils/constants\");\nvar DynamicBytesDataType = /*#__PURE__*/function (_blob_1$AbstractBlobD) {\n  _inherits(DynamicBytesDataType, _blob_1$AbstractBlobD);\n  function DynamicBytesDataType(dataItem, dataTypeFactory) {\n    var _this;\n    _classCallCheck(this, DynamicBytesDataType);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DynamicBytesDataType).call(this, dataItem, dataTypeFactory, DynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME));\n    if (!DynamicBytesDataType.matchType(dataItem.type)) {\n      throw new Error(\"Tried to instantiate Dynamic Bytes with bad input: \".concat(dataItem));\n    }\n    return _this;\n  }\n  _createClass(DynamicBytesDataType, [{\n    key: \"encodeValue\",\n    // Disable prefer-function-over-method for inherited abstract methods.\n    /* tslint:disable prefer-function-over-method */\n    value: function encodeValue(value) {\n      // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n      // 1/3 Construct the length\n      DynamicBytesDataType._sanityCheckValue(value);\n      var valueBuf = ethUtil.toBuffer(value);\n      var wordsToStoreValuePadded = Math.ceil(valueBuf.byteLength / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n      var bytesToStoreValuePadded = wordsToStoreValuePadded * constants_1.constants.EVM_WORD_WIDTH_IN_BYTES;\n      var lengthBuf = ethUtil.toBuffer(valueBuf.byteLength);\n      var lengthBufPadded = ethUtil.setLengthLeft(lengthBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n      // 2/3 Construct the value\n      var valueBufPadded = ethUtil.setLengthRight(valueBuf, bytesToStoreValuePadded);\n      // 3/3 Combine length and value\n      var encodedValue = Buffer.concat([lengthBufPadded, valueBufPadded]);\n      return encodedValue;\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(calldata) {\n      // Encoded value is of the form: <length><value>, with each field padded to be word-aligned.\n      // 1/2 Decode length\n      var lengthBuf = calldata.popWord();\n      var lengthHex = ethUtil.bufferToHex(lengthBuf);\n      var length = parseInt(lengthHex, constants_1.constants.HEX_BASE);\n      // 2/2 Decode value\n      var wordsToStoreValuePadded = Math.ceil(length / constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n      var valueBufPadded = calldata.popWords(wordsToStoreValuePadded);\n      var valueBuf = valueBufPadded.slice(0, length);\n      var value = ethUtil.bufferToHex(valueBuf);\n      DynamicBytesDataType._sanityCheckValue(value);\n      return value;\n    }\n  }, {\n    key: \"getDefaultValue\",\n    value: function getDefaultValue() {\n      return DynamicBytesDataType._DEFAULT_VALUE;\n    }\n  }, {\n    key: \"getSignatureType\",\n    value: function getSignatureType() {\n      return ethereum_types_1.SolidityTypes.Bytes;\n    }\n  }], [{\n    key: \"matchType\",\n    value: function matchType(type) {\n      return type === ethereum_types_1.SolidityTypes.Bytes;\n    }\n  }, {\n    key: \"_sanityCheckValue\",\n    value: function _sanityCheckValue(value) {\n      if (typeof value !== 'string') {\n        return;\n      }\n      if (!_.startsWith(value, '0x')) {\n        throw new Error(\"Tried to encode non-hex value. Value must include '0x' prefix.\");\n      } else if (value.length % 2 !== 0) {\n        throw new Error(\"Tried to assign \".concat(value, \", which is contains a half-byte. Use full bytes only.\"));\n      }\n    }\n  }]);\n  return DynamicBytesDataType;\n}(blob_1.AbstractBlobDataType);\nexports.DynamicBytesDataType = DynamicBytesDataType;\nDynamicBytesDataType._SIZE_KNOWN_AT_COMPILE_TIME = false;\nDynamicBytesDataType._DEFAULT_VALUE = '0x';","map":null,"metadata":{},"sourceType":"script"}