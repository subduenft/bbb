{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Calldata = void 0;\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar pointer_1 = require(\"./blocks/pointer\");\nvar set_1 = require(\"./blocks/set\");\nvar iterator_1 = require(\"./iterator\");\nvar Calldata = /*#__PURE__*/function () {\n  function Calldata(rules) {\n    _classCallCheck(this, Calldata);\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n  _createClass(Calldata, [{\n    key: \"setRoot\",\n    value: function setRoot(block) {\n      this._root = block;\n    }\n    /**\n     * Sets the selector to be prepended onto the calldata.\n     * If the root block was created by a Method then a selector will likely be set.\n     */\n  }, {\n    key: \"setSelector\",\n    value: function setSelector(selector) {\n      if (!_.startsWith(selector, '0x')) {\n        throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n      } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n        throw new Error(\"Invalid selector '\".concat(selector, \"'\"));\n      }\n      this._selector = selector;\n    }\n    /**\n     * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n     * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n     * If the `annotate` flag is set then this will return human-readable calldata.\n     * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // Sanity check: root block must be set\n      if (this._root === undefined) {\n        throw new Error('expected root');\n      }\n      // Optimize, if flag set\n      if (this._rules.shouldOptimize) {\n        this._optimize();\n      }\n      // Set offsets\n      var iterator = new iterator_1.CalldataIterator(this._root);\n      var offset = 0;\n      var _iterator = _createForOfIteratorHelper(iterator),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var block = _step.value;\n          block.setOffset(offset);\n          offset += block.getSizeInBytes();\n        }\n        // Generate hex string\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n      return hexString;\n    }\n    /**\n     * There are three types of calldata blocks: Blob, Set and Pointer.\n     * Scenarios arise where distinct pointers resolve to identical values.\n     * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n     * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n     *\n     * Example #1:\n     *  function f(string[], string[])\n     *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n     *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n     *\n     * Example #2:\n     *  function f(string[], string)\n     *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n     *  The string \"foo\" will only be included in the calldata once.\n     *\n     * Example #3:\n     *  function f((string, uint, bytes), string, uint, bytes)\n     *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n     *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n     *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n     *\n     * @TODO #1:\n     *   This optimization strategy handles blocks that are exact duplicates of one another.\n     *   But what if some block is a combination of two other blocks? Or a subset of another block?\n     *   This optimization problem is not much different from the current implemetation.\n     *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n     *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n     *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n     *   This shouldn't be a problem but further investigation should be done.\n     *\n     * @TODO #2:\n     *   To be done as a follow-up to @TODO #1.\n     *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n     *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n     *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n     *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n     *\n     */\n  }, {\n    key: \"_optimize\",\n    value: function _optimize() {\n      // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n      if (this._root === undefined) {\n        throw new Error('expected root');\n      }\n      var iterator = new iterator_1.ReverseCalldataIterator(this._root);\n      // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n      var blocksByHash = {};\n      var _iterator2 = _createForOfIteratorHelper(iterator),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var block = _step2.value;\n          // If a block is a pointer and its value has already been observed, then update\n          // the pointer to resolve to the existing value.\n          if (block instanceof pointer_1.PointerCalldataBlock) {\n            var dependencyBlockHashBuf = block.getDependency().computeHash();\n            var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n            if (dependencyBlockHash in blocksByHash) {\n              var blockWithSameHash = blocksByHash[dependencyBlockHash];\n              if (blockWithSameHash !== block.getDependency()) {\n                block.setAlias(blockWithSameHash);\n              }\n            }\n            continue;\n          }\n          // This block has not been seen. Record its hash.\n          var blockHashBuf = block.computeHash();\n          var blockHash = ethUtil.bufferToHex(blockHashBuf);\n          if (!(blockHash in blocksByHash)) {\n            blocksByHash[blockHash] = block;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_toEvmCompatibeCallDataHex\",\n    value: function _toEvmCompatibeCallDataHex() {\n      // Sanity check: must have a root block.\n      if (this._root === undefined) {\n        throw new Error('expected root');\n      }\n      // Construct an array of buffers (one buffer for each block).\n      var selectorBuffer = ethUtil.toBuffer(this._selector || '0x');\n      var valueBufs = [selectorBuffer];\n      var iterator = new iterator_1.CalldataIterator(this._root);\n      var _iterator3 = _createForOfIteratorHelper(iterator),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var block = _step3.value;\n          valueBufs.push(block.toBuffer());\n        }\n        // Create hex from buffer array.\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var combinedBuffers = Buffer.concat(valueBufs);\n      var hexValue = ethUtil.bufferToHex(combinedBuffers);\n      return hexValue;\n    }\n    /**\n     * Returns human-readable calldata.\n     *\n     * Example:\n     *   simpleFunction(string[], string[])\n     *   strings = [\"Hello\", \"World\"]\n     *   simpleFunction(strings, strings)\n     *\n     * Output:\n     *   0xbb4f12e3\n     *                                                                                      ### simpleFunction\n     *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n     *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n     *\n     *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n     *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n     *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n     *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n     *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n     *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n     *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n     */\n  }, {\n    key: \"_toHumanReadableCallData\",\n    value: function _toHumanReadableCallData() {\n      // Sanity check: must have a root block.\n      if (this._root === undefined) {\n        throw new Error('expected root');\n      }\n      // Constants for constructing annotated string\n      var offsetPadding = 10;\n      var valuePadding = 74;\n      var namePadding = 80;\n      var evmWordStartIndex = 0;\n      var emptySize = 0;\n      // Construct annotated calldata\n      var hexValue = \"\".concat(this._selector);\n      var offset = 0;\n      var functionName = this._root.getName();\n      var iterator = new iterator_1.CalldataIterator(this._root);\n      var _iterator4 = _createForOfIteratorHelper(iterator),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var block = _step4.value;\n          // Process each block 1 word at a time\n          var size = block.getSizeInBytes();\n          var name = block.getName();\n          var parentName = block.getParentName();\n          var prettyName = name.replace(\"\".concat(parentName, \".\"), '').replace(\"\".concat(functionName, \".\"), '');\n          // Resulting line will be <offsetStr><valueStr><nameStr>\n          var offsetStr = '';\n          var valueStr = '';\n          var nameStr = '';\n          var lineStr = '';\n          if (size === emptySize) {\n            // This is a Set block with no header.\n            // For example, a tuple or an array with a defined length.\n            offsetStr = ' '.repeat(offsetPadding);\n            valueStr = ' '.repeat(valuePadding);\n            nameStr = \"### \".concat(prettyName.padEnd(namePadding));\n            lineStr = \"\\n\".concat(offsetStr).concat(valueStr).concat(nameStr);\n          } else {\n            // This block has at least one word of value.\n            offsetStr = \"0x\".concat(offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n            valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n            if (block instanceof set_1.SetCalldataBlock) {\n              nameStr = \"### \".concat(prettyName.padEnd(namePadding));\n              lineStr = \"\\n\".concat(offsetStr).concat(valueStr).concat(nameStr);\n            } else {\n              nameStr = \"    \".concat(prettyName.padEnd(namePadding));\n              lineStr = \"\".concat(offsetStr).concat(valueStr).concat(nameStr);\n            }\n          }\n          // This block has a value that is more than 1 word.\n          for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n            offsetStr = \"0x\".concat((offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n            valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n            nameStr = ' '.repeat(namePadding);\n            lineStr = \"\".concat(lineStr, \"\\n\").concat(offsetStr).concat(valueStr).concat(nameStr);\n          }\n          // Append to hex value\n          hexValue = \"\".concat(hexValue, \"\\n\").concat(lineStr);\n          offset += size;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return hexValue;\n    }\n  }]);\n  return Calldata;\n}();\nexports.Calldata = Calldata;","map":null,"metadata":{},"sourceType":"script"}