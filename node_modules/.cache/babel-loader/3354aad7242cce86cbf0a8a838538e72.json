{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiUtils = void 0;\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n// Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\nfunction parseEthersParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n      var result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(\"tuple(\".concat(result.types.join(','), \")\").concat(suffix));\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n}\n// returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n    var newType = _.trimEnd(type, '[]');\n    for (var i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    }\n    // For tuples, we iterate through the underlying values and check each\n    // one individually.\n    var types = splitTupleTypes(type);\n    if (types.length !== name.names.length) {\n      throw new Error(\"Internal error: parameter types/names length mismatch (\".concat(types.length, \" != \").concat(name.names.length, \")\"));\n    }\n    for (var _i = 0; _i < types.length; _i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      var nestedName = _.isString(name.names[_i]) ? name.names[_i] : name.names[_i].name;\n      if (!isAbiDataEqual(name.names[_i], types[_i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n  return _.isEqual(x, y);\n}\n// splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\nfunction splitTupleTypes(type) {\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(\"Internal error: expected tuple type but got non-tuple type: \".concat(type));\n  }\n  // Trim the outtermost tuple().\n  var trimmedType = type.substring('tuple('.length, type.length - 1);\n  var types = [];\n  var currToken = '';\n  var parenCount = 0;\n  // Tokenize the type string while keeping track of parentheses.\n  var _iterator = _createForOfIteratorHelper(trimmedType),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var char = _step.value;\n      switch (char) {\n        case '(':\n          parenCount += 1;\n          currToken += char;\n          break;\n        case ')':\n          parenCount -= 1;\n          currToken += char;\n          break;\n        case ',':\n          if (parenCount === 0) {\n            types.push(currToken);\n            currToken = '';\n            break;\n          } else {\n            currToken += char;\n            break;\n          }\n        default:\n          currToken += char;\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  types.push(currToken);\n  return types;\n}\nexports.abiUtils = {\n  parseEthersParams: parseEthersParams,\n  isAbiDataEqual: isAbiDataEqual,\n  splitTupleTypes: splitTupleTypes,\n  parseFunctionParam: function parseFunctionParam(param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      var tupleComponents = param.components;\n      var paramString = _.map(tupleComponents, function (component) {\n        return exports.abiUtils.parseFunctionParam(component);\n      });\n      var tupleParamString = \"{\".concat(paramString, \"}\");\n      return tupleParamString;\n    }\n    return param.type;\n  },\n  getFunctionSignature: function getFunctionSignature(methodAbi) {\n    var functionName = methodAbi.name;\n    var parameterTypeList = _.map(methodAbi.inputs, function (param) {\n      return exports.abiUtils.parseFunctionParam(param);\n    });\n    var functionSignature = \"\".concat(functionName, \"(\").concat(parameterTypeList, \")\");\n    return functionSignature;\n  },\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods: function renameOverloadedMethods(inputContractAbi) {\n    var contractAbi = _.cloneDeep(inputContractAbi);\n    var methodAbis = contractAbi.filter(function (abi) {\n      return abi.type === ethereum_types_1.AbiType.Function;\n    });\n    // Sort method Abis into alphabetical order, by function signature\n    var methodAbisOrdered = _.sortBy(methodAbis, [function (methodAbi) {\n      var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]);\n    // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n    var methodAbisByName = {};\n    _.each(methodAbisOrdered, function (methodAbi) {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    });\n    // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n    _.each(methodAbisByName, function (methodAbisWithSameName) {\n      _.each(methodAbisWithSameName, function (methodAbi, i) {\n        if (methodAbisWithSameName.length > 1) {\n          var overloadedMethodId = i + 1;\n          var sanitizedMethodName = \"\".concat(methodAbi.name).concat(overloadedMethodId);\n          var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) {\n            return currentMethodAbi.name === sanitizedMethodName;\n          });\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            var methodName = methodAbi.name;\n            throw new Error(\"Failed to rename overloaded method '\".concat(methodName, \"' to '\").concat(sanitizedMethodName, \"'. A method with this name already exists.\"));\n          }\n          methodAbi.name = sanitizedMethodName;\n        }\n      });\n    });\n    return contractAbi;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}