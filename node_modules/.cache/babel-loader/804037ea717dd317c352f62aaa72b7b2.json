{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMethod = exports.create = exports.EvmDataTypeFactory = exports.Method = exports.Array = exports.Tuple = exports.Pointer = exports.String = exports.DynamicBytes = exports.StaticBytes = exports.UInt = exports.Int = exports.Bool = exports.Address = void 0;\nvar _ = require(\"lodash\");\nvar signature_parser_1 = require(\"./utils/signature_parser\");\nvar address_1 = require(\"./evm_data_types/address\");\nvar array_1 = require(\"./evm_data_types/array\");\nvar bool_1 = require(\"./evm_data_types/bool\");\nvar dynamic_bytes_1 = require(\"./evm_data_types/dynamic_bytes\");\nvar int_1 = require(\"./evm_data_types/int\");\nvar method_1 = require(\"./evm_data_types/method\");\nvar pointer_1 = require(\"./evm_data_types/pointer\");\nvar static_bytes_1 = require(\"./evm_data_types/static_bytes\");\nvar string_1 = require(\"./evm_data_types/string\");\nvar tuple_1 = require(\"./evm_data_types/tuple\");\nvar uint_1 = require(\"./evm_data_types/uint\");\nvar Address = /*#__PURE__*/function (_address_1$AddressDat) {\n  _inherits(Address, _address_1$AddressDat);\n  function Address(dataItem) {\n    _classCallCheck(this, Address);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Address).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return Address;\n}(address_1.AddressDataType);\nexports.Address = Address;\nvar Bool = /*#__PURE__*/function (_bool_1$BoolDataType) {\n  _inherits(Bool, _bool_1$BoolDataType);\n  function Bool(dataItem) {\n    _classCallCheck(this, Bool);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Bool).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return Bool;\n}(bool_1.BoolDataType);\nexports.Bool = Bool;\nvar Int = /*#__PURE__*/function (_int_1$IntDataType) {\n  _inherits(Int, _int_1$IntDataType);\n  function Int(dataItem) {\n    _classCallCheck(this, Int);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Int).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return Int;\n}(int_1.IntDataType);\nexports.Int = Int;\nvar UInt = /*#__PURE__*/function (_uint_1$UIntDataType) {\n  _inherits(UInt, _uint_1$UIntDataType);\n  function UInt(dataItem) {\n    _classCallCheck(this, UInt);\n    return _possibleConstructorReturn(this, _getPrototypeOf(UInt).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return UInt;\n}(uint_1.UIntDataType);\nexports.UInt = UInt;\nvar StaticBytes = /*#__PURE__*/function (_static_bytes_1$Stati) {\n  _inherits(StaticBytes, _static_bytes_1$Stati);\n  function StaticBytes(dataItem) {\n    _classCallCheck(this, StaticBytes);\n    return _possibleConstructorReturn(this, _getPrototypeOf(StaticBytes).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return StaticBytes;\n}(static_bytes_1.StaticBytesDataType);\nexports.StaticBytes = StaticBytes;\nvar DynamicBytes = /*#__PURE__*/function (_dynamic_bytes_1$Dyna) {\n  _inherits(DynamicBytes, _dynamic_bytes_1$Dyna);\n  function DynamicBytes(dataItem) {\n    _classCallCheck(this, DynamicBytes);\n    return _possibleConstructorReturn(this, _getPrototypeOf(DynamicBytes).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return DynamicBytes;\n}(dynamic_bytes_1.DynamicBytesDataType);\nexports.DynamicBytes = DynamicBytes;\nvar String = /*#__PURE__*/function (_string_1$StringDataT) {\n  _inherits(String, _string_1$StringDataT);\n  function String(dataItem) {\n    _classCallCheck(this, String);\n    return _possibleConstructorReturn(this, _getPrototypeOf(String).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return String;\n}(string_1.StringDataType);\nexports.String = String;\nvar Pointer = /*#__PURE__*/function (_pointer_1$PointerDat) {\n  _inherits(Pointer, _pointer_1$PointerDat);\n  function Pointer(destDataType, parentDataType) {\n    _classCallCheck(this, Pointer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Pointer).call(this, destDataType, parentDataType, EvmDataTypeFactory.getInstance()));\n  }\n  return Pointer;\n}(pointer_1.PointerDataType);\nexports.Pointer = Pointer;\nvar Tuple = /*#__PURE__*/function (_tuple_1$TupleDataTyp) {\n  _inherits(Tuple, _tuple_1$TupleDataTyp);\n  function Tuple(dataItem) {\n    _classCallCheck(this, Tuple);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tuple).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return Tuple;\n}(tuple_1.TupleDataType);\nexports.Tuple = Tuple;\nvar Array = /*#__PURE__*/function (_array_1$ArrayDataTyp) {\n  _inherits(Array, _array_1$ArrayDataTyp);\n  function Array(dataItem) {\n    _classCallCheck(this, Array);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Array).call(this, dataItem, EvmDataTypeFactory.getInstance()));\n  }\n  return Array;\n}(array_1.ArrayDataType);\nexports.Array = Array;\nvar Method = /*#__PURE__*/function (_method_1$MethodDataT) {\n  _inherits(Method, _method_1$MethodDataT);\n  function Method(abi) {\n    _classCallCheck(this, Method);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Method).call(this, abi, EvmDataTypeFactory.getInstance()));\n  }\n  return Method;\n}(method_1.MethodDataType);\nexports.Method = Method;\n/* tslint:disable no-construct */\nvar EvmDataTypeFactory = /*#__PURE__*/function () {\n  /* tslint:enable prefer-function-over-method */\n  function EvmDataTypeFactory() {\n    _classCallCheck(this, EvmDataTypeFactory);\n  }\n  _createClass(EvmDataTypeFactory, [{\n    key: \"create\",\n    /* tslint:disable prefer-function-over-method */value: function create(dataItem, parentDataType) {\n      // Create data type\n      var dataType;\n      if (Array.matchType(dataItem.type)) {\n        dataType = new Array(dataItem);\n      } else if (Address.matchType(dataItem.type)) {\n        dataType = new Address(dataItem);\n      } else if (Bool.matchType(dataItem.type)) {\n        dataType = new Bool(dataItem);\n      } else if (Int.matchType(dataItem.type)) {\n        dataType = new Int(dataItem);\n      } else if (UInt.matchType(dataItem.type)) {\n        dataType = new UInt(dataItem);\n      } else if (StaticBytes.matchType(dataItem.type)) {\n        dataType = new StaticBytes(dataItem);\n      } else if (Tuple.matchType(dataItem.type)) {\n        dataType = new Tuple(dataItem);\n      } else if (DynamicBytes.matchType(dataItem.type)) {\n        dataType = new DynamicBytes(dataItem);\n      } else if (String.matchType(dataItem.type)) {\n        dataType = new String(dataItem);\n      }\n      // @TODO: DataTypeement Fixed/UFixed types\n      if (dataType === undefined) {\n        throw new Error(\"Unrecognized data type: '\".concat(dataItem.type, \"'\"));\n      } else if (parentDataType !== undefined && !dataType.isStatic()) {\n        var pointerToDataType = new Pointer(dataType, parentDataType);\n        return pointerToDataType;\n      }\n      return dataType;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!EvmDataTypeFactory._instance) {\n        EvmDataTypeFactory._instance = new EvmDataTypeFactory();\n      }\n      return EvmDataTypeFactory._instance;\n    }\n  }]);\n  return EvmDataTypeFactory;\n}();\nexports.EvmDataTypeFactory = EvmDataTypeFactory;\n/**\n * Convenience function for creating a DataType from different inputs.\n * @param input A single or set of DataItem or a signature for an EVM data type.\n * @return DataType corresponding to input.\n */\nfunction create(input, nestedDataItems) {\n  var dataItem = consolidateDataItemsIntoSingle(input);\n  if (nestedDataItems) {\n    var nestedTypes = _.keyBy(nestedDataItems, 'internalType');\n    var replaceTypes = function replaceTypes(_dataItem) {\n      var aliasedType = _dataItem.type;\n      if (Array.matchType(aliasedType)) {\n        var _Array$decodeElementT = Array.decodeElementTypeAndLengthFromType(aliasedType),\n          _Array$decodeElementT2 = _slicedToArray(_Array$decodeElementT, 2),\n          elementType = _Array$decodeElementT2[0],\n          arrayLength = _Array$decodeElementT2[1];\n        if (elementType in nestedTypes) {\n          _dataItem.type = \"\".concat(nestedTypes[elementType].type, \"[\").concat(arrayLength !== null && arrayLength !== void 0 ? arrayLength : '', \"]\");\n          _dataItem.components = nestedTypes[elementType].components;\n        }\n      } else if (aliasedType in nestedTypes) {\n        _dataItem.type = nestedTypes[aliasedType].type;\n        _dataItem.components = nestedTypes[aliasedType].components;\n      }\n      if (_dataItem.components) {\n        _dataItem.components.map(replaceTypes);\n      }\n    };\n    dataItem = _.cloneDeep(dataItem);\n    replaceTypes(dataItem);\n  }\n  var dataType = EvmDataTypeFactory.getInstance().create(dataItem);\n  return dataType;\n}\nexports.create = create;\n/**\n * Convenience function to aggregate a single input or a set of inputs into a single DataItem.\n * An array of data items is grouped into a single tuple.\n * @param input A single data item; a set of data items; a signature.\n * @return A single data item corresponding to input.\n */\nfunction consolidateDataItemsIntoSingle(input) {\n  var dataItem;\n  if (_.isArray(input)) {\n    var dataItems = input;\n    dataItem = {\n      name: '',\n      type: 'tuple',\n      components: dataItems\n    };\n  } else {\n    dataItem = _.isString(input) ? signature_parser_1.generateDataItemFromSignature(input) : input;\n  }\n  return dataItem;\n}\n/**\n * Convenience function for creating a Method encoder from different inputs.\n * @param methodName name of method.\n * @param input A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @param output A single data item; a set of data items; a signature; or an array of signatures (optional).\n * @return Method corresponding to input.\n */\nfunction createMethod(methodName, input, output) {\n  var methodInput = input === undefined ? [] : consolidateDataItemsIntoArray(input);\n  var methodOutput = output === undefined ? [] : consolidateDataItemsIntoArray(output);\n  var methodAbi = {\n    name: methodName,\n    inputs: methodInput,\n    outputs: methodOutput,\n    type: 'function',\n    // default fields not used by ABI\n    constant: false,\n    payable: false,\n    stateMutability: 'nonpayable'\n  };\n  var dataType = new Method(methodAbi);\n  return dataType;\n}\nexports.createMethod = createMethod;\n/**\n * Convenience function that aggregates a single input or a set of inputs into an array of DataItems.\n * @param input A single data item; a set of data items; a signature; or an array of signatures.\n * @return Array of data items corresponding to input.\n */\nfunction consolidateDataItemsIntoArray(input) {\n  var dataItems;\n  if (_.isArray(input) && _.isEmpty(input)) {\n    dataItems = [];\n  } else if (_.isArray(input) && _.isString(input[0])) {\n    dataItems = [];\n    _.each(input, function (signature) {\n      var dataItem = signature_parser_1.generateDataItemFromSignature(signature);\n      dataItems.push(dataItem);\n    });\n  } else if (_.isArray(input)) {\n    dataItems = input;\n  } else if (typeof input === 'string') {\n    var dataItem = signature_parser_1.generateDataItemFromSignature(input);\n    dataItems = [dataItem];\n  } else {\n    dataItems = [input];\n  }\n  return dataItems;\n}\n/* tslint:enable no-construct */","map":null,"metadata":{},"sourceType":"script"}