{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAdvancedOrderNumeratorDenominator = exports.generateFulfillOrdersFulfillments = exports.fulfillAvailableOrders = exports.validateAndSanitizeFromOrderStatus = exports.fulfillStandardOrder = exports.fulfillBasicOrder = exports.shouldUseBasicFulfill = void 0;\nvar ethers_1 = require(\"ethers\");\nvar constants_1 = require(\"../constants\");\nvar approval_1 = require(\"./approval\");\nvar balanceAndApprovalCheck_1 = require(\"./balanceAndApprovalCheck\");\nvar criteria_1 = require(\"./criteria\");\nvar gcd_1 = require(\"./gcd\");\nvar item_1 = require(\"./item\");\nvar order_1 = require(\"./order\");\nvar usecase_1 = require(\"./usecase\");\n/**\n * We should use basic fulfill order if the order adheres to the following criteria:\n * 1. The order should not be partially filled.\n * 2. The order only contains a single offer item and contains at least one consideration item\n * 3. The order does not offer an item with Ether (or other native tokens) as its item type.\n * 4. The order only contains a single ERC721 or ERC1155 item and that item is not criteria-based\n * 5. All other items have the same Native or ERC20 item type and token\n * 6. All items have the same startAmount and endAmount\n * 7. First consideration item must contain the offerer as the recipient\n * 8. If the order has multiple consideration items and all consideration items other than the\n *    first consideration item have the same item type as the offered item, the offered item\n *    amount is not less than the sum of all consideration item amounts excluding the\n *    first consideration item amount\n * 9. The token on native currency items needs to be set to the null address and the identifier on\n *    currencies needs to be zero, and the amounts on the 721 item need to be 1\n */\nvar shouldUseBasicFulfill = function shouldUseBasicFulfill(_a, totalFilled) {\n  var offer = _a.offer,\n    consideration = _a.consideration,\n    offerer = _a.offerer;\n  // 1. The order must not be partially filled\n  if (!totalFilled.eq(0)) {\n    return false;\n  }\n  // 2. Must be single offer and at least one consideration\n  if (offer.length > 1 || consideration.length === 0) {\n    return false;\n  }\n  var allItems = __spreadArray(__spreadArray([], __read(offer), false), __read(consideration), false);\n  var nfts = allItems.filter(function (_a) {\n    var itemType = _a.itemType;\n    return [constants_1.ItemType.ERC721, constants_1.ItemType.ERC1155].includes(itemType);\n  });\n  var nftsWithCriteria = allItems.filter(function (_a) {\n    var itemType = _a.itemType;\n    return (0, item_1.isCriteriaItem)(itemType);\n  });\n  var offersNativeCurrency = (0, item_1.isNativeCurrencyItem)(offer[0]);\n  // 3. The order does not offer an item with Ether (or other native tokens) as its item type.\n  if (offersNativeCurrency) {\n    return false;\n  }\n  // 4. The order only contains a single ERC721 or ERC1155 item and that item is not criteria-based\n  if (nfts.length !== 1 || nftsWithCriteria.length !== 0) {\n    return false;\n  }\n  // 5. All currencies need to have the same address and item type (Native, ERC20)\n  if (!(0, order_1.areAllCurrenciesSame)({\n    offer: offer,\n    consideration: consideration\n  })) {\n    return false;\n  }\n  // 6. All individual items need to have the same startAmount and endAmount\n  var differentStartAndEndAmount = allItems.some(function (_a) {\n    var startAmount = _a.startAmount,\n      endAmount = _a.endAmount;\n    return startAmount !== endAmount;\n  });\n  if (differentStartAndEndAmount) {\n    return false;\n  }\n  var _b = __read(consideration),\n    firstConsideration = _b[0],\n    restConsideration = _b.slice(1);\n  // 7. First consideration item must contain the offerer as the recipient\n  var firstConsiderationRecipientIsNotOfferer = firstConsideration.recipient.toLowerCase() !== offerer.toLowerCase();\n  if (firstConsiderationRecipientIsNotOfferer) {\n    return false;\n  }\n  // 8. If the order has multiple consideration items and all consideration items other than the\n  // first consideration item have the same item type as the offered item, the offered item\n  // amount is not less than the sum of all consideration item amounts excluding the\n  // first consideration item amount\n  if (consideration.length > 1 && restConsideration.every(function (item) {\n    return item.itemType === offer[0].itemType;\n  }) && (0, order_1.totalItemsAmount)(restConsideration).endAmount.gt(offer[0].endAmount)) {\n    return false;\n  }\n  var currencies = allItems.filter(item_1.isCurrencyItem);\n  //  9. The token on native currency items needs to be set to the null address and the identifier on\n  //  currencies needs to be zero, and the amounts on the 721 item need to be 1\n  var nativeCurrencyIsZeroAddress = currencies.filter(function (_a) {\n    var itemType = _a.itemType;\n    return itemType === constants_1.ItemType.NATIVE;\n  }).every(function (_a) {\n    var token = _a.token;\n    return token === ethers_1.ethers.constants.AddressZero;\n  });\n  var currencyIdentifiersAreZero = currencies.every(function (_a) {\n    var identifierOrCriteria = _a.identifierOrCriteria;\n    return ethers_1.BigNumber.from(identifierOrCriteria).eq(0);\n  });\n  var erc721sAreSingleAmount = nfts.filter(function (_a) {\n    var itemType = _a.itemType;\n    return itemType === constants_1.ItemType.ERC721;\n  }).every(function (_a) {\n    var endAmount = _a.endAmount;\n    return endAmount === \"1\";\n  });\n  return nativeCurrencyIsZeroAddress && currencyIdentifiersAreZero && erc721sAreSingleAmount;\n};\nexports.shouldUseBasicFulfill = shouldUseBasicFulfill;\nvar offerAndConsiderationFulfillmentMapping = (_a = {}, _a[constants_1.ItemType.ERC20] = (_b = {}, _b[constants_1.ItemType.ERC721] = constants_1.BasicOrderRouteType.ERC721_TO_ERC20, _b[constants_1.ItemType.ERC1155] = constants_1.BasicOrderRouteType.ERC1155_TO_ERC20, _b), _a[constants_1.ItemType.ERC721] = (_c = {}, _c[constants_1.ItemType.NATIVE] = constants_1.BasicOrderRouteType.ETH_TO_ERC721, _c[constants_1.ItemType.ERC20] = constants_1.BasicOrderRouteType.ERC20_TO_ERC721, _c), _a[constants_1.ItemType.ERC1155] = (_d = {}, _d[constants_1.ItemType.NATIVE] = constants_1.BasicOrderRouteType.ETH_TO_ERC1155, _d[constants_1.ItemType.ERC20] = constants_1.BasicOrderRouteType.ERC20_TO_ERC1155, _d), _a);\nfunction fulfillBasicOrder(_a, exactApproval) {\n  var _b, _c;\n  var order = _a.order,\n    seaportContract = _a.seaportContract,\n    offererBalancesAndApprovals = _a.offererBalancesAndApprovals,\n    fulfillerBalancesAndApprovals = _a.fulfillerBalancesAndApprovals,\n    timeBasedItemParams = _a.timeBasedItemParams,\n    offererOperator = _a.offererOperator,\n    fulfillerOperator = _a.fulfillerOperator,\n    signer = _a.signer,\n    _d = _a.tips,\n    tips = _d === void 0 ? [] : _d,\n    _e = _a.conduitKey,\n    conduitKey = _e === void 0 ? constants_1.NO_CONDUIT : _e,\n    domain = _a.domain;\n  return __awaiter(this, void 0, void 0, function () {\n    var _f, offer, consideration, considerationIncludingTips, offerItem, _g, forOfferer, forAdditionalRecipients, basicOrderRouteType, additionalRecipients, considerationWithoutOfferItemType, totalNativeAmount, insufficientApprovals, basicOrderParameters, payableOverrides, approvalActions, exchangeAction, actions;\n    return __generator(this, function (_h) {\n      switch (_h.label) {\n        case 0:\n          _f = order.parameters, offer = _f.offer, consideration = _f.consideration;\n          considerationIncludingTips = __spreadArray(__spreadArray([], __read(consideration), false), __read(tips), false);\n          offerItem = offer[0];\n          _g = __read(considerationIncludingTips), forOfferer = _g[0], forAdditionalRecipients = _g.slice(1);\n          basicOrderRouteType = (_b = offerAndConsiderationFulfillmentMapping[offerItem.itemType]) === null || _b === void 0 ? void 0 : _b[forOfferer.itemType];\n          if (basicOrderRouteType === undefined) {\n            throw new Error(\"Order parameters did not result in a valid basic fulfillment\");\n          }\n          additionalRecipients = forAdditionalRecipients.map(function (_a) {\n            var startAmount = _a.startAmount,\n              recipient = _a.recipient;\n            return {\n              amount: startAmount,\n              recipient: recipient\n            };\n          });\n          considerationWithoutOfferItemType = considerationIncludingTips.filter(function (item) {\n            return item.itemType !== offer[0].itemType;\n          });\n          totalNativeAmount = (_c = (0, item_1.getSummedTokenAndIdentifierAmounts)({\n            items: considerationWithoutOfferItemType,\n            criterias: [],\n            timeBasedItemParams: __assign(__assign({}, timeBasedItemParams), {\n              isConsiderationItem: true\n            })\n          })[ethers_1.ethers.constants.AddressZero]) === null || _c === void 0 ? void 0 : _c[\"0\"];\n          insufficientApprovals = (0, balanceAndApprovalCheck_1.validateBasicFulfillBalancesAndApprovals)({\n            offer: offer,\n            consideration: considerationIncludingTips,\n            offererBalancesAndApprovals: offererBalancesAndApprovals,\n            fulfillerBalancesAndApprovals: fulfillerBalancesAndApprovals,\n            timeBasedItemParams: timeBasedItemParams,\n            offererOperator: offererOperator,\n            fulfillerOperator: fulfillerOperator\n          });\n          basicOrderParameters = {\n            offerer: order.parameters.offerer,\n            offererConduitKey: order.parameters.conduitKey,\n            zone: order.parameters.zone,\n            //  Note the use of a \"basicOrderType\" enum;\n            //  this represents both the usual order type as well as the \"route\"\n            //  of the basic order (a simple derivation function for the basic order\n            //  type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n            basicOrderType: order.parameters.orderType + 4 * basicOrderRouteType,\n            offerToken: offerItem.token,\n            offerIdentifier: offerItem.identifierOrCriteria,\n            offerAmount: offerItem.endAmount,\n            considerationToken: forOfferer.token,\n            considerationIdentifier: forOfferer.identifierOrCriteria,\n            considerationAmount: forOfferer.endAmount,\n            startTime: order.parameters.startTime,\n            endTime: order.parameters.endTime,\n            salt: order.parameters.salt,\n            totalOriginalAdditionalRecipients: order.parameters.consideration.length - 1,\n            signature: order.signature,\n            fulfillerConduitKey: conduitKey,\n            additionalRecipients: additionalRecipients,\n            zoneHash: order.parameters.zoneHash\n          };\n          payableOverrides = {\n            value: totalNativeAmount\n          };\n          return [4 /*yield*/, (0, approval_1.getApprovalActions)(insufficientApprovals, exactApproval, signer)];\n        case 1:\n          approvalActions = _h.sent();\n          exchangeAction = {\n            type: \"exchange\",\n            transactionMethods: (0, usecase_1.getTransactionMethods)(seaportContract.connect(signer), \"fulfillBasicOrder\", [basicOrderParameters, payableOverrides], domain)\n          };\n          actions = __spreadArray(__spreadArray([], __read(approvalActions), false), [exchangeAction], false);\n          return [2 /*return*/, {\n            actions: actions,\n            executeAllActions: function executeAllActions() {\n              return (0, usecase_1.executeAllActions)(actions);\n            }\n          }];\n      }\n    });\n  });\n}\nexports.fulfillBasicOrder = fulfillBasicOrder;\nfunction fulfillStandardOrder(_a, exactApproval) {\n  var _b;\n  var order = _a.order,\n    _c = _a.unitsToFill,\n    unitsToFill = _c === void 0 ? 0 : _c,\n    totalSize = _a.totalSize,\n    totalFilled = _a.totalFilled,\n    offerCriteria = _a.offerCriteria,\n    considerationCriteria = _a.considerationCriteria,\n    _d = _a.tips,\n    tips = _d === void 0 ? [] : _d,\n    extraData = _a.extraData,\n    seaportContract = _a.seaportContract,\n    offererBalancesAndApprovals = _a.offererBalancesAndApprovals,\n    fulfillerBalancesAndApprovals = _a.fulfillerBalancesAndApprovals,\n    offererOperator = _a.offererOperator,\n    fulfillerOperator = _a.fulfillerOperator,\n    timeBasedItemParams = _a.timeBasedItemParams,\n    conduitKey = _a.conduitKey,\n    recipientAddress = _a.recipientAddress,\n    signer = _a.signer,\n    domain = _a.domain;\n  return __awaiter(this, void 0, void 0, function () {\n    var orderWithAdjustedFills, _e, offer, consideration, considerationIncludingTips, offerCriteriaItems, considerationCriteriaItems, hasCriteriaItems, totalNativeAmount, insufficientApprovals, payableOverrides, approvalActions, isGift, useAdvanced, orderAccountingForTips, _f, numerator, denominator, exchangeAction, actions;\n    return __generator(this, function (_g) {\n      switch (_g.label) {\n        case 0:\n          orderWithAdjustedFills = unitsToFill ? (0, order_1.mapOrderAmountsFromUnitsToFill)(order, {\n            unitsToFill: unitsToFill,\n            totalFilled: totalFilled,\n            totalSize: totalSize\n          }) :\n          // Else, we adjust the order by the remaining order left to be fulfilled\n          (0, order_1.mapOrderAmountsFromFilledStatus)(order, {\n            totalFilled: totalFilled,\n            totalSize: totalSize\n          });\n          _e = orderWithAdjustedFills.parameters, offer = _e.offer, consideration = _e.consideration;\n          considerationIncludingTips = __spreadArray(__spreadArray([], __read(consideration), false), __read(tips), false);\n          offerCriteriaItems = offer.filter(function (_a) {\n            var itemType = _a.itemType;\n            return (0, item_1.isCriteriaItem)(itemType);\n          });\n          considerationCriteriaItems = considerationIncludingTips.filter(function (_a) {\n            var itemType = _a.itemType;\n            return (0, item_1.isCriteriaItem)(itemType);\n          });\n          hasCriteriaItems = offerCriteriaItems.length > 0 || considerationCriteriaItems.length > 0;\n          if (offerCriteriaItems.length !== offerCriteria.length || considerationCriteriaItems.length !== considerationCriteria.length) {\n            throw new Error(\"You must supply the appropriate criterias for criteria based items\");\n          }\n          totalNativeAmount = (_b = (0, item_1.getSummedTokenAndIdentifierAmounts)({\n            items: considerationIncludingTips,\n            criterias: considerationCriteria,\n            timeBasedItemParams: __assign(__assign({}, timeBasedItemParams), {\n              isConsiderationItem: true\n            })\n          })[ethers_1.ethers.constants.AddressZero]) === null || _b === void 0 ? void 0 : _b[\"0\"];\n          insufficientApprovals = (0, balanceAndApprovalCheck_1.validateStandardFulfillBalancesAndApprovals)({\n            offer: offer,\n            consideration: considerationIncludingTips,\n            offerCriteria: offerCriteria,\n            considerationCriteria: considerationCriteria,\n            offererBalancesAndApprovals: offererBalancesAndApprovals,\n            fulfillerBalancesAndApprovals: fulfillerBalancesAndApprovals,\n            timeBasedItemParams: timeBasedItemParams,\n            offererOperator: offererOperator,\n            fulfillerOperator: fulfillerOperator\n          });\n          payableOverrides = {\n            value: totalNativeAmount\n          };\n          return [4 /*yield*/, (0, approval_1.getApprovalActions)(insufficientApprovals, exactApproval, signer)];\n        case 1:\n          approvalActions = _g.sent();\n          isGift = recipientAddress !== ethers_1.ethers.constants.AddressZero;\n          useAdvanced = Boolean(unitsToFill) || hasCriteriaItems || isGift;\n          orderAccountingForTips = __assign(__assign({}, order), {\n            parameters: __assign(__assign({}, order.parameters), {\n              consideration: __spreadArray(__spreadArray([], __read(order.parameters.consideration), false), __read(tips), false),\n              totalOriginalConsiderationItems: consideration.length\n            })\n          });\n          _f = (0, exports.getAdvancedOrderNumeratorDenominator)(order, unitsToFill), numerator = _f.numerator, denominator = _f.denominator;\n          exchangeAction = {\n            type: \"exchange\",\n            transactionMethods: useAdvanced ? (0, usecase_1.getTransactionMethods)(seaportContract.connect(signer), \"fulfillAdvancedOrder\", [__assign(__assign({}, orderAccountingForTips), {\n              numerator: numerator,\n              denominator: denominator,\n              extraData: extraData !== null && extraData !== void 0 ? extraData : \"0x\"\n            }), hasCriteriaItems ? (0, criteria_1.generateCriteriaResolvers)({\n              orders: [order],\n              offerCriterias: [offerCriteria],\n              considerationCriterias: [considerationCriteria]\n            }) : [], conduitKey, recipientAddress, payableOverrides], domain) : (0, usecase_1.getTransactionMethods)(seaportContract.connect(signer), \"fulfillOrder\", [orderAccountingForTips, conduitKey, payableOverrides], domain)\n          };\n          actions = __spreadArray(__spreadArray([], __read(approvalActions), false), [exchangeAction], false);\n          return [2 /*return*/, {\n            actions: actions,\n            executeAllActions: function executeAllActions() {\n              return (0, usecase_1.executeAllActions)(actions);\n            }\n          }];\n      }\n    });\n  });\n}\nexports.fulfillStandardOrder = fulfillStandardOrder;\nfunction validateAndSanitizeFromOrderStatus(order, orderStatus) {\n  var isValidated = orderStatus.isValidated,\n    isCancelled = orderStatus.isCancelled,\n    totalFilled = orderStatus.totalFilled,\n    totalSize = orderStatus.totalSize;\n  if (totalSize.gt(0) && totalFilled.div(totalSize).eq(1)) {\n    throw new Error(\"The order you are trying to fulfill is already filled\");\n  }\n  if (isCancelled) {\n    throw new Error(\"The order you are trying to fulfill is cancelled\");\n  }\n  if (isValidated) {\n    // If the order is already validated, manually wipe the signature off of the order to save gas\n    return {\n      parameters: __assign({}, order.parameters),\n      signature: \"0x\"\n    };\n  }\n  return order;\n}\nexports.validateAndSanitizeFromOrderStatus = validateAndSanitizeFromOrderStatus;\nfunction fulfillAvailableOrders(_a) {\n  var ordersMetadata = _a.ordersMetadata,\n    seaportContract = _a.seaportContract,\n    fulfillerBalancesAndApprovals = _a.fulfillerBalancesAndApprovals,\n    fulfillerOperator = _a.fulfillerOperator,\n    currentBlockTimestamp = _a.currentBlockTimestamp,\n    ascendingAmountTimestampBuffer = _a.ascendingAmountTimestampBuffer,\n    conduitKey = _a.conduitKey,\n    signer = _a.signer,\n    recipientAddress = _a.recipientAddress,\n    exactApproval = _a.exactApproval,\n    domain = _a.domain;\n  return __awaiter(this, void 0, void 0, function () {\n    var sanitizedOrdersMetadata, ordersMetadataWithAdjustedFills, totalNativeAmount, totalInsufficientApprovals, hasCriteriaItems, addApprovalIfNeeded, payableOverrides, approvalActions, advancedOrdersWithTips, _b, offerFulfillments, considerationFulfillments, exchangeAction, actions;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          sanitizedOrdersMetadata = ordersMetadata.map(function (orderMetadata) {\n            return __assign(__assign({}, orderMetadata), {\n              order: validateAndSanitizeFromOrderStatus(orderMetadata.order, orderMetadata.orderStatus)\n            });\n          });\n          ordersMetadataWithAdjustedFills = sanitizedOrdersMetadata.map(function (orderMetadata) {\n            return __assign(__assign({}, orderMetadata), {\n              // If we are supplying units to fill, we adjust the order by the minimum of the amount to fill and\n              // the remaining order left to be fulfilled\n              order: orderMetadata.unitsToFill ? (0, order_1.mapOrderAmountsFromUnitsToFill)(orderMetadata.order, {\n                unitsToFill: orderMetadata.unitsToFill,\n                totalFilled: orderMetadata.orderStatus.totalFilled,\n                totalSize: orderMetadata.orderStatus.totalSize\n              }) :\n              // Else, we adjust the order by the remaining order left to be fulfilled\n              (0, order_1.mapOrderAmountsFromFilledStatus)(orderMetadata.order, {\n                totalFilled: orderMetadata.orderStatus.totalFilled,\n                totalSize: orderMetadata.orderStatus.totalSize\n              })\n            });\n          });\n          totalNativeAmount = ethers_1.BigNumber.from(0);\n          totalInsufficientApprovals = [];\n          hasCriteriaItems = false;\n          addApprovalIfNeeded = function addApprovalIfNeeded(orderInsufficientApprovals) {\n            orderInsufficientApprovals.forEach(function (insufficientApproval) {\n              if (!totalInsufficientApprovals.find(function (approval) {\n                return approval.token === insufficientApproval.token;\n              })) {\n                totalInsufficientApprovals.push(insufficientApproval);\n              }\n            });\n          };\n          ordersMetadataWithAdjustedFills.forEach(function (_a) {\n            var _b, _c;\n            var order = _a.order,\n              tips = _a.tips,\n              offerCriteria = _a.offerCriteria,\n              considerationCriteria = _a.considerationCriteria,\n              offererBalancesAndApprovals = _a.offererBalancesAndApprovals,\n              offererOperator = _a.offererOperator;\n            var considerationIncludingTips = __spreadArray(__spreadArray([], __read(order.parameters.consideration), false), __read(tips), false);\n            var timeBasedItemParams = {\n              startTime: order.parameters.startTime,\n              endTime: order.parameters.endTime,\n              currentBlockTimestamp: currentBlockTimestamp,\n              ascendingAmountTimestampBuffer: ascendingAmountTimestampBuffer,\n              isConsiderationItem: true\n            };\n            totalNativeAmount = totalNativeAmount.add((_c = (_b = (0, item_1.getSummedTokenAndIdentifierAmounts)({\n              items: considerationIncludingTips,\n              criterias: considerationCriteria,\n              timeBasedItemParams: timeBasedItemParams\n            })[ethers_1.ethers.constants.AddressZero]) === null || _b === void 0 ? void 0 : _b[\"0\"]) !== null && _c !== void 0 ? _c : ethers_1.BigNumber.from(0));\n            var insufficientApprovals = (0, balanceAndApprovalCheck_1.validateStandardFulfillBalancesAndApprovals)({\n              offer: order.parameters.offer,\n              consideration: considerationIncludingTips,\n              offerCriteria: offerCriteria,\n              considerationCriteria: considerationCriteria,\n              offererBalancesAndApprovals: offererBalancesAndApprovals,\n              fulfillerBalancesAndApprovals: fulfillerBalancesAndApprovals,\n              timeBasedItemParams: timeBasedItemParams,\n              offererOperator: offererOperator,\n              fulfillerOperator: fulfillerOperator\n            });\n            var offerCriteriaItems = order.parameters.offer.filter(function (_a) {\n              var itemType = _a.itemType;\n              return (0, item_1.isCriteriaItem)(itemType);\n            });\n            var considerationCriteriaItems = considerationIncludingTips.filter(function (_a) {\n              var itemType = _a.itemType;\n              return (0, item_1.isCriteriaItem)(itemType);\n            });\n            if (offerCriteriaItems.length !== offerCriteria.length || considerationCriteriaItems.length !== considerationCriteria.length) {\n              throw new Error(\"You must supply the appropriate criterias for criteria based items\");\n            }\n            addApprovalIfNeeded(insufficientApprovals);\n          });\n          payableOverrides = {\n            value: totalNativeAmount\n          };\n          return [4 /*yield*/, (0, approval_1.getApprovalActions)(totalInsufficientApprovals, exactApproval, signer)];\n        case 1:\n          approvalActions = _c.sent();\n          advancedOrdersWithTips = sanitizedOrdersMetadata.map(function (_a) {\n            var order = _a.order,\n              _b = _a.unitsToFill,\n              unitsToFill = _b === void 0 ? 0 : _b,\n              tips = _a.tips,\n              extraData = _a.extraData;\n            var _c = (0, exports.getAdvancedOrderNumeratorDenominator)(order, unitsToFill),\n              numerator = _c.numerator,\n              denominator = _c.denominator;\n            var considerationIncludingTips = __spreadArray(__spreadArray([], __read(order.parameters.consideration), false), __read(tips), false);\n            return __assign(__assign({}, order), {\n              parameters: __assign(__assign({}, order.parameters), {\n                consideration: considerationIncludingTips,\n                totalOriginalConsiderationItems: order.parameters.consideration.length\n              }),\n              numerator: numerator,\n              denominator: denominator,\n              extraData: extraData\n            });\n          });\n          _b = generateFulfillOrdersFulfillments(ordersMetadata), offerFulfillments = _b.offerFulfillments, considerationFulfillments = _b.considerationFulfillments;\n          exchangeAction = {\n            type: \"exchange\",\n            transactionMethods: (0, usecase_1.getTransactionMethods)(seaportContract.connect(signer), \"fulfillAvailableAdvancedOrders\", [advancedOrdersWithTips, hasCriteriaItems ? (0, criteria_1.generateCriteriaResolvers)({\n              orders: ordersMetadata.map(function (_a) {\n                var order = _a.order;\n                return order;\n              }),\n              offerCriterias: ordersMetadata.map(function (_a) {\n                var offerCriteria = _a.offerCriteria;\n                return offerCriteria;\n              }),\n              considerationCriterias: ordersMetadata.map(function (_a) {\n                var considerationCriteria = _a.considerationCriteria;\n                return considerationCriteria;\n              })\n            }) : [], offerFulfillments, considerationFulfillments, conduitKey, recipientAddress, advancedOrdersWithTips.length, payableOverrides], domain)\n          };\n          actions = __spreadArray(__spreadArray([], __read(approvalActions), false), [exchangeAction], false);\n          return [2 /*return*/, {\n            actions: actions,\n            executeAllActions: function executeAllActions() {\n              return (0, usecase_1.executeAllActions)(actions);\n            }\n          }];\n      }\n    });\n  });\n}\nexports.fulfillAvailableOrders = fulfillAvailableOrders;\nfunction generateFulfillOrdersFulfillments(ordersMetadata) {\n  var hashAggregateKey = function hashAggregateKey(_a) {\n    var sourceOrDestination = _a.sourceOrDestination,\n      _b = _a.operator,\n      operator = _b === void 0 ? \"\" : _b,\n      token = _a.token,\n      identifier = _a.identifier;\n    return \"\".concat(sourceOrDestination, \"-\").concat(operator, \"-\").concat(token, \"-\").concat(identifier);\n  };\n  var offerAggregatedFulfillments = {};\n  var considerationAggregatedFulfillments = {};\n  ordersMetadata.forEach(function (_a, orderIndex) {\n    var order = _a.order,\n      offererOperator = _a.offererOperator,\n      offerCriteria = _a.offerCriteria;\n    var itemToCriteria = (0, criteria_1.getItemToCriteriaMap)(order.parameters.offer, offerCriteria);\n    return order.parameters.offer.forEach(function (item, itemIndex) {\n      var _a, _b, _c;\n      var aggregateKey = \"\".concat(hashAggregateKey({\n        sourceOrDestination: order.parameters.offerer,\n        operator: offererOperator,\n        token: item.token,\n        identifier: (_b = (_a = itemToCriteria.get(item)) === null || _a === void 0 ? void 0 : _a.identifier) !== null && _b !== void 0 ? _b : item.identifierOrCriteria\n        // We tack on the index to ensure that erc721s can never be aggregated and instead must be in separate arrays\n      })).concat((0, item_1.isErc721Item)(item.itemType) ? itemIndex : \"\");\n      offerAggregatedFulfillments[aggregateKey] = __spreadArray(__spreadArray([], __read((_c = offerAggregatedFulfillments[aggregateKey]) !== null && _c !== void 0 ? _c : []), false), [{\n        orderIndex: orderIndex,\n        itemIndex: itemIndex\n      }], false);\n    });\n  });\n  ordersMetadata.forEach(function (_a, orderIndex) {\n    var order = _a.order,\n      considerationCriteria = _a.considerationCriteria,\n      tips = _a.tips;\n    var itemToCriteria = (0, criteria_1.getItemToCriteriaMap)(order.parameters.consideration, considerationCriteria);\n    return __spreadArray(__spreadArray([], __read(order.parameters.consideration), false), __read(tips), false).forEach(function (item, itemIndex) {\n      var _a, _b, _c;\n      var aggregateKey = \"\".concat(hashAggregateKey({\n        sourceOrDestination: item.recipient,\n        token: item.token,\n        identifier: (_b = (_a = itemToCriteria.get(item)) === null || _a === void 0 ? void 0 : _a.identifier) !== null && _b !== void 0 ? _b : item.identifierOrCriteria\n        // We tack on the index to ensure that erc721s can never be aggregated and instead must be in separate arrays\n      })).concat((0, item_1.isErc721Item)(item.itemType) ? itemIndex : \"\");\n      considerationAggregatedFulfillments[aggregateKey] = __spreadArray(__spreadArray([], __read((_c = considerationAggregatedFulfillments[aggregateKey]) !== null && _c !== void 0 ? _c : []), false), [{\n        orderIndex: orderIndex,\n        itemIndex: itemIndex\n      }], false);\n    });\n  });\n  return {\n    offerFulfillments: Object.values(offerAggregatedFulfillments),\n    considerationFulfillments: Object.values(considerationAggregatedFulfillments)\n  };\n}\nexports.generateFulfillOrdersFulfillments = generateFulfillOrdersFulfillments;\nvar getAdvancedOrderNumeratorDenominator = function getAdvancedOrderNumeratorDenominator(order, unitsToFill) {\n  // Used for advanced order cases\n  var maxUnits = (0, item_1.getMaximumSizeForOrder)(order);\n  var unitsToFillBn = ethers_1.BigNumber.from(unitsToFill);\n  // Reduce the numerator/denominator as optimization\n  var unitsGcd = (0, gcd_1.gcd)(unitsToFillBn, maxUnits);\n  var numerator = unitsToFill ? unitsToFillBn.div(unitsGcd) : ethers_1.BigNumber.from(1);\n  var denominator = unitsToFill ? maxUnits.div(unitsGcd) : ethers_1.BigNumber.from(1);\n  return {\n    numerator: numerator,\n    denominator: denominator\n  };\n};\nexports.getAdvancedOrderNumeratorDenominator = getAdvancedOrderNumeratorDenominator;","map":null,"metadata":{},"sourceType":"script"}