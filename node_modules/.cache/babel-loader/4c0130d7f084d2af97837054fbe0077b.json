{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OpenSeaAPI = void 0;\nrequire(\"isomorphic-unfetch\");\nvar QueryString = __importStar(require(\"query-string\"));\nvar constants_1 = require(\"./constants\");\nvar utils_1 = require(\"./orders/utils\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils/utils\");\nvar OpenSeaAPI = /** @class */function () {\n  /**\n   * Create an instance of the OpenSea API\n   * @param config OpenSeaAPIConfig for setting up the API, including an optional API key, network name, and base URL\n   * @param logger Optional function for logging debug strings before and after requests are made\n   */\n  function OpenSeaAPI(config, logger) {\n    var _a;\n    /**\n     * Page size to use for fetching orders\n     */\n    this.pageSize = 20;\n    this.retryDelay = 3000;\n    this.apiKey = config.apiKey;\n    this.networkName = (_a = config.networkName) !== null && _a !== void 0 ? _a : types_1.Network.Main;\n    switch (config.networkName) {\n      case types_1.Network.Goerli:\n        this.apiBaseUrl = config.apiBaseUrl || constants_1.API_BASE_TESTNET;\n        break;\n      case types_1.Network.Main:\n      default:\n        this.apiBaseUrl = config.apiBaseUrl || constants_1.API_BASE_MAINNET;\n        break;\n    }\n    // Debugging: default to nothing\n    this.logger = logger || function (arg) {\n      return arg;\n    };\n  }\n  /**\n   * Gets an order from API based on query options. Throws when no order is found.\n   */\n  OpenSeaAPI.prototype.getOrder = function (_a) {\n    var side = _a.side,\n      _b = _a.protocol,\n      protocol = _b === void 0 ? \"seaport\" : _b,\n      _c = _a.orderDirection,\n      orderDirection = _c === void 0 ? \"desc\" : _c,\n      _d = _a.orderBy,\n      orderBy = _d === void 0 ? \"created_date\" : _d,\n      restOptions = __rest(_a, [\"side\", \"protocol\", \"orderDirection\", \"orderBy\"]);\n    return __awaiter(this, void 0, void 0, function () {\n      var orders;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            return [4 /*yield*/, this.get((0, utils_1.getOrdersAPIPath)(this.networkName, protocol, side), (0, utils_1.serializeOrdersQueryOptions)(__assign({\n              limit: 1,\n              orderBy: orderBy,\n              orderDirection: orderDirection\n            }, restOptions)))];\n          case 1:\n            orders = _e.sent().orders;\n            if (orders.length === 0) {\n              throw new Error(\"Not found: no matching order found\");\n            }\n            return [2 /*return*/, (0, utils_1.deserializeOrder)(orders[0])];\n        }\n      });\n    });\n  };\n  /**\n   * Gets a list of orders from API based on query options and returns orders\n   * with next and previous cursors.\n   */\n  OpenSeaAPI.prototype.getOrders = function (_a) {\n    var side = _a.side,\n      _b = _a.protocol,\n      protocol = _b === void 0 ? \"seaport\" : _b,\n      _c = _a.orderDirection,\n      orderDirection = _c === void 0 ? \"desc\" : _c,\n      _d = _a.orderBy,\n      orderBy = _d === void 0 ? \"created_date\" : _d,\n      restOptions = __rest(_a, [\"side\", \"protocol\", \"orderDirection\", \"orderBy\"]);\n    return __awaiter(this, void 0, void 0, function () {\n      var response;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            return [4 /*yield*/, this.get((0, utils_1.getOrdersAPIPath)(this.networkName, protocol, side), (0, utils_1.serializeOrdersQueryOptions)(__assign({\n              limit: this.pageSize,\n              orderBy: orderBy,\n              orderDirection: orderDirection\n            }, restOptions)))];\n          case 1:\n            response = _e.sent();\n            return [2 /*return*/, __assign(__assign({}, response), {\n              orders: response.orders.map(utils_1.deserializeOrder)\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Generate the data needed to fulfill a listing or an offer\n   */\n  OpenSeaAPI.prototype.generateFulfillmentData = function (fulfillerAddress, orderHash, protocolAddress, side) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = null;\n            if (side === \"ask\") {\n              payload = (0, utils_1.getFulfillListingPayload)(fulfillerAddress, orderHash, protocolAddress, this.networkName);\n            } else {\n              payload = (0, utils_1.getFulfillOfferPayload)(fulfillerAddress, orderHash, protocolAddress, this.networkName);\n            }\n            return [4 /*yield*/, this.post((0, utils_1.getFulfillmentDataPath)(side), payload)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, response];\n        }\n      });\n    });\n  };\n  /**\n   * Send an order to be posted. Throws when the order is invalid.\n   */\n  OpenSeaAPI.prototype.postOrder = function (order, apiOptions, _a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.retries,\n      retries = _c === void 0 ? 2 : _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var response, _d, protocol, side, protocolAddress, error_1;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _d = apiOptions.protocol, protocol = _d === void 0 ? \"seaport\" : _d, side = apiOptions.side, protocolAddress = apiOptions.protocolAddress;\n            _e.label = 1;\n          case 1:\n            _e.trys.push([1, 3,, 5]);\n            return [4 /*yield*/, this.post((0, utils_1.getOrdersAPIPath)(this.networkName, protocol, side), __assign(__assign({}, order), {\n              protocol_address: protocolAddress\n            }))];\n          case 2:\n            response = _e.sent();\n            return [3 /*break*/, 5];\n          case 3:\n            error_1 = _e.sent();\n            _throwOrContinue(error_1, retries);\n            return [4 /*yield*/, (0, utils_2.delay)(this.retryDelay)];\n          case 4:\n            _e.sent();\n            return [2 /*return*/, this.postOrder(order, apiOptions, {\n              retries: retries - 1\n            })];\n          case 5:\n            return [2 /*return*/, (0, utils_1.deserializeOrder)(response.order)];\n        }\n      });\n    });\n  };\n  /**\n   * Build an offer\n   */\n  OpenSeaAPI.prototype.buildOffer = function (offererAddress, quantity, collectionSlug) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = (0, utils_1.getBuildCollectionOfferPayload)(offererAddress, quantity, collectionSlug);\n            return [4 /*yield*/, this.post((0, utils_1.getBuildOfferPath)(), payload)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, response];\n        }\n      });\n    });\n  };\n  /**\n   * Post collection offer\n   */\n  OpenSeaAPI.prototype.postCollectionOffer = function (order, slug, retries) {\n    if (retries === void 0) {\n      retries = 0;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = (0, utils_1.getPostCollectionOfferPayload)(slug, order);\n            console.log(\"Post Order Payload\");\n            console.log(JSON.stringify(payload, null, 4));\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 5]);\n            return [4 /*yield*/, this.post((0, utils_1.getPostCollectionOfferPath)(), payload)];\n          case 2:\n            return [2 /*return*/, _a.sent()];\n          case 3:\n            error_2 = _a.sent();\n            _throwOrContinue(error_2, retries);\n            return [4 /*yield*/, (0, utils_2.delay)(1000)];\n          case 4:\n            _a.sent();\n            return [2 /*return*/, this.postCollectionOffer(order, slug, retries - 1)];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Create a whitelist entry for an asset to prevent others from buying.\n   * Buyers will have to have verified at least one of the emails\n   * on an asset in order to buy.\n   * This will throw a 403 if the given API key isn't allowed to create whitelist entries for this contract or asset.\n   * @param tokenAddress Address of the asset's contract\n   * @param tokenId The asset's token ID\n   * @param email The email allowed to buy.\n   */\n  OpenSeaAPI.prototype.postAssetWhitelist = function (tokenAddress, tokenId, email) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.post(\"\".concat(constants_1.API_PATH, \"/asset/\").concat(tokenAddress, \"/\").concat(tokenId, \"/whitelist/\"), {\n              email: email\n            })];\n          case 1:\n            json = _a.sent();\n            return [2 /*return*/, !!json.success];\n        }\n      });\n    });\n  };\n  /**\n   * Get which version of Wyvern exchange to use to create orders\n   * Simply return null in case API doesn't give us a good response\n   */\n  OpenSeaAPI.prototype.getOrderCreateWyvernExchangeAddress = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.ORDERBOOK_PATH, \"/exchange/\"))];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, result];\n          case 2:\n            error_3 = _a.sent();\n            this.logger(\"Couldn't retrieve Wyvern exchange address for order creation\");\n            return [2 /*return*/, null];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch an asset from the API, throwing if none is found\n   * @param tokenAddress Address of the asset's contract\n   * @param tokenId The asset's token ID, or null if ERC-20\n   * @param retries Number of times to retry if the service is unavailable for any reason\n   */\n  OpenSeaAPI.prototype.getAsset = function (_a, retries) {\n    var tokenAddress = _a.tokenAddress,\n      tokenId = _a.tokenId;\n    if (retries === void 0) {\n      retries = 1;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var json, error_4;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 4]);\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.API_PATH, \"/asset/\").concat(tokenAddress, \"/\").concat(tokenId || 0, \"/\"))];\n          case 1:\n            json = _b.sent();\n            return [3 /*break*/, 4];\n          case 2:\n            error_4 = _b.sent();\n            _throwOrContinue(error_4, retries);\n            return [4 /*yield*/, (0, utils_2.delay)(1000)];\n          case 3:\n            _b.sent();\n            return [2 /*return*/, this.getAsset({\n              tokenAddress: tokenAddress,\n              tokenId: tokenId\n            }, retries - 1)];\n          case 4:\n            return [2 /*return*/, (0, utils_2.assetFromJSON)(json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of assets from the API, returning the page of assets and the count of total assets\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n   */\n  OpenSeaAPI.prototype.getAssets = function (query) {\n    if (query === void 0) {\n      query = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.API_PATH, \"/assets/\"), __assign({\n              limit: this.pageSize\n            }, query))];\n          case 1:\n            json = _a.sent();\n            return [2 /*return*/, {\n              assets: json.assets.map(function (j) {\n                return (0, utils_2.assetFromJSON)(j);\n              }),\n              next: json.next,\n              previous: json.previous,\n              estimatedCount: json.estimated_count\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a collection through the API\n   */\n  OpenSeaAPI.prototype.getCollection = function (slug) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = (0, utils_1.getCollectionPath)(slug);\n            return [4 /*yield*/, this.get(path)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, (0, utils_2.collectionFromJSON)(response.collection)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of fungible tokens from the API matching parameters\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OpenSeaFungibleTokenQuery\n   * @param retries Number of times to retry if the service is unavailable for any reason\n   */\n  OpenSeaAPI.prototype.getPaymentTokens = function (query, page, retries) {\n    if (query === void 0) {\n      query = {};\n    }\n    if (page === void 0) {\n      page = 1;\n    }\n    if (retries === void 0) {\n      retries = 1;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var json, error_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 4]);\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.API_PATH, \"/tokens/\"), __assign(__assign({}, query), {\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }))];\n          case 1:\n            json = _a.sent();\n            return [3 /*break*/, 4];\n          case 2:\n            error_5 = _a.sent();\n            _throwOrContinue(error_5, retries);\n            return [4 /*yield*/, (0, utils_2.delay)(1000)];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, this.getPaymentTokens(query, page, retries - 1)];\n          case 4:\n            return [2 /*return*/, {\n              tokens: json.map(function (t) {\n                return (0, utils_2.tokenFromJSON)(t);\n              })\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a bundle from the API, return null if it isn't found\n   * @param slug The bundle's identifier\n   */\n  OpenSeaAPI.prototype.getBundle = function (_a) {\n    var slug = _a.slug;\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.API_PATH, \"/bundle/\").concat(slug, \"/\"))];\n          case 1:\n            json = _b.sent();\n            return [2 /*return*/, json ? (0, utils_2.assetBundleFromJSON)(json) : null];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch list of bundles from the API, returning the page of bundles and the count of total bundles\n   * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetBundleJSON` type is supported\n   * @param page Page number, defaults to 1. Can be overridden by\n   * `limit` and `offset` attributes from OpenSeaAssetBundleQuery\n   */\n  OpenSeaAPI.prototype.getBundles = function (query, page) {\n    if (query === void 0) {\n      query = {};\n    }\n    if (page === void 0) {\n      page = 1;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.get(\"\".concat(constants_1.API_PATH, \"/bundles/\"), __assign(__assign({}, query), {\n              limit: this.pageSize,\n              offset: (page - 1) * this.pageSize\n            }))];\n          case 1:\n            json = _a.sent();\n            return [2 /*return*/, {\n              bundles: json.bundles.map(function (j) {\n                return (0, utils_2.assetBundleFromJSON)(j);\n              }),\n              estimatedCount: json.estimated_count\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Get JSON data from API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param query Data to send. Will be stringified using QueryString\n   */\n  OpenSeaAPI.prototype.get = function (apiPath, query) {\n    if (query === void 0) {\n      query = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var qs, url, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            qs = QueryString.stringify(query);\n            url = \"\".concat(apiPath, \"?\").concat(qs);\n            return [4 /*yield*/, this._fetch(url)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, response.json()];\n        }\n      });\n    });\n  };\n  /**\n   * POST JSON data to API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param body Data to send. Will be JSON.stringified\n   * @param opts RequestInit opts, similar to Fetch API. If it contains\n   *  a body, it won't be stringified.\n   */\n  OpenSeaAPI.prototype.post = function (apiPath, body, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var fetchOpts, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            fetchOpts = __assign({\n              method: \"POST\",\n              body: body ? JSON.stringify(body) : undefined,\n              headers: {\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/json\"\n              }\n            }, opts);\n            return [4 /*yield*/, this._fetch(apiPath, fetchOpts)];\n          case 1:\n            response = _a.sent();\n            return [2 /*return*/, response.json()];\n        }\n      });\n    });\n  };\n  /**\n   * PUT JSON data to API, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param body Data to send\n   * @param opts RequestInit opts, similar to Fetch API. If it contains\n   *  a body, it won't be stringified.\n   */\n  OpenSeaAPI.prototype.put = function (apiPath, body, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.post(apiPath, body, __assign({\n          method: \"PUT\"\n        }, opts))];\n      });\n    });\n  };\n  /**\n   * Get from an API Endpoint, sending auth token in headers\n   * @param apiPath Path to URL endpoint under API\n   * @param opts RequestInit opts, similar to Fetch API\n   */\n  OpenSeaAPI.prototype._fetch = function (apiPath, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var apiBase, apiKey, finalUrl, finalOpts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        apiBase = this.apiBaseUrl;\n        apiKey = this.apiKey;\n        finalUrl = apiBase + apiPath;\n        finalOpts = __assign(__assign({}, opts), {\n          headers: __assign(__assign({}, apiKey ? {\n            \"X-API-KEY\": apiKey\n          } : {}), opts.headers || {})\n        });\n        this.logger(\"Sending request: \".concat(finalUrl, \" \").concat(JSON.stringify(finalOpts).substr(0, 100), \"...\"));\n        return [2 /*return*/, fetch(finalUrl, finalOpts).then(function (res) {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              return [2 /*return*/, this._handleApiResponse(res)];\n            });\n          });\n        })];\n      });\n    });\n  };\n  OpenSeaAPI.prototype._handleApiResponse = function (response) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, errorMessage, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (response.ok) {\n              this.logger(\"Got success: \".concat(response.status));\n              return [2 /*return*/, response];\n            }\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, response.text()];\n          case 2:\n            result = _b.sent();\n            result = JSON.parse(result);\n            return [3 /*break*/, 4];\n          case 3:\n            _a = _b.sent();\n            return [3 /*break*/, 4];\n          case 4:\n            this.logger(\"Got error \".concat(response.status, \": \").concat(JSON.stringify(result)));\n            switch (response.status) {\n              case 400:\n                errorMessage = result && result.errors ? result.errors.join(\", \") : \"Invalid request: \".concat(JSON.stringify(result));\n                break;\n              case 401:\n              case 403:\n                errorMessage = \"Unauthorized. Full message was '\".concat(JSON.stringify(result), \"'\");\n                break;\n              case 404:\n                errorMessage = \"Not found. Full message was '\".concat(JSON.stringify(result), \"'\");\n                break;\n              case 500:\n                errorMessage = \"Internal server error. OpenSea has been alerted, but if the problem persists please contact us via Discord: https://discord.gg/opensea - full message was \".concat(JSON.stringify(result));\n                break;\n              case 503:\n                errorMessage = \"Service unavailable. Please try again in a few minutes. If the problem persists please contact us via Discord: https://discord.gg/opensea - full message was \".concat(JSON.stringify(result));\n                break;\n              default:\n                errorMessage = \"Message: \".concat(JSON.stringify(result));\n                break;\n            }\n            throw new Error(\"API Error \".concat(response.status, \": \").concat(errorMessage));\n        }\n      });\n    });\n  };\n  return OpenSeaAPI;\n}();\nexports.OpenSeaAPI = OpenSeaAPI;\nfunction _throwOrContinue(error, retries) {\n  var isUnavailable = error instanceof Error && !!error.message && (error.message.includes(\"503\") || error.message.includes(\"429\"));\n  if (retries <= 0 || !isUnavailable) {\n    throw error;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}