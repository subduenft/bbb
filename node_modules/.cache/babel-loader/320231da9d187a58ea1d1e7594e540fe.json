{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldUseMatchForFulfill = exports.generateRandomSaltWithDomain = exports.generateRandomSalt = exports.mapOrderAmountsFromUnitsToFill = exports.mapOrderAmountsFromFilledStatus = exports.totalItemsAmount = exports.areAllCurrenciesSame = exports.mapInputItemToOfferItem = exports.deductFees = exports.feeToConsiderationItem = void 0;\nvar ethers_1 = require(\"ethers\");\nvar utils_1 = require(\"ethers/lib/utils\");\nvar constants_1 = require(\"../constants\");\nvar item_1 = require(\"./item\");\nvar merkletree_1 = require(\"./merkletree\");\nvar multiplyBasisPoints = function multiplyBasisPoints(amount, basisPoints) {\n  return ethers_1.BigNumber.from(amount).mul(ethers_1.BigNumber.from(basisPoints)).div(constants_1.ONE_HUNDRED_PERCENT_BP);\n};\nvar feeToConsiderationItem = function feeToConsiderationItem(_a) {\n  var fee = _a.fee,\n    token = _a.token,\n    baseAmount = _a.baseAmount,\n    _b = _a.baseEndAmount,\n    baseEndAmount = _b === void 0 ? baseAmount : _b;\n  return {\n    itemType: token === ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.NATIVE : constants_1.ItemType.ERC20,\n    token: token,\n    identifierOrCriteria: \"0\",\n    startAmount: multiplyBasisPoints(baseAmount, fee.basisPoints).toString(),\n    endAmount: multiplyBasisPoints(baseEndAmount, fee.basisPoints).toString(),\n    recipient: fee.recipient\n  };\n};\nexports.feeToConsiderationItem = feeToConsiderationItem;\nvar deductFees = function deductFees(items, fees) {\n  if (!fees) {\n    return items;\n  }\n  var totalBasisPoints = fees.reduce(function (accBasisPoints, fee) {\n    return accBasisPoints + fee.basisPoints;\n  }, 0);\n  return items.map(function (item) {\n    return __assign(__assign({}, item), {\n      startAmount: (0, item_1.isCurrencyItem)(item) ? ethers_1.BigNumber.from(item.startAmount).sub(multiplyBasisPoints(item.startAmount, totalBasisPoints)).toString() : item.startAmount,\n      endAmount: (0, item_1.isCurrencyItem)(item) ? ethers_1.BigNumber.from(item.endAmount).sub(multiplyBasisPoints(item.endAmount, totalBasisPoints)).toString() : item.endAmount\n    });\n  });\n};\nexports.deductFees = deductFees;\nvar mapInputItemToOfferItem = function mapInputItemToOfferItem(item) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  // Item is an NFT\n  if (\"itemType\" in item) {\n    // Convert this to a criteria based item\n    if (\"identifiers\" in item) {\n      var tree = new merkletree_1.MerkleTree(item.identifiers);\n      return {\n        itemType: item.itemType === constants_1.ItemType.ERC721 ? constants_1.ItemType.ERC721_WITH_CRITERIA : constants_1.ItemType.ERC1155_WITH_CRITERIA,\n        token: item.token,\n        identifierOrCriteria: tree.getRoot(),\n        startAmount: (_a = item.amount) !== null && _a !== void 0 ? _a : \"1\",\n        endAmount: (_c = (_b = item.endAmount) !== null && _b !== void 0 ? _b : item.amount) !== null && _c !== void 0 ? _c : \"1\"\n      };\n    }\n    if (\"amount\" in item || \"endAmount\" in item) {\n      return {\n        itemType: item.itemType,\n        token: item.token,\n        identifierOrCriteria: item.identifier,\n        // @ts-ignore\n        startAmount: item.amount,\n        // @ts-ignore\n        endAmount: (_e = (_d = item.endAmount) !== null && _d !== void 0 ? _d : item.amount) !== null && _e !== void 0 ? _e : \"1\"\n      };\n    }\n    return {\n      itemType: item.itemType,\n      token: item.token,\n      identifierOrCriteria: item.identifier,\n      startAmount: \"1\",\n      endAmount: \"1\"\n    };\n  }\n  // Item is a currency\n  return {\n    itemType: item.token && item.token !== ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.ERC20 : constants_1.ItemType.NATIVE,\n    token: (_f = item.token) !== null && _f !== void 0 ? _f : ethers_1.ethers.constants.AddressZero,\n    identifierOrCriteria: \"0\",\n    startAmount: item.amount,\n    endAmount: (_g = item.endAmount) !== null && _g !== void 0 ? _g : item.amount\n  };\n};\nexports.mapInputItemToOfferItem = mapInputItemToOfferItem;\nvar areAllCurrenciesSame = function areAllCurrenciesSame(_a) {\n  var offer = _a.offer,\n    consideration = _a.consideration;\n  var allItems = __spreadArray(__spreadArray([], __read(offer), false), __read(consideration), false);\n  var currencies = allItems.filter(item_1.isCurrencyItem);\n  return currencies.every(function (_a) {\n    var itemType = _a.itemType,\n      token = _a.token;\n    return itemType === currencies[0].itemType && token.toLowerCase() === currencies[0].token.toLowerCase();\n  });\n};\nexports.areAllCurrenciesSame = areAllCurrenciesSame;\nvar totalItemsAmount = function totalItemsAmount(items) {\n  var initialValues = {\n    startAmount: ethers_1.BigNumber.from(0),\n    endAmount: ethers_1.BigNumber.from(0)\n  };\n  return items.map(function (_a) {\n    var startAmount = _a.startAmount,\n      endAmount = _a.endAmount;\n    return {\n      startAmount: startAmount,\n      endAmount: endAmount\n    };\n  }).reduce(function (_a, _b) {\n    var totalStartAmount = _a.startAmount,\n      totalEndAmount = _a.endAmount;\n    var startAmount = _b.startAmount,\n      endAmount = _b.endAmount;\n    return {\n      startAmount: totalStartAmount.add(startAmount),\n      endAmount: totalEndAmount.add(endAmount)\n    };\n  }, {\n    startAmount: ethers_1.BigNumber.from(0),\n    endAmount: ethers_1.BigNumber.from(0)\n  });\n};\nexports.totalItemsAmount = totalItemsAmount;\n/**\n * Maps order offer and consideration item amounts based on the order's filled status\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n */\nvar mapOrderAmountsFromFilledStatus = function mapOrderAmountsFromFilledStatus(order, _a) {\n  var totalFilled = _a.totalFilled,\n    totalSize = _a.totalSize;\n  if (totalFilled.eq(0) || totalSize.eq(0)) {\n    return order;\n  }\n  // i.e if totalFilled is 3 and totalSize is 4, there are 1 / 4 order amounts left to fill.\n  var basisPoints = totalSize.sub(totalFilled).mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(totalSize);\n  return {\n    parameters: __assign(__assign({}, order.parameters), {\n      offer: order.parameters.offer.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      }),\n      consideration: order.parameters.consideration.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      })\n    }),\n    signature: order.signature\n  };\n};\nexports.mapOrderAmountsFromFilledStatus = mapOrderAmountsFromFilledStatus;\n/**\n * Maps order offer and consideration item amounts based on the units needed to fulfill\n * After applying the fraction, we can view this order as the \"canonical\" order for which we\n * check approvals and balances\n * Returns the numerator and denominator as well, converting this to an AdvancedOrder\n */\nvar mapOrderAmountsFromUnitsToFill = function mapOrderAmountsFromUnitsToFill(order, _a) {\n  var unitsToFill = _a.unitsToFill,\n    totalFilled = _a.totalFilled,\n    totalSize = _a.totalSize;\n  var unitsToFillBn = ethers_1.BigNumber.from(unitsToFill);\n  if (unitsToFillBn.lte(0)) {\n    throw new Error(\"Units to fill must be greater than 1\");\n  }\n  var maxUnits = (0, item_1.getMaximumSizeForOrder)(order);\n  if (totalSize.eq(0)) {\n    totalSize = maxUnits;\n  }\n  // This is the percentage of the order that is left to be fulfilled, and therefore we can't fill more than that.\n  var remainingOrderPercentageToBeFilled = totalSize.sub(totalFilled).mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(totalSize);\n  // i.e if totalSize is 8 and unitsToFill is 3, then we multiply every amount by 3 / 8\n  var unitsToFillBasisPoints = unitsToFillBn.mul(constants_1.ONE_HUNDRED_PERCENT_BP).div(maxUnits);\n  // We basically choose the lesser between the units requested to be filled and the actual remaining order amount left\n  // This is so that if a user tries to fulfill an order that is 1/2 filled, and supplies a fraction such as 3/4, the maximum\n  // amount to fulfill is 1/2 instead of 3/4\n  var basisPoints = remainingOrderPercentageToBeFilled.gt(unitsToFillBasisPoints) ? unitsToFillBasisPoints : remainingOrderPercentageToBeFilled;\n  return {\n    parameters: __assign(__assign({}, order.parameters), {\n      offer: order.parameters.offer.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      }),\n      consideration: order.parameters.consideration.map(function (item) {\n        return __assign(__assign({}, item), {\n          startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(),\n          endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString()\n        });\n      })\n    }),\n    signature: order.signature\n  };\n};\nexports.mapOrderAmountsFromUnitsToFill = mapOrderAmountsFromUnitsToFill;\nvar generateRandomSalt = function generateRandomSalt() {\n  return \"0x\".concat(Buffer.from((0, utils_1.randomBytes)(8)).toString(\"hex\").padStart(24, \"0\"));\n};\nexports.generateRandomSalt = generateRandomSalt;\nvar generateRandomSaltWithDomain = function generateRandomSaltWithDomain(domain) {\n  return \"0x\".concat(Buffer.from((0, utils_1.concat)([(0, utils_1.keccak256)((0, utils_1.toUtf8Bytes)(domain)).slice(0, 10), Uint8Array.from(Array(20).fill(0)), (0, utils_1.randomBytes)(8)])).toString(\"hex\"));\n};\nexports.generateRandomSaltWithDomain = generateRandomSaltWithDomain;\nvar shouldUseMatchForFulfill = function shouldUseMatchForFulfill() {\n  return true;\n};\nexports.shouldUseMatchForFulfill = shouldUseMatchForFulfill;","map":null,"metadata":{},"sourceType":"script"}