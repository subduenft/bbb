{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateDataItemFromSignature = void 0;\nvar _ = require(\"lodash\");\nfunction parseNode(node) {\n  var components = [];\n  _.each(node.children, function (child) {\n    var component = parseNode(child);\n    components.push(component);\n  });\n  var dataItem = {\n    name: node.name,\n    type: node.value\n  };\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\nfunction generateDataItemFromSignature(signature) {\n  // No data item corresponds to an empty signature\n  if (_.isEmpty(signature)) {\n    throw new Error(\"Cannot parse data item from empty signature, ''\");\n  }\n  // Create a parse tree for data item\n  var node = {\n    name: '',\n    value: '',\n    children: []\n  };\n  var _iterator = _createForOfIteratorHelper(signature),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var char = _step.value;\n      switch (char) {\n        case '(':\n          var child = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node\n          };\n          node.value = 'tuple';\n          node.children.push(child);\n          node = child;\n          break;\n        case ')':\n          node = node.parent;\n          break;\n        case ',':\n          var sibling = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node.parent\n          };\n          node.parent.children.push(sibling);\n          node = sibling;\n          break;\n        case ' ':\n          node.name = node.value;\n          node.value = '';\n          break;\n        default:\n          node.value += char;\n          break;\n      }\n    }\n    // Interpret data item from parse tree\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var dataItem = parseNode(node);\n  return dataItem;\n}\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":null,"metadata":{},"sourceType":"script"}