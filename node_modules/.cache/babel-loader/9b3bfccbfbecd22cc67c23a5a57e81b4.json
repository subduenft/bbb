{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\nvar _wrapNativeSuper = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawRevertError = exports.AnyRevertError = exports.StringRevertError = exports.getThrownErrorRevertErrorBytes = exports.RevertError = exports.coerceThrownErrorAsRevertError = exports.decodeThrownErrorAsRevertError = exports.decodeBytesAsRevertError = exports.registerRevertErrorType = void 0;\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar util_1 = require(\"util\");\nvar AbiEncoder = require(\"./abi_encoder\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n/**\n * Register a RevertError type so that it can be decoded by\n * `decodeRevertError`.\n * @param revertClass A class that inherits from RevertError.\n * @param force Allow overwriting registered types.\n */\nfunction registerRevertErrorType(revertClass) {\n  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  RevertError.registerType(revertClass, force);\n}\nexports.registerRevertErrorType = registerRevertErrorType;\n/**\n * Decode an ABI encoded revert error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\nfunction decodeBytesAsRevertError(bytes) {\n  var coerce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return RevertError.decode(bytes, coerce);\n}\nexports.decodeBytesAsRevertError = decodeBytesAsRevertError;\n/**\n * Decode a thrown error.\n * Throws if the data cannot be decoded as a known RevertError type.\n * @param error Any thrown error.\n * @param coerce Coerce unknown selectors into a `RawRevertError` type.\n * @return A RevertError object.\n */\nfunction decodeThrownErrorAsRevertError(error) {\n  var coerce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (error instanceof RevertError) {\n    return error;\n  }\n  return RevertError.decode(getThrownErrorRevertErrorBytes(error), coerce);\n}\nexports.decodeThrownErrorAsRevertError = decodeThrownErrorAsRevertError;\n/**\n * Coerce a thrown error into a `RevertError`. Always succeeds.\n * @param error Any thrown error.\n * @return A RevertError object.\n */\nfunction coerceThrownErrorAsRevertError(error) {\n  if (error instanceof RevertError) {\n    return error;\n  }\n  try {\n    return decodeThrownErrorAsRevertError(error, true);\n  } catch (err) {\n    if (isGanacheTransactionRevertError(error)) {\n      throw err;\n    }\n    // Handle geth transaction reverts.\n    if (isGethTransactionRevertError(error)) {\n      // Geth transaction reverts are opaque, meaning no useful data is returned,\n      // so we just return an AnyRevertError type.\n      return new AnyRevertError();\n    }\n    // Coerce plain errors into a StringRevertError.\n    return new StringRevertError(error.message);\n  }\n}\nexports.coerceThrownErrorAsRevertError = coerceThrownErrorAsRevertError;\n/**\n * Base type for revert errors.\n */\nvar RevertError = /*#__PURE__*/function (_Error) {\n  _inherits(RevertError, _Error);\n  /**\n   * Create a RevertError instance with optional parameter values.\n   * Parameters that are left undefined will not be tested in equality checks.\n   * @param declaration Function-style declaration of the revert (e.g., Error(string message))\n   * @param values Optional mapping of parameters to values.\n   * @param raw Optional encoded form of the revert error. If supplied, this\n   *        instance will be treated as a `RawRevertError`, meaning it can only\n   *        match other `RawRevertError` types with the same encoded payload.\n   */\n  function RevertError(name, declaration, values, raw) {\n    var _this;\n    _classCallCheck(this, RevertError);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RevertError).call(this, createErrorMessage(name, values)));\n    _this.values = {};\n    if (declaration !== undefined) {\n      _this.abi = declarationToAbi(declaration);\n      if (values !== undefined) {\n        _.assign(_this.values, _.cloneDeep(values));\n      }\n    }\n    _this._raw = raw;\n    // Extending Error is tricky; we need to explicitly set the prototype.\n    Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), (this instanceof RevertError ? this.constructor : void 0).prototype);\n    return _this;\n  }\n  /**\n   * Decode an ABI encoded revert error.\n   * Throws if the data cannot be decoded as a known RevertError type.\n   * @param bytes The ABI encoded revert error. Either a hex string or a Buffer.\n   * @param coerce Whether to coerce unknown selectors into a `RawRevertError` type.\n   * @return A RevertError object.\n   */\n  _createClass(RevertError, [{\n    key: \"equals\",\n    /**\n     * Compares this instance with another.\n     * Fails if instances are not of the same type.\n     * Only fields/values defined in both instances are compared.\n     * @param other Either another RevertError instance, hex-encoded bytes, or a Buffer of the ABI encoded revert.\n     * @return True if both instances match.\n     */\n    value: function equals(other) {\n      var _other = other;\n      if (_other instanceof Buffer) {\n        _other = ethUtil.bufferToHex(_other);\n      }\n      if (typeof _other === 'string') {\n        _other = RevertError.decode(_other);\n      }\n      if (!(_other instanceof RevertError)) {\n        return false;\n      }\n      // If either is of the `AnyRevertError` type, always succeed.\n      if (this._isAnyType || _other._isAnyType) {\n        return true;\n      }\n      // If either are raw types, they must match their raw data.\n      if (this._isRawType || _other._isRawType) {\n        return this._raw === _other._raw;\n      }\n      // Must be of same type.\n      if (this.constructor !== _other.constructor) {\n        return false;\n      }\n      // Must share the same parameter values if defined in both instances.\n      for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var a = this.values[name];\n        var b = _other.values[name];\n        if (a === b) {\n          continue;\n        }\n        if (!_.isNil(a) && !_.isNil(b)) {\n          var _this$_getArgumentByN = this._getArgumentByName(name),\n            type = _this$_getArgumentByN.type;\n          if (!checkArgEquality(type, a, b)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      if (this._raw !== undefined) {\n        return this._raw;\n      }\n      if (!this._hasAllArgumentValues) {\n        throw new Error(\"Instance of \".concat(this.typeName, \" does not have all its parameter values set.\"));\n      }\n      var encoder = createEncoder(this.abi);\n      return encoder(this.values);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this._isRawType) {\n        return \"\".concat(this.constructor.name, \"(\").concat(this._raw, \")\");\n      }\n      var values = _.omitBy(this.values, function (v) {\n        return _.isNil(v);\n      });\n      // tslint:disable-next-line: forin\n      for (var k in values) {\n        var _this$_getArgumentByN2 = this._getArgumentByName(k),\n          argType = _this$_getArgumentByN2.type;\n        if (argType === 'bytes') {\n          // Try to decode nested revert errors.\n          try {\n            values[k] = RevertError.decode(values[k]);\n          } catch (err) {} // tslint:disable-line:no-empty\n        }\n      }\n\n      var inner = _.isEmpty(values) ? '' : util_1.inspect(values);\n      return \"\".concat(this.constructor.name, \"(\").concat(inner, \")\");\n    }\n  }, {\n    key: \"_getArgumentByName\",\n    value: function _getArgumentByName(name) {\n      var arg = _.find(this.arguments, function (a) {\n        return a.name === name;\n      });\n      if (_.isNil(arg)) {\n        throw new Error(\"RevertError \".concat(this.signature, \" has no argument named \").concat(name));\n      }\n      return arg;\n    }\n  }, {\n    key: \"name\",\n    /**\n     * Get the ABI name for this revert.\n     */\n    get: function get() {\n      if (!_.isNil(this.abi)) {\n        return this.abi.name;\n      }\n      return \"<\".concat(this.typeName, \">\");\n    }\n    /**\n     * Get the class name of this type.\n     */\n  }, {\n    key: \"typeName\",\n    get: function get() {\n      // tslint:disable-next-line: no-string-literal\n      return this.constructor.name;\n    }\n    /**\n     * Get the hex selector for this revert (without leading '0x').\n     */\n  }, {\n    key: \"selector\",\n    get: function get() {\n      if (!_.isNil(this.abi)) {\n        return toSelector(this.abi);\n      }\n      if (this._isRawType) {\n        // tslint:disable-next-line: custom-no-magic-numbers\n        return this._raw.slice(2, 10);\n      }\n      return '';\n    }\n    /**\n     * Get the signature for this revert: e.g., 'Error(string)'.\n     */\n  }, {\n    key: \"signature\",\n    get: function get() {\n      if (!_.isNil(this.abi)) {\n        return toSignature(this.abi);\n      }\n      return '';\n    }\n    /**\n     * Get the ABI arguments for this revert.\n     */\n  }, {\n    key: \"arguments\",\n    get: function get() {\n      if (!_.isNil(this.abi)) {\n        return this.abi.arguments || [];\n      }\n      return [];\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return this.toString();\n    }\n  }, {\n    key: \"_isAnyType\",\n    get: function get() {\n      return _.isNil(this.abi) && _.isNil(this._raw);\n    }\n  }, {\n    key: \"_isRawType\",\n    get: function get() {\n      return !_.isNil(this._raw);\n    }\n  }, {\n    key: \"_hasAllArgumentValues\",\n    get: function get() {\n      if (_.isNil(this.abi) || _.isNil(this.abi.arguments)) {\n        return false;\n      }\n      var _iterator = _createForOfIteratorHelper(this.abi.arguments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var arg = _step.value;\n          if (_.isNil(this.values[arg.name])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return true;\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(bytes) {\n      var coerce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (bytes instanceof RevertError) {\n        return bytes;\n      }\n      var _bytes = bytes instanceof Buffer ? ethUtil.bufferToHex(bytes) : ethUtil.addHexPrefix(bytes);\n      // tslint:disable-next-line: custom-no-magic-numbers\n      var selector = _bytes.slice(2, 10);\n      if (!(selector in RevertError._typeRegistry)) {\n        if (coerce) {\n          return new RawRevertError(bytes);\n        }\n        throw new Error(\"Unknown selector: \".concat(selector));\n      }\n      var _RevertError$_typeReg = RevertError._typeRegistry[selector],\n        type = _RevertError$_typeReg.type,\n        decoder = _RevertError$_typeReg.decoder;\n      var instance = new type();\n      try {\n        Object.assign(instance, {\n          values: decoder(_bytes)\n        });\n        instance.message = instance.toString();\n        return instance;\n      } catch (err) {\n        throw new Error(\"Bytes \".concat(_bytes, \" cannot be decoded as a revert error of type \").concat(instance.signature, \": \").concat(err.message));\n      }\n    }\n    /**\n     * Register a RevertError type so that it can be decoded by\n     * `RevertError.decode`.\n     * @param revertClass A class that inherits from RevertError.\n     * @param force Allow overwriting existing registrations.\n     */\n  }, {\n    key: \"registerType\",\n    value: function registerType(revertClass) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var instance = new revertClass();\n      if (!force && instance.selector in RevertError._typeRegistry) {\n        throw new Error(\"RevertError type with signature \\\"\".concat(instance.signature, \"\\\" is already registered\"));\n      }\n      if (_.isNil(instance.abi)) {\n        throw new Error(\"Attempting to register a RevertError class with no ABI\");\n      }\n      RevertError._typeRegistry[instance.selector] = {\n        type: revertClass,\n        decoder: createDecoder(instance.abi)\n      };\n    }\n  }]);\n  return RevertError;\n}(_wrapNativeSuper(Error));\nexports.RevertError = RevertError;\n// Map of types registered via `registerType`.\nRevertError._typeRegistry = {};\nvar PARITY_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM execution error/;\nvar GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE = /^VM Exception while processing transaction: revert/;\nvar GETH_TRANSACTION_REVERT_ERROR_MESSAGE = /always failing transaction$/;\n/**\n * Try to extract the ecnoded revert error bytes from a thrown `Error`.\n */\nfunction getThrownErrorRevertErrorBytes(error) {\n  // Handle ganache transaction reverts.\n  if (isGanacheTransactionRevertError(error)) {\n    // Grab the first result attached.\n    var result = error.results[error.hashes[0]];\n    // If a reason is provided, just wrap it in a StringRevertError\n    if (result.reason !== undefined) {\n      return new StringRevertError(result.reason).encode();\n    }\n    if (result.return !== undefined && result.return !== '0x') {\n      return result.return;\n    }\n  } else if (isParityTransactionRevertError(error)) {\n    // Parity returns { data: 'Reverted 0xa6bcde47...', ... }\n    var data = error.data;\n    var hexDataIndex = data.indexOf('0x');\n    if (hexDataIndex !== -1) {\n      return data.slice(hexDataIndex);\n    }\n  } else {\n    // Handle geth transaction reverts.\n    if (isGethTransactionRevertError(error)) {\n      // Geth transaction reverts are opaque, meaning no useful data is returned,\n      // so we do nothing.\n    }\n  }\n  throw new Error(\"Cannot decode thrown Error \\\"\".concat(error.message, \"\\\" as a RevertError\"));\n}\nexports.getThrownErrorRevertErrorBytes = getThrownErrorRevertErrorBytes;\nfunction isParityTransactionRevertError(error) {\n  if (PARITY_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'code' in error && 'data' in error) {\n    return true;\n  }\n  return false;\n}\nfunction isGanacheTransactionRevertError(error) {\n  if (GANACHE_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message) && 'hashes' in error && 'results' in error) {\n    return true;\n  }\n  return false;\n}\nfunction isGethTransactionRevertError(error) {\n  return GETH_TRANSACTION_REVERT_ERROR_MESSAGE.test(error.message);\n}\n/**\n * RevertError type for standard string reverts.\n */\nvar StringRevertError = /*#__PURE__*/function (_RevertError) {\n  _inherits(StringRevertError, _RevertError);\n  function StringRevertError(message) {\n    _classCallCheck(this, StringRevertError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(StringRevertError).call(this, 'StringRevertError', 'Error(string message)', {\n      message: message\n    }));\n  }\n  return StringRevertError;\n}(RevertError);\nexports.StringRevertError = StringRevertError;\n/**\n * Special RevertError type that matches with any other RevertError instance.\n */\nvar AnyRevertError = /*#__PURE__*/function (_RevertError2) {\n  _inherits(AnyRevertError, _RevertError2);\n  function AnyRevertError() {\n    _classCallCheck(this, AnyRevertError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(AnyRevertError).call(this, 'AnyRevertError'));\n  }\n  return AnyRevertError;\n}(RevertError);\nexports.AnyRevertError = AnyRevertError;\n/**\n * Special RevertError type that is not decoded.\n */\nvar RawRevertError = /*#__PURE__*/function (_RevertError3) {\n  _inherits(RawRevertError, _RevertError3);\n  function RawRevertError(encoded) {\n    _classCallCheck(this, RawRevertError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(RawRevertError).call(this, 'RawRevertError', undefined, undefined, typeof encoded === 'string' ? encoded : ethUtil.bufferToHex(encoded)));\n  }\n  return RawRevertError;\n}(RevertError);\nexports.RawRevertError = RawRevertError;\n/**\n * Create an error message for a RevertError.\n * @param name The name of the RevertError.\n * @param values The values for the RevertError.\n */\nfunction createErrorMessage(name, values) {\n  if (values === undefined) {\n    return \"\".concat(name, \"()\");\n  }\n  var _values = _.omitBy(values, function (v) {\n    return _.isNil(v);\n  });\n  var inner = _.isEmpty(_values) ? '' : util_1.inspect(_values);\n  return \"\".concat(name, \"(\").concat(inner, \")\");\n}\n/**\n * Parse a solidity function declaration into a RevertErrorAbi object.\n * @param declaration Function declaration (e.g., 'foo(uint256 bar)').\n * @return A RevertErrorAbi object.\n */\nfunction declarationToAbi(declaration) {\n  var m = /^\\s*([_a-z][a-z0-9_]*)\\((.*)\\)\\s*$/i.exec(declaration);\n  if (!m) {\n    throw new Error(\"Invalid Revert Error signature: \\\"\".concat(declaration, \"\\\"\"));\n  }\n  var _m$slice = m.slice(1),\n    _m$slice2 = _slicedToArray(_m$slice, 2),\n    name = _m$slice2[0],\n    args = _m$slice2[1];\n  var argList = _.filter(args.split(','));\n  var argData = _.map(argList, function (a) {\n    // Match a function parameter in the format 'TYPE ID', where 'TYPE' may be\n    // an array type.\n    m = /^\\s*(([_a-z][a-z0-9_]*)(\\[\\d*\\])*)\\s+([_a-z][a-z0-9_]*)\\s*$/i.exec(a);\n    if (!m) {\n      throw new Error(\"Invalid Revert Error signature: \\\"\".concat(declaration, \"\\\"\"));\n    }\n    // tslint:disable: custom-no-magic-numbers\n    return {\n      name: m[4],\n      type: m[1]\n    };\n    // tslint:enable: custom-no-magic-numbers\n  });\n\n  var r = {\n    type: 'error',\n    name: name,\n    arguments: _.isEmpty(argData) ? [] : argData\n  };\n  return r;\n}\nfunction checkArgEquality(type, lhs, rhs) {\n  // Try to compare as decoded revert errors first.\n  try {\n    return RevertError.decode(lhs).equals(RevertError.decode(rhs));\n  } catch (err) {\n    // no-op\n  }\n  if (type === 'address') {\n    return normalizeAddress(lhs) === normalizeAddress(rhs);\n  } else if (type === 'bytes' || /^bytes(\\d+)$/.test(type)) {\n    return normalizeBytes(lhs) === normalizeBytes(rhs);\n  } else if (type === 'string') {\n    return lhs === rhs;\n  } else if (/\\[\\d*\\]$/.test(type)) {\n    // An array type.\n    // tslint:disable: custom-no-magic-numbers\n    // Arguments must be arrays and have the same dimensions.\n    if (lhs.length !== rhs.length) {\n      return false;\n    }\n    var m = /^(.+)\\[(\\d*)\\]$/.exec(type);\n    var baseType = m[1];\n    var isFixedLength = m[2].length !== 0;\n    if (isFixedLength) {\n      var length = parseInt(m[2], 10);\n      // Fixed-size arrays have a fixed dimension.\n      if (lhs.length !== length) {\n        return false;\n      }\n    }\n    // Recurse into sub-elements.\n    var _iterator2 = _createForOfIteratorHelper(_.zip(lhs, rhs)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n          slhs = _step2$value[0],\n          srhs = _step2$value[1];\n        if (!checkArgEquality(baseType, slhs, srhs)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return true;\n    // tslint:enable: no-magic-numbers\n  }\n  // tslint:disable-next-line\n  return new configured_bignumber_1.BigNumber(lhs || 0).eq(rhs);\n}\nfunction normalizeAddress(addr) {\n  var ADDRESS_SIZE = 20;\n  return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(ethUtil.addHexPrefix(addr)), ADDRESS_SIZE));\n}\nfunction normalizeBytes(bytes) {\n  return ethUtil.addHexPrefix(bytes).toLowerCase();\n}\nfunction createEncoder(abi) {\n  var encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n  return function (values) {\n    var valuesArray = _.map(abi.arguments, function (arg) {\n      return values[arg.name];\n    });\n    return encoder.encode(valuesArray);\n  };\n}\nfunction createDecoder(abi) {\n  var encoder = AbiEncoder.createMethod(abi.name, abi.arguments || []);\n  return function (hex) {\n    return encoder.decode(hex);\n  };\n}\nfunction toSignature(abi) {\n  var argTypes = _.map(abi.arguments, function (a) {\n    return a.type;\n  });\n  var args = argTypes.join(',');\n  return \"\".concat(abi.name, \"(\").concat(args, \")\");\n}\nfunction toSelector(abi) {\n  return ethUtil.keccak256(Buffer.from(toSignature(abi)))\n  // tslint:disable-next-line: custom-no-magic-numbers\n  .slice(0, 4).toString('hex');\n}\n// Register StringRevertError\nRevertError.registerType(StringRevertError);\n// tslint:disable-next-line max-file-line-count","map":null,"metadata":{},"sourceType":"script"}