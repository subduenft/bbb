{"ast":null,"code":"var ethUtil = require('ethereumjs-util');\nvar MR = require('miller-rabin');\nvar BN = ethUtil.BN;\nexports.params = {\n  DATASET_BYTES_INIT: 1073741824,\n  // 2^30\n  DATASET_BYTES_GROWTH: 8388608,\n  // 2 ^ 23\n  CACHE_BYTES_INIT: 16777216,\n  // 2**24 number of bytes in dataset at genesis\n  CACHE_BYTES_GROWTH: 131072,\n  // 2**17 cache growth per epoch\n  CACHE_MULTIPLIER: 1024,\n  // Size of the DAG relative to the cache\n  EPOCH_LENGTH: 30000,\n  // blocks per epoch\n  MIX_BYTES: 128,\n  // width of mix\n  HASH_BYTES: 64,\n  // hash length in bytes\n  DATASET_PARENTS: 256,\n  // number of parents of each dataset element\n  CACHE_ROUNDS: 3,\n  // number of rounds in cache production\n  ACCESSES: 64,\n  WORD_BYTES: 4\n};\nexports.getCacheSize = function (epoc) {\n  var mr = new MR();\n  var sz = exports.params.CACHE_BYTES_INIT + exports.params.CACHE_BYTES_GROWTH * epoc;\n  sz -= exports.params.HASH_BYTES;\n  while (!mr.test(new BN(sz / exports.params.HASH_BYTES))) {\n    sz -= 2 * exports.params.HASH_BYTES;\n  }\n  return sz;\n};\nexports.getFullSize = function (epoc) {\n  var mr = new MR();\n  var sz = exports.params.DATASET_BYTES_INIT + exports.params.DATASET_BYTES_GROWTH * epoc;\n  sz -= exports.params.MIX_BYTES;\n  while (!mr.test(new BN(sz / exports.params.MIX_BYTES))) {\n    sz -= 2 * exports.params.MIX_BYTES;\n  }\n  return sz;\n};\nexports.getEpoc = function (blockNumber) {\n  return Math.floor(blockNumber / exports.params.EPOCH_LENGTH);\n};\n\n/**\n * Generates a seed give the end epoc and optional the begining epoc and the\n * begining epoc seed\n * @method getSeed\n * @param end Number\n * @param begin Number\n * @param seed Buffer\n */\nexports.getSeed = function (seed, begin, end) {\n  for (var i = begin; i < end; i++) {\n    seed = ethUtil.keccak256(seed);\n  }\n  return seed;\n};\nvar fnv = exports.fnv = function (x, y) {\n  return ((x * 0x01000000 | 0) + (x * 0x193 | 0) ^ y) >>> 0;\n};\nexports.fnvBuffer = function (a, b) {\n  var r = Buffer.alloc(a.length);\n  for (var i = 0; i < a.length; i = i + 4) {\n    r.writeUInt32LE(fnv(a.readUInt32LE(i), b.readUInt32LE(i)), i);\n  }\n  return r;\n};\nexports.bufReverse = function (a) {\n  var length = a.length;\n  var b = Buffer.alloc(length);\n  for (var i = 0; i < length; i++) {\n    b[i] = a[length - i - 1];\n  }\n  return b;\n};","map":null,"metadata":{},"sourceType":"script"}