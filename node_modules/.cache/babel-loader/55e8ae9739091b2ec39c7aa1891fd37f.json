{"ast":null,"code":"var Common = require('ethereumjs-common').default;\nvar ethUtil = require('ethereumjs-util');\nvar _require = require('ethereumjs-tx'),\n  Transaction = _require.Transaction;\nvar Trie = require('merkle-patricia-tree');\nvar BN = ethUtil.BN;\nvar rlp = ethUtil.rlp;\nvar async = require('async');\nvar BlockHeader = require('./header');\n\n/**\n * Creates a new block object\n * @constructor the raw serialized or the deserialized block.\n * @param {Array|Buffer|Object} data\n * @param {Array} opts Options\n * @param {String|Number} opts.chain The chain for the block [default: 'mainnet']\n * @param {String} opts.hardfork Hardfork for the block [default: null, block number-based behaviour]\n * @param {Object} opts.common Alternatively pass a Common instance (ethereumjs-common) instead of setting chain/hardfork directly\n * @prop {Header} header the block's header\n * @prop {Array.<Header>} uncleList an array of uncle headers\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\nvar Block = module.exports = function (data, opts) {\n  opts = opts || {};\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!');\n    }\n    this._common = opts.common;\n  } else {\n    var chain = opts.chain ? opts.chain : 'mainnet';\n    var hardfork = opts.hardfork ? opts.hardfork : null;\n    this._common = new Common(chain, hardfork);\n  }\n  this.transactions = [];\n  this.uncleHeaders = [];\n  this._inBlockChain = false;\n  this.txTrie = new Trie();\n  Object.defineProperty(this, 'raw', {\n    get: function get() {\n      return this.serialize(false);\n    }\n  });\n  var rawTransactions, rawUncleHeaders;\n\n  // defaults\n  if (!data) {\n    data = [[], [], []];\n  }\n  if (Buffer.isBuffer(data)) {\n    data = rlp.decode(data);\n  }\n  if (Array.isArray(data)) {\n    this.header = new BlockHeader(data[0], opts);\n    rawTransactions = data[1];\n    rawUncleHeaders = data[2];\n  } else {\n    this.header = new BlockHeader(data.header, opts);\n    rawTransactions = data.transactions || [];\n    rawUncleHeaders = data.uncleHeaders || [];\n  }\n\n  // parse uncle headers\n  for (var i = 0; i < rawUncleHeaders.length; i++) {\n    this.uncleHeaders.push(new BlockHeader(rawUncleHeaders[i], opts));\n  }\n\n  // parse transactions\n  for (i = 0; i < rawTransactions.length; i++) {\n    var tx = new Transaction(rawTransactions[i], opts);\n    tx._homestead = true;\n    this.transactions.push(tx);\n  }\n};\nBlock.Header = BlockHeader;\n\n/**\n * Produces a hash the RLP of the block\n * @method hash\n */\nBlock.prototype.hash = function () {\n  return this.header.hash();\n};\n\n/**\n * Determines if a given block is the genesis block\n * @method isGenisis\n * @return Boolean\n */\nBlock.prototype.isGenesis = function () {\n  return this.header.isGenesis();\n};\n\n/**\n * turns the block into the canonical genesis block\n * @method setGenesisParams\n */\nBlock.prototype.setGenesisParams = function () {\n  this.header.setGenesisParams();\n};\n\n/**\n * Produces a serialization of the block.\n * @method serialize\n * @param {Boolean} rlpEncode whether to rlp encode the block or not\n */\nBlock.prototype.serialize = function (rlpEncode) {\n  var raw = [this.header.raw, [], []];\n\n  // rlpEnode defaults to true\n  if (typeof rlpEncode === 'undefined') {\n    rlpEncode = true;\n  }\n  this.transactions.forEach(function (tx) {\n    raw[1].push(tx.raw);\n  });\n  this.uncleHeaders.forEach(function (uncle) {\n    raw[2].push(uncle.raw);\n  });\n  return rlpEncode ? rlp.encode(raw) : raw;\n};\n\n/**\n * Generate transaction trie. The tx trie must be generated before the transaction trie can\n * be validated with `validateTransactionTrie`\n * @method genTxTrie\n * @param {Function} cb the callback\n */\nBlock.prototype.genTxTrie = function (cb) {\n  var i = 0;\n  var self = this;\n  async.eachSeries(this.transactions, function (tx, done) {\n    self.txTrie.put(rlp.encode(i), tx.serialize(), done);\n    i++;\n  }, cb);\n};\n\n/**\n * Validates the transaction trie\n * @method validateTransactionTrie\n * @return {Boolean}\n */\nBlock.prototype.validateTransactionsTrie = function () {\n  var txT = this.header.transactionsTrie.toString('hex');\n  if (this.transactions.length) {\n    return txT === this.txTrie.root.toString('hex');\n  } else {\n    return txT === ethUtil.SHA3_RLP.toString('hex');\n  }\n};\n\n/**\n * Validates the transactions\n * @method validateTransactions\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean}\n */\nBlock.prototype.validateTransactions = function (stringError) {\n  var errors = [];\n  this.transactions.forEach(function (tx, i) {\n    var error = tx.validate(true);\n    if (error) {\n      errors.push(error + ' at tx ' + i);\n    }\n  });\n  if (stringError === undefined || stringError === false) {\n    return errors.length === 0;\n  } else {\n    return arrayToString(errors);\n  }\n};\n\n/**\n * Validates the entire block. Returns a string to the callback if block is invalid\n * @method validate\n * @param {BlockChain} blockChain the blockchain that this block wants to be part of\n * @param {Function} cb the callback which is given a `String` if the block is not valid\n */\nBlock.prototype.validate = function (blockChain, cb) {\n  var self = this;\n  var errors = [];\n  async.parallel([\n  // validate uncles\n  self.validateUncles.bind(self, blockChain),\n  // validate block\n  self.header.validate.bind(self.header, blockChain),\n  // generate the transaction trie\n  self.genTxTrie.bind(self)], function (err) {\n    if (err) {\n      errors.push(err);\n    }\n    if (!self.validateTransactionsTrie()) {\n      errors.push('invalid transaction trie');\n    }\n    var txErrors = self.validateTransactions(true);\n    if (txErrors !== '') {\n      errors.push(txErrors);\n    }\n    if (!self.validateUnclesHash()) {\n      errors.push('invalid uncle hash');\n    }\n    cb(arrayToString(errors));\n  });\n};\n\n/**\n * Validates the uncle's hash\n * @method validateUncleHash\n * @return {Boolean}\n */\nBlock.prototype.validateUnclesHash = function () {\n  var raw = [];\n  this.uncleHeaders.forEach(function (uncle) {\n    raw.push(uncle.raw);\n  });\n  raw = rlp.encode(raw);\n  return ethUtil.sha3(raw).toString('hex') === this.header.uncleHash.toString('hex');\n};\n\n/**\n * Validates the uncles that are in the block if any. Returns a string to the callback if uncles are invalid\n * @method validateUncles\n * @param {Blockchain} blockChaina an instance of the Blockchain\n * @param {Function} cb the callback\n */\nBlock.prototype.validateUncles = function (blockChain, cb) {\n  if (this.isGenesis()) {\n    return cb();\n  }\n  var self = this;\n  if (self.uncleHeaders.length > 2) {\n    return cb('too many uncle headers');\n  }\n  var uncleHashes = self.uncleHeaders.map(function (header) {\n    return header.hash().toString('hex');\n  });\n  if (!(new Set(uncleHashes).size === uncleHashes.length)) {\n    return cb('duplicate uncles');\n  }\n  async.each(self.uncleHeaders, function (uncle, cb2) {\n    var height = new BN(self.header.number);\n    async.parallel([uncle.validate.bind(uncle, blockChain, height),\n    // check to make sure the uncle is not already in the blockchain\n    function (cb3) {\n      blockChain.getDetails(uncle.hash(), function (err, blockInfo) {\n        // TODO: remove uncles from BC\n        if (blockInfo && blockInfo.isUncle) {\n          cb3(err || 'uncle already included');\n        } else {\n          cb3();\n        }\n      });\n    }], cb2);\n  }, cb);\n};\n\n/**\n * Converts the block toJSON\n * @method toJSON\n * @param {Bool} labeled whether to create an labeled object or an array\n * @return {Object}\n */\nBlock.prototype.toJSON = function (labeled) {\n  if (labeled) {\n    var obj = {\n      header: this.header.toJSON(true),\n      transactions: [],\n      uncleHeaders: []\n    };\n    this.transactions.forEach(function (tx) {\n      obj.transactions.push(tx.toJSON(labeled));\n    });\n    this.uncleHeaders.forEach(function (uh) {\n      obj.uncleHeaders.push(uh.toJSON());\n    });\n    return obj;\n  } else {\n    return ethUtil.baToJSON(this.raw);\n  }\n};\nfunction arrayToString(array) {\n  try {\n    return array.reduce(function (str, err) {\n      if (str) {\n        str += ' ';\n      }\n      return str + err;\n    });\n  } catch (e) {\n    return '';\n  }\n}","map":null,"metadata":{},"sourceType":"script"}