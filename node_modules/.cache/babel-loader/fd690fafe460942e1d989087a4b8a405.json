{"ast":null,"code":"/* Copyright (c) 2017 Rod Vagg, MIT License */\n\nvar xtend = require('xtend'),\n  AbstractIterator = require('./abstract-iterator'),\n  AbstractChainedBatch = require('./abstract-chained-batch');\nfunction AbstractLevelDOWN(location) {\n  if (!arguments.length || location === undefined) throw new Error('constructor requires at least a location argument');\n  if (typeof location != 'string') throw new Error('constructor requires a location string argument');\n  this.location = location;\n  this.status = 'new';\n}\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  var self = this,\n    oldStatus = this.status;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('open() requires a callback argument');\n  if (typeof options != 'object') options = {};\n  options.createIfMissing = options.createIfMissing != false;\n  options.errorIfExists = !!options.errorIfExists;\n  if (typeof this._open == 'function') {\n    this.status = 'opening';\n    this._open(options, function (err) {\n      if (err) {\n        self.status = oldStatus;\n        return callback(err);\n      }\n      self.status = 'open';\n      callback();\n    });\n  } else {\n    this.status = 'open';\n    process.nextTick(callback);\n  }\n};\nAbstractLevelDOWN.prototype.close = function (callback) {\n  var self = this,\n    oldStatus = this.status;\n  if (typeof callback != 'function') throw new Error('close() requires a callback argument');\n  if (typeof this._close == 'function') {\n    this.status = 'closing';\n    this._close(function (err) {\n      if (err) {\n        self.status = oldStatus;\n        return callback(err);\n      }\n      self.status = 'closed';\n      callback();\n    });\n  } else {\n    this.status = 'closed';\n    process.nextTick(callback);\n  }\n};\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('get() requires a callback argument');\n  if (err = this._checkKey(key, 'key')) return callback(err);\n  key = this._serializeKey(key);\n  if (typeof options != 'object') options = {};\n  options.asBuffer = options.asBuffer != false;\n  if (typeof this._get == 'function') return this._get(key, options, callback);\n  process.nextTick(function () {\n    callback(new Error('NotFound'));\n  });\n};\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('put() requires a callback argument');\n  if (err = this._checkKey(key, 'key')) return callback(err);\n  key = this._serializeKey(key);\n  value = this._serializeValue(value);\n  if (typeof options != 'object') options = {};\n  if (typeof this._put == 'function') return this._put(key, value, options, callback);\n  process.nextTick(callback);\n};\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('del() requires a callback argument');\n  if (err = this._checkKey(key, 'key')) return callback(err);\n  key = this._serializeKey(key);\n  if (typeof options != 'object') options = {};\n  if (typeof this._del == 'function') return this._del(key, options, callback);\n  process.nextTick(callback);\n};\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) return this._chainedBatch();\n  if (typeof options == 'function') callback = options;\n  if (typeof array == 'function') callback = array;\n  if (typeof callback != 'function') throw new Error('batch(array) requires a callback argument');\n  if (!Array.isArray(array)) return callback(new Error('batch(array) requires an array argument'));\n  if (!options || typeof options != 'object') options = {};\n  var i = 0,\n    l = array.length,\n    e,\n    err;\n  for (; i < l; i++) {\n    e = array[i];\n    if (typeof e != 'object') continue;\n    if (err = this._checkKey(e.type, 'type')) return callback(err);\n    if (err = this._checkKey(e.key, 'key')) return callback(err);\n  }\n  if (typeof this._batch == 'function') return this._batch(array, options, callback);\n  process.nextTick(callback);\n};\n\n//TODO: remove from here, not a necessary primitive\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (start == null || end == null || typeof start == 'function' || typeof end == 'function') {\n    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments');\n  }\n  if (typeof callback != 'function') throw new Error('approximateSize() requires a callback argument');\n  start = this._serializeKey(start);\n  end = this._serializeKey(end);\n  if (typeof this._approximateSize == 'function') return this._approximateSize(start, end, callback);\n  process.nextTick(function () {\n    callback(null, 0);\n  });\n};\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  var self = this;\n  options = xtend(options);\n  ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function (o) {\n    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0) delete options[o];\n  });\n  options.reverse = !!options.reverse;\n  options.keys = options.keys != false;\n  options.values = options.values != false;\n  options.limit = 'limit' in options ? options.limit : -1;\n  options.keyAsBuffer = options.keyAsBuffer != false;\n  options.valueAsBuffer = options.valueAsBuffer != false;\n  return options;\n};\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != 'object') options = {};\n  options = this._setupIteratorOptions(options);\n  if (typeof this._iterator == 'function') return this._iterator(options);\n  return new AbstractIterator(this);\n};\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this);\n};\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj);\n};\nAbstractLevelDOWN.prototype._serializeKey = function (key) {\n  return this._isBuffer(key) ? key : String(key);\n};\nAbstractLevelDOWN.prototype._serializeValue = function (value) {\n  if (value == null) return '';\n  return this._isBuffer(value) || process.browser ? value : String(value);\n};\nAbstractLevelDOWN.prototype._checkKey = function (obj, type) {\n  if (obj === null || obj === undefined) return new Error(type + ' cannot be `null` or `undefined`');\n  if (this._isBuffer(obj) && obj.length === 0) return new Error(type + ' cannot be an empty Buffer');else if (String(obj) === '') return new Error(type + ' cannot be an empty String');\n};\nmodule.exports = AbstractLevelDOWN;","map":null,"metadata":{},"sourceType":"script"}