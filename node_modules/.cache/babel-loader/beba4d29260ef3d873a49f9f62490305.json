{"ast":null,"code":"var levelup = require('levelup');\nvar memdown = require('memdown');\nvar async = require('async');\nvar inherits = require('util').inherits;\nvar Readable = require('readable-stream').Readable;\nvar levelws = require('level-ws');\nvar callTogether = require('./util').callTogether;\nmodule.exports = checkpointInterface;\nfunction checkpointInterface(trie) {\n  this._scratch = null;\n  trie._checkpoints = [];\n  Object.defineProperty(trie, 'isCheckpoint', {\n    get: function get() {\n      return !!trie._checkpoints.length;\n    }\n  });\n\n  // new methods\n  trie.checkpoint = checkpoint;\n  trie.commit = commit;\n  trie.revert = revert;\n  trie._enterCpMode = _enterCpMode;\n  trie._exitCpMode = _exitCpMode;\n  trie.createScratchReadStream = createScratchReadStream;\n\n  // overwrites\n  trie.copy = copy.bind(trie, trie.copy.bind(trie));\n}\n\n/**\n * Creates a checkpoint that can later be reverted to or committed. After this is called, no changes to the trie will be permanently saved until `commit` is called\n * @method checkpoint\n */\nfunction checkpoint() {\n  var self = this;\n  var wasCheckpoint = self.isCheckpoint;\n  self._checkpoints.push(self.root);\n  if (!wasCheckpoint && self.isCheckpoint) {\n    self._enterCpMode();\n  }\n}\n\n/**\n * commits a checkpoint to disk\n * @method commit\n * @param {Function} cb the callback\n */\nfunction commit(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self._checkpoints.pop();\n      if (!self.isCheckpoint) {\n        self._exitCpMode(true, cb);\n      } else {\n        cb();\n      }\n    } else {\n      throw new Error('trying to commit when not checkpointed');\n    }\n  });\n}\n\n/**\n * Reverts the trie to the state it was at when `checkpoint` was first called.\n * @method revert\n * @param {Function} cb the callback\n */\nfunction revert(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self.root = self._checkpoints.pop();\n      if (!self.isCheckpoint) {\n        self._exitCpMode(false, cb);\n        return;\n      }\n    }\n    cb();\n  });\n}\n\n// enter into checkpoint mode\nfunction _enterCpMode() {\n  this._scratch = levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this._scratch].concat(this._getDBs);\n  this.__putDBs = this._putDBs;\n  this._putDBs = [this._scratch];\n  this._putRaw = this.putRaw;\n  this.putRaw = putRaw;\n}\n\n// exit from checkpoint mode\nfunction _exitCpMode(commitState, cb) {\n  var self = this;\n  var scratch = this._scratch;\n  this._scratch = null;\n  this._getDBs = this._getDBs.slice(1);\n  this._putDBs = this.__putDBs;\n  this.putRaw = this._putRaw;\n  function flushScratch(db, cb) {\n    if (!db.createWriteStream) {\n      db = levelws(db);\n    }\n    self.createScratchReadStream(scratch).pipe(db.createWriteStream()).on('close', cb);\n  }\n  if (commitState) {\n    async.map(this._putDBs, flushScratch, cb);\n  } else {\n    cb();\n  }\n}\n\n// adds the interface when copying the trie\nfunction copy(_super) {\n  var trie = _super();\n  checkpointInterface.call(trie, trie);\n  trie._scratch = this._scratch;\n  // trie._checkpoints = this._checkpoints.slice()\n  return trie;\n}\nfunction putRaw(key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n  async.each(this.__putDBs, dbPut, cb);\n}\nfunction createScratchReadStream(scratch) {\n  var trie = this.copy();\n  scratch = scratch || this._scratch;\n  // only read from the scratch\n  trie._getDBs = [scratch];\n  trie._scratch = scratch;\n  return new ScratchReadStream(trie);\n}\n\n// ScratchReadStream\n// this is used to minimally dump the scratch into the db\n\ninherits(ScratchReadStream, Readable);\nfunction ScratchReadStream(trie) {\n  this.trie = trie;\n  this.next = null;\n  Readable.call(this, {\n    objectMode: true\n  });\n}\nScratchReadStream.prototype._read = function () {\n  var self = this;\n  if (!self._started) {\n    self._started = true;\n    self.trie._findDbNodes(function (nodeRef, node, key, next) {\n      self.push({\n        key: nodeRef,\n        value: node.serialize()\n      });\n      next();\n    }, function () {\n      // close stream\n      self.push(null);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}