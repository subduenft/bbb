{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar utils = require(\"ethereumjs-util\");\nvar exceptions_1 = require(\"../exceptions\");\nvar MASK_160 = new BN(1).shln(160).subn(1);\n// Find Ceil(`this` / `num`)\nfunction divCeil(a, b) {\n  var div = a.div(b);\n  var mod = a.mod(b);\n  // Fast case - exact division\n  if (mod.isZero()) return div;\n  // Round up\n  return div.isNeg() ? div.isubn(1) : div.iaddn(1);\n}\nfunction addressToBuffer(address) {\n  return address.and(MASK_160).toArrayLike(Buffer, 'be', 20);\n}\n// the opcode functions\nexports.handlers = {\n  STOP: function STOP(runState) {\n    trap(exceptions_1.ERROR.STOP);\n  },\n  ADD: function ADD(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.add(b).mod(utils.TWO_POW256);\n    runState.stack.push(r);\n  },\n  MUL: function MUL(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.mul(b).mod(utils.TWO_POW256);\n    runState.stack.push(r);\n  },\n  SUB: function SUB(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.sub(b).toTwos(256);\n    runState.stack.push(r);\n  },\n  DIV: function DIV(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r;\n    if (b.isZero()) {\n      r = new BN(b);\n    } else {\n      r = a.div(b);\n    }\n    runState.stack.push(r);\n  },\n  SDIV: function SDIV(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r;\n    if (b.isZero()) {\n      r = new BN(b);\n    } else {\n      a = a.fromTwos(256);\n      b = b.fromTwos(256);\n      r = a.div(b).toTwos(256);\n    }\n    runState.stack.push(r);\n  },\n  MOD: function MOD(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r;\n    if (b.isZero()) {\n      r = new BN(b);\n    } else {\n      r = a.mod(b);\n    }\n    runState.stack.push(r);\n  },\n  SMOD: function SMOD(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r;\n    if (b.isZero()) {\n      r = new BN(b);\n    } else {\n      a = a.fromTwos(256);\n      b = b.fromTwos(256);\n      r = a.abs().mod(b.abs());\n      if (a.isNeg()) {\n        r = r.ineg();\n      }\n      r = r.toTwos(256);\n    }\n    runState.stack.push(r);\n  },\n  ADDMOD: function ADDMOD(runState) {\n    var _a = runState.stack.popN(3),\n      a = _a[0],\n      b = _a[1],\n      c = _a[2];\n    var r;\n    if (c.isZero()) {\n      r = new BN(c);\n    } else {\n      r = a.add(b).mod(c);\n    }\n    runState.stack.push(r);\n  },\n  MULMOD: function MULMOD(runState) {\n    var _a = runState.stack.popN(3),\n      a = _a[0],\n      b = _a[1],\n      c = _a[2];\n    var r;\n    if (c.isZero()) {\n      r = new BN(c);\n    } else {\n      r = a.mul(b).mod(c);\n    }\n    runState.stack.push(r);\n  },\n  EXP: function EXP(runState) {\n    var _a = runState.stack.popN(2),\n      base = _a[0],\n      exponent = _a[1];\n    if (exponent.isZero()) {\n      runState.stack.push(new BN(1));\n      return;\n    }\n    var byteLength = exponent.byteLength();\n    if (byteLength < 1 || byteLength > 32) {\n      trap(exceptions_1.ERROR.OUT_OF_RANGE);\n    }\n    var gasPrice = runState._common.param('gasPrices', 'expByte');\n    var amount = new BN(byteLength).muln(gasPrice);\n    runState.eei.useGas(amount);\n    if (base.isZero()) {\n      runState.stack.push(new BN(0));\n      return;\n    }\n    var m = BN.red(utils.TWO_POW256);\n    var redBase = base.toRed(m);\n    var r = redBase.redPow(exponent);\n    runState.stack.push(r.fromRed());\n  },\n  SIGNEXTEND: function SIGNEXTEND(runState) {\n    var _a = runState.stack.popN(2),\n      k = _a[0],\n      val = _a[1];\n    if (k.ltn(31)) {\n      var signBit = k.muln(8).iaddn(7).toNumber();\n      var mask = new BN(1).ishln(signBit).isubn(1);\n      if (val.testn(signBit)) {\n        val = val.or(mask.notn(256));\n      } else {\n        val = val.and(mask);\n      }\n    } else {\n      // return the same value\n      val = new BN(val);\n    }\n    runState.stack.push(val);\n  },\n  // 0x10 range - bit ops\n  LT: function LT(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = new BN(a.lt(b) ? 1 : 0);\n    runState.stack.push(r);\n  },\n  GT: function GT(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = new BN(a.gt(b) ? 1 : 0);\n    runState.stack.push(r);\n  },\n  SLT: function SLT(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = new BN(a.fromTwos(256).lt(b.fromTwos(256)) ? 1 : 0);\n    runState.stack.push(r);\n  },\n  SGT: function SGT(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = new BN(a.fromTwos(256).gt(b.fromTwos(256)) ? 1 : 0);\n    runState.stack.push(r);\n  },\n  EQ: function EQ(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = new BN(a.eq(b) ? 1 : 0);\n    runState.stack.push(r);\n  },\n  ISZERO: function ISZERO(runState) {\n    var a = runState.stack.pop();\n    var r = new BN(a.isZero() ? 1 : 0);\n    runState.stack.push(r);\n  },\n  AND: function AND(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.and(b);\n    runState.stack.push(r);\n  },\n  OR: function OR(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.or(b);\n    runState.stack.push(r);\n  },\n  XOR: function XOR(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    var r = a.xor(b);\n    runState.stack.push(r);\n  },\n  NOT: function NOT(runState) {\n    var a = runState.stack.pop();\n    var r = a.notn(256);\n    runState.stack.push(r);\n  },\n  BYTE: function BYTE(runState) {\n    var _a = runState.stack.popN(2),\n      pos = _a[0],\n      word = _a[1];\n    if (pos.gten(32)) {\n      runState.stack.push(new BN(0));\n      return;\n    }\n    var r = new BN(word.shrn((31 - pos.toNumber()) * 8).andln(0xff));\n    runState.stack.push(r);\n  },\n  SHL: function SHL(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    if (!runState._common.gteHardfork('constantinople')) {\n      trap(exceptions_1.ERROR.INVALID_OPCODE);\n    }\n    if (a.gten(256)) {\n      runState.stack.push(new BN(0));\n      return;\n    }\n    var r = b.shln(a.toNumber()).iand(utils.MAX_INTEGER);\n    runState.stack.push(r);\n  },\n  SHR: function SHR(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    if (!runState._common.gteHardfork('constantinople')) {\n      trap(exceptions_1.ERROR.INVALID_OPCODE);\n    }\n    if (a.gten(256)) {\n      runState.stack.push(new BN(0));\n      return;\n    }\n    var r = b.shrn(a.toNumber());\n    runState.stack.push(r);\n  },\n  SAR: function SAR(runState) {\n    var _a = runState.stack.popN(2),\n      a = _a[0],\n      b = _a[1];\n    if (!runState._common.gteHardfork('constantinople')) {\n      trap(exceptions_1.ERROR.INVALID_OPCODE);\n    }\n    var r;\n    var isSigned = b.testn(255);\n    if (a.gten(256)) {\n      if (isSigned) {\n        r = new BN(utils.MAX_INTEGER);\n      } else {\n        r = new BN(0);\n      }\n      runState.stack.push(r);\n      return;\n    }\n    var c = b.shrn(a.toNumber());\n    if (isSigned) {\n      var shiftedOutWidth = 255 - a.toNumber();\n      var mask = utils.MAX_INTEGER.shrn(shiftedOutWidth).shln(shiftedOutWidth);\n      r = c.ior(mask);\n    } else {\n      r = c;\n    }\n    runState.stack.push(r);\n  },\n  // 0x20 range - crypto\n  SHA3: function SHA3(runState) {\n    var _a = runState.stack.popN(2),\n      offset = _a[0],\n      length = _a[1];\n    subMemUsage(runState, offset, length);\n    var data = Buffer.alloc(0);\n    if (!length.isZero()) {\n      data = runState.memory.read(offset.toNumber(), length.toNumber());\n    }\n    // copy fee\n    runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sha3Word')).imul(divCeil(length, new BN(32))));\n    var r = new BN(utils.keccak256(data));\n    runState.stack.push(r);\n  },\n  // 0x30 range - closure state\n  ADDRESS: function ADDRESS(runState) {\n    runState.stack.push(new BN(runState.eei.getAddress()));\n  },\n  BALANCE: function BALANCE(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var address, addressBuf, balance;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = runState.stack.pop();\n            addressBuf = addressToBuffer(address);\n            return [4 /*yield*/, runState.eei.getExternalBalance(addressBuf)];\n          case 1:\n            balance = _a.sent();\n            runState.stack.push(balance);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  ORIGIN: function ORIGIN(runState) {\n    runState.stack.push(runState.eei.getTxOrigin());\n  },\n  CALLER: function CALLER(runState) {\n    runState.stack.push(runState.eei.getCaller());\n  },\n  CALLVALUE: function CALLVALUE(runState) {\n    runState.stack.push(runState.eei.getCallValue());\n  },\n  CALLDATALOAD: function CALLDATALOAD(runState) {\n    var pos = runState.stack.pop();\n    if (pos.gt(runState.eei.getCallDataSize())) {\n      runState.stack.push(new BN(0));\n      return;\n    }\n    var i = pos.toNumber();\n    var loaded = runState.eei.getCallData().slice(i, i + 32);\n    loaded = loaded.length ? loaded : Buffer.from([0]);\n    var r = new BN(utils.setLengthRight(loaded, 32));\n    runState.stack.push(r);\n  },\n  CALLDATASIZE: function CALLDATASIZE(runState) {\n    var r = runState.eei.getCallDataSize();\n    runState.stack.push(r);\n  },\n  CALLDATACOPY: function CALLDATACOPY(runState) {\n    var _a = runState.stack.popN(3),\n      memOffset = _a[0],\n      dataOffset = _a[1],\n      dataLength = _a[2];\n    subMemUsage(runState, memOffset, dataLength);\n    runState.eei.useGas(new BN(runState._common.param('gasPrices', 'copy')).imul(divCeil(dataLength, new BN(32))));\n    var data = getDataSlice(runState.eei.getCallData(), dataOffset, dataLength);\n    var memOffsetNum = memOffset.toNumber();\n    var dataLengthNum = dataLength.toNumber();\n    runState.memory.extend(memOffsetNum, dataLengthNum);\n    runState.memory.write(memOffsetNum, dataLengthNum, data);\n  },\n  CODESIZE: function CODESIZE(runState) {\n    runState.stack.push(runState.eei.getCodeSize());\n  },\n  CODECOPY: function CODECOPY(runState) {\n    var _a = runState.stack.popN(3),\n      memOffset = _a[0],\n      codeOffset = _a[1],\n      length = _a[2];\n    subMemUsage(runState, memOffset, length);\n    runState.eei.useGas(new BN(runState._common.param('gasPrices', 'copy')).imul(divCeil(length, new BN(32))));\n    var data = getDataSlice(runState.eei.getCode(), codeOffset, length);\n    var memOffsetNum = memOffset.toNumber();\n    var lengthNum = length.toNumber();\n    runState.memory.extend(memOffsetNum, lengthNum);\n    runState.memory.write(memOffsetNum, lengthNum, data);\n  },\n  EXTCODESIZE: function EXTCODESIZE(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var address, size;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = runState.stack.pop();\n            return [4 /*yield*/, runState.eei.getExternalCodeSize(address)];\n          case 1:\n            size = _a.sent();\n            runState.stack.push(size);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  EXTCODECOPY: function EXTCODECOPY(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, address, memOffset, codeOffset, length, code, data, memOffsetNum, lengthNum;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = runState.stack.popN(4), address = _a[0], memOffset = _a[1], codeOffset = _a[2], length = _a[3];\n            // FIXME: for some reason this must come before subGas\n            subMemUsage(runState, memOffset, length);\n            // copy fee\n            runState.eei.useGas(new BN(runState._common.param('gasPrices', 'copy')).imul(divCeil(length, new BN(32))));\n            return [4 /*yield*/, runState.eei.getExternalCode(address)];\n          case 1:\n            code = _b.sent();\n            data = getDataSlice(code, codeOffset, length);\n            memOffsetNum = memOffset.toNumber();\n            lengthNum = length.toNumber();\n            runState.memory.extend(memOffsetNum, lengthNum);\n            runState.memory.write(memOffsetNum, lengthNum, data);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  EXTCODEHASH: function EXTCODEHASH(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var address, addressBuf, empty, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            address = runState.stack.pop();\n            if (!runState._common.gteHardfork('constantinople')) {\n              trap(exceptions_1.ERROR.INVALID_OPCODE);\n            }\n            addressBuf = addressToBuffer(address);\n            return [4 /*yield*/, runState.eei.isAccountEmpty(addressBuf)];\n          case 1:\n            empty = _a.sent();\n            if (empty) {\n              runState.stack.push(new BN(0));\n              return [2 /*return*/];\n            }\n\n            return [4 /*yield*/, runState.eei.getExternalCode(address)];\n          case 2:\n            code = _a.sent();\n            if (code.length === 0) {\n              runState.stack.push(new BN(utils.KECCAK256_NULL));\n              return [2 /*return*/];\n            }\n\n            runState.stack.push(new BN(utils.keccak256(code)));\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  RETURNDATASIZE: function RETURNDATASIZE(runState) {\n    runState.stack.push(runState.eei.getReturnDataSize());\n  },\n  RETURNDATACOPY: function RETURNDATACOPY(runState) {\n    var _a = runState.stack.popN(3),\n      memOffset = _a[0],\n      returnDataOffset = _a[1],\n      length = _a[2];\n    if (returnDataOffset.add(length).gt(runState.eei.getReturnDataSize())) {\n      trap(exceptions_1.ERROR.OUT_OF_GAS);\n    }\n    subMemUsage(runState, memOffset, length);\n    runState.eei.useGas(new BN(runState._common.param('gasPrices', 'copy')).mul(divCeil(length, new BN(32))));\n    var data = getDataSlice(runState.eei.getReturnData(), returnDataOffset, length);\n    var memOffsetNum = memOffset.toNumber();\n    var lengthNum = length.toNumber();\n    runState.memory.extend(memOffsetNum, lengthNum);\n    runState.memory.write(memOffsetNum, lengthNum, data);\n  },\n  GASPRICE: function GASPRICE(runState) {\n    runState.stack.push(runState.eei.getTxGasPrice());\n  },\n  // '0x40' range - block operations\n  BLOCKHASH: function BLOCKHASH(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var number, diff, hash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            number = runState.stack.pop();\n            diff = runState.eei.getBlockNumber().sub(number);\n            // block lookups must be within the past 256 blocks\n            if (diff.gtn(256) || diff.lten(0)) {\n              runState.stack.push(new BN(0));\n              return [2 /*return*/];\n            }\n\n            return [4 /*yield*/, runState.eei.getBlockHash(number)];\n          case 1:\n            hash = _a.sent();\n            runState.stack.push(hash);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  COINBASE: function COINBASE(runState) {\n    runState.stack.push(runState.eei.getBlockCoinbase());\n  },\n  TIMESTAMP: function TIMESTAMP(runState) {\n    runState.stack.push(runState.eei.getBlockTimestamp());\n  },\n  NUMBER: function NUMBER(runState) {\n    runState.stack.push(runState.eei.getBlockNumber());\n  },\n  DIFFICULTY: function DIFFICULTY(runState) {\n    runState.stack.push(runState.eei.getBlockDifficulty());\n  },\n  GASLIMIT: function GASLIMIT(runState) {\n    runState.stack.push(runState.eei.getBlockGasLimit());\n  },\n  CHAINID: function CHAINID(runState) {\n    if (!runState._common.gteHardfork('istanbul')) {\n      trap(exceptions_1.ERROR.INVALID_OPCODE);\n    }\n    runState.stack.push(runState.eei.getChainId());\n  },\n  SELFBALANCE: function SELFBALANCE(runState) {\n    if (!runState._common.gteHardfork('istanbul')) {\n      trap(exceptions_1.ERROR.INVALID_OPCODE);\n    }\n    runState.stack.push(runState.eei.getSelfBalance());\n  },\n  // 0x50 range - 'storage' and execution\n  POP: function POP(runState) {\n    runState.stack.pop();\n  },\n  MLOAD: function MLOAD(runState) {\n    var pos = runState.stack.pop();\n    subMemUsage(runState, pos, new BN(32));\n    var word = runState.memory.read(pos.toNumber(), 32);\n    runState.stack.push(new BN(word));\n  },\n  MSTORE: function MSTORE(runState) {\n    var _a = runState.stack.popN(2),\n      offset = _a[0],\n      word = _a[1];\n    var buf = word.toArrayLike(Buffer, 'be', 32);\n    subMemUsage(runState, offset, new BN(32));\n    var offsetNum = offset.toNumber();\n    runState.memory.extend(offsetNum, 32);\n    runState.memory.write(offsetNum, 32, buf);\n  },\n  MSTORE8: function MSTORE8(runState) {\n    var _a = runState.stack.popN(2),\n      offset = _a[0],\n      byte = _a[1];\n    // NOTE: we're using a 'trick' here to get the least significant byte\n    // NOTE: force cast necessary because `BN.andln` returns number but\n    // the types are wrong\n    var buf = Buffer.from([byte.andln(0xff)]);\n    subMemUsage(runState, offset, new BN(1));\n    var offsetNum = offset.toNumber();\n    runState.memory.extend(offsetNum, 1);\n    runState.memory.write(offsetNum, 1, buf);\n  },\n  SLOAD: function SLOAD(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, keyBuf, value, valueBN;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = runState.stack.pop();\n            keyBuf = key.toArrayLike(Buffer, 'be', 32);\n            return [4 /*yield*/, runState.eei.storageLoad(keyBuf)];\n          case 1:\n            value = _a.sent();\n            valueBN = value.length ? new BN(value) : new BN(0);\n            runState.stack.push(valueBN);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  SSTORE: function SSTORE(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, key, val, keyBuf, value, found;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (runState.eei.isStatic()) {\n              trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n            }\n            _a = runState.stack.popN(2), key = _a[0], val = _a[1];\n            keyBuf = key.toArrayLike(Buffer, 'be', 32);\n            if (val.isZero()) {\n              value = Buffer.from([]);\n            } else {\n              value = val.toArrayLike(Buffer, 'be');\n            }\n            return [4 /*yield*/, getContractStorage(runState, runState.eei.getAddress(), keyBuf)];\n          case 1:\n            found = _b.sent();\n            updateSstoreGas(runState, found, value);\n            return [4 /*yield*/, runState.eei.storageStore(keyBuf, value)];\n          case 2:\n            _b.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  JUMP: function JUMP(runState) {\n    var dest = runState.stack.pop();\n    if (dest.gt(runState.eei.getCodeSize())) {\n      trap(exceptions_1.ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n    }\n    var destNum = dest.toNumber();\n    if (!jumpIsValid(runState, destNum)) {\n      trap(exceptions_1.ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n    }\n    runState.programCounter = destNum;\n  },\n  JUMPI: function JUMPI(runState) {\n    var _a = runState.stack.popN(2),\n      dest = _a[0],\n      cond = _a[1];\n    if (!cond.isZero()) {\n      if (dest.gt(runState.eei.getCodeSize())) {\n        trap(exceptions_1.ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n      }\n      var destNum = dest.toNumber();\n      if (!jumpIsValid(runState, destNum)) {\n        trap(exceptions_1.ERROR.INVALID_JUMP + ' at ' + describeLocation(runState));\n      }\n      runState.programCounter = destNum;\n    }\n  },\n  PC: function PC(runState) {\n    runState.stack.push(new BN(runState.programCounter - 1));\n  },\n  MSIZE: function MSIZE(runState) {\n    runState.stack.push(runState.memoryWordCount.muln(32));\n  },\n  GAS: function GAS(runState) {\n    runState.stack.push(new BN(runState.eei.getGasLeft()));\n  },\n  JUMPDEST: function JUMPDEST(runState) {},\n  PUSH: function PUSH(runState) {\n    var numToPush = runState.opCode - 0x5f;\n    var loaded = new BN(runState.eei.getCode().slice(runState.programCounter, runState.programCounter + numToPush).toString('hex'), 16);\n    runState.programCounter += numToPush;\n    runState.stack.push(loaded);\n  },\n  DUP: function DUP(runState) {\n    var stackPos = runState.opCode - 0x7f;\n    runState.stack.dup(stackPos);\n  },\n  SWAP: function SWAP(runState) {\n    var stackPos = runState.opCode - 0x8f;\n    runState.stack.swap(stackPos);\n  },\n  LOG: function LOG(runState) {\n    if (runState.eei.isStatic()) {\n      trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n    }\n    var _a = runState.stack.popN(2),\n      memOffset = _a[0],\n      memLength = _a[1];\n    var topicsCount = runState.opCode - 0xa0;\n    if (topicsCount < 0 || topicsCount > 4) {\n      trap(exceptions_1.ERROR.OUT_OF_RANGE);\n    }\n    var topics = runState.stack.popN(topicsCount);\n    var topicsBuf = topics.map(function (a) {\n      return a.toArrayLike(Buffer, 'be', 32);\n    });\n    subMemUsage(runState, memOffset, memLength);\n    var mem = Buffer.alloc(0);\n    if (!memLength.isZero()) {\n      mem = runState.memory.read(memOffset.toNumber(), memLength.toNumber());\n    }\n    runState.eei.useGas(new BN(runState._common.param('gasPrices', 'logTopic')).imuln(topicsCount).iadd(memLength.muln(runState._common.param('gasPrices', 'logData'))));\n    runState.eei.log(mem, topicsCount, topicsBuf);\n  },\n  // '0xf0' range - closures\n  CREATE: function CREATE(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, value, offset, length, gasLimit, data, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (runState.eei.isStatic()) {\n              trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n            }\n            _a = runState.stack.popN(3), value = _a[0], offset = _a[1], length = _a[2];\n            subMemUsage(runState, offset, length);\n            gasLimit = new BN(runState.eei.getGasLeft());\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            data = Buffer.alloc(0);\n            if (!length.isZero()) {\n              data = runState.memory.read(offset.toNumber(), length.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.create(gasLimit, value, data)];\n          case 1:\n            ret = _b.sent();\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  CREATE2: function CREATE2(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, value, offset, length, salt, gasLimit, data, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!runState._common.gteHardfork('constantinople')) {\n              trap(exceptions_1.ERROR.INVALID_OPCODE);\n            }\n            if (runState.eei.isStatic()) {\n              trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n            }\n            _a = runState.stack.popN(4), value = _a[0], offset = _a[1], length = _a[2], salt = _a[3];\n            subMemUsage(runState, offset, length);\n            // Deduct gas costs for hashing\n            runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sha3Word')).imul(divCeil(length, new BN(32))));\n            gasLimit = new BN(runState.eei.getGasLeft());\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            data = Buffer.alloc(0);\n            if (!length.isZero()) {\n              data = runState.memory.read(offset.toNumber(), length.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.create2(gasLimit, value, data, salt.toArrayLike(Buffer, 'be', 32))];\n          case 1:\n            ret = _b.sent();\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  CALL: function CALL(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, gasLimit, toAddress, value, inOffset, inLength, outOffset, outLength, toAddressBuf, data, empty, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = runState.stack.popN(7), gasLimit = _a[0], toAddress = _a[1], value = _a[2], inOffset = _a[3], inLength = _a[4], outOffset = _a[5], outLength = _a[6];\n            toAddressBuf = addressToBuffer(toAddress);\n            if (runState.eei.isStatic() && !value.isZero()) {\n              trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n            }\n            subMemUsage(runState, inOffset, inLength);\n            subMemUsage(runState, outOffset, outLength);\n            if (!value.isZero()) {\n              runState.eei.useGas(new BN(runState._common.param('gasPrices', 'callValueTransfer')));\n            }\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            data = Buffer.alloc(0);\n            if (!inLength.isZero()) {\n              data = runState.memory.read(inOffset.toNumber(), inLength.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.isAccountEmpty(toAddressBuf)];\n          case 1:\n            empty = _b.sent();\n            if (empty) {\n              if (!value.isZero()) {\n                runState.eei.useGas(new BN(runState._common.param('gasPrices', 'callNewAccount')));\n              }\n            }\n            if (!value.isZero()) {\n              // TODO: Don't use private attr directly\n              runState.eei._gasLeft.iaddn(runState._common.param('gasPrices', 'callStipend'));\n              gasLimit.iaddn(runState._common.param('gasPrices', 'callStipend'));\n            }\n            return [4 /*yield*/, runState.eei.call(gasLimit, toAddressBuf, value, data)\n            // Write return data to memory\n            ];\n\n          case 2:\n            ret = _b.sent();\n            // Write return data to memory\n            writeCallOutput(runState, outOffset, outLength);\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  CALLCODE: function CALLCODE(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, gasLimit, toAddress, value, inOffset, inLength, outOffset, outLength, toAddressBuf, data, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = runState.stack.popN(7), gasLimit = _a[0], toAddress = _a[1], value = _a[2], inOffset = _a[3], inLength = _a[4], outOffset = _a[5], outLength = _a[6];\n            toAddressBuf = addressToBuffer(toAddress);\n            subMemUsage(runState, inOffset, inLength);\n            subMemUsage(runState, outOffset, outLength);\n            if (!value.isZero()) {\n              runState.eei.useGas(new BN(runState._common.param('gasPrices', 'callValueTransfer')));\n            }\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            if (!value.isZero()) {\n              // TODO: Don't use private attr directly\n              runState.eei._gasLeft.iaddn(runState._common.param('gasPrices', 'callStipend'));\n              gasLimit.iaddn(runState._common.param('gasPrices', 'callStipend'));\n            }\n            data = Buffer.alloc(0);\n            if (!inLength.isZero()) {\n              data = runState.memory.read(inOffset.toNumber(), inLength.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.callCode(gasLimit, toAddressBuf, value, data)\n            // Write return data to memory\n            ];\n\n          case 1:\n            ret = _b.sent();\n            // Write return data to memory\n            writeCallOutput(runState, outOffset, outLength);\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  DELEGATECALL: function DELEGATECALL(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var value, _a, gasLimit, toAddress, inOffset, inLength, outOffset, outLength, toAddressBuf, data, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            value = runState.eei.getCallValue();\n            _a = runState.stack.popN(6), gasLimit = _a[0], toAddress = _a[1], inOffset = _a[2], inLength = _a[3], outOffset = _a[4], outLength = _a[5];\n            toAddressBuf = addressToBuffer(toAddress);\n            subMemUsage(runState, inOffset, inLength);\n            subMemUsage(runState, outOffset, outLength);\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            data = Buffer.alloc(0);\n            if (!inLength.isZero()) {\n              data = runState.memory.read(inOffset.toNumber(), inLength.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.callDelegate(gasLimit, toAddressBuf, value, data)\n            // Write return data to memory\n            ];\n\n          case 1:\n            ret = _b.sent();\n            // Write return data to memory\n            writeCallOutput(runState, outOffset, outLength);\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  STATICCALL: function STATICCALL(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var value, _a, gasLimit, toAddress, inOffset, inLength, outOffset, outLength, toAddressBuf, data, ret;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            value = new BN(0);\n            _a = runState.stack.popN(6), gasLimit = _a[0], toAddress = _a[1], inOffset = _a[2], inLength = _a[3], outOffset = _a[4], outLength = _a[5];\n            toAddressBuf = addressToBuffer(toAddress);\n            subMemUsage(runState, inOffset, inLength);\n            subMemUsage(runState, outOffset, outLength);\n            gasLimit = maxCallGas(gasLimit, runState.eei.getGasLeft());\n            data = Buffer.alloc(0);\n            if (!inLength.isZero()) {\n              data = runState.memory.read(inOffset.toNumber(), inLength.toNumber());\n            }\n            return [4 /*yield*/, runState.eei.callStatic(gasLimit, toAddressBuf, value, data)\n            // Write return data to memory\n            ];\n\n          case 1:\n            ret = _b.sent();\n            // Write return data to memory\n            writeCallOutput(runState, outOffset, outLength);\n            runState.stack.push(ret);\n            return [2 /*return*/];\n        }\n      });\n    });\n  },\n\n  RETURN: function RETURN(runState) {\n    var _a = runState.stack.popN(2),\n      offset = _a[0],\n      length = _a[1];\n    subMemUsage(runState, offset, length);\n    var returnData = Buffer.alloc(0);\n    if (!length.isZero()) {\n      returnData = runState.memory.read(offset.toNumber(), length.toNumber());\n    }\n    runState.eei.finish(returnData);\n  },\n  REVERT: function REVERT(runState) {\n    var _a = runState.stack.popN(2),\n      offset = _a[0],\n      length = _a[1];\n    subMemUsage(runState, offset, length);\n    var returnData = Buffer.alloc(0);\n    if (!length.isZero()) {\n      returnData = runState.memory.read(offset.toNumber(), length.toNumber());\n    }\n    runState.eei.revert(returnData);\n  },\n  // '0x70', range - other\n  SELFDESTRUCT: function SELFDESTRUCT(runState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var selfdestructToAddress, selfdestructToAddressBuf, balance, empty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            selfdestructToAddress = runState.stack.pop();\n            if (runState.eei.isStatic()) {\n              trap(exceptions_1.ERROR.STATIC_STATE_CHANGE);\n            }\n            selfdestructToAddressBuf = addressToBuffer(selfdestructToAddress);\n            return [4 /*yield*/, runState.eei.getExternalBalance(runState.eei.getAddress())];\n          case 1:\n            balance = _a.sent();\n            if (!balance.gtn(0)) return [3 /*break*/, 3];\n            return [4 /*yield*/, runState.eei.isAccountEmpty(selfdestructToAddressBuf)];\n          case 2:\n            empty = _a.sent();\n            if (empty) {\n              runState.eei.useGas(new BN(runState._common.param('gasPrices', 'callNewAccount')));\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, runState.eei.selfDestruct(selfdestructToAddressBuf)];\n        }\n      });\n    });\n  }\n};\nfunction describeLocation(runState) {\n  var hash = utils.keccak256(runState.eei.getCode()).toString('hex');\n  var address = runState.eei.getAddress().toString('hex');\n  var pc = runState.programCounter - 1;\n  return hash + '/' + address + ':' + pc;\n}\nfunction trap(err) {\n  // TODO: facilitate extra data along with errors\n  throw new exceptions_1.VmError(err);\n}\n/**\n * Subtracts the amount needed for memory usage from `runState.gasLeft`\n * @method subMemUsage\n * @param {Object} runState\n * @param {BN} offset\n * @param {BN} length\n * @returns {String}\n */\nfunction subMemUsage(runState, offset, length) {\n  // YP (225): access with zero length will not extend the memory\n  if (length.isZero()) return;\n  var newMemoryWordCount = divCeil(offset.add(length), new BN(32));\n  if (newMemoryWordCount.lte(runState.memoryWordCount)) return;\n  var words = newMemoryWordCount;\n  var fee = new BN(runState._common.param('gasPrices', 'memory'));\n  var quadCoeff = new BN(runState._common.param('gasPrices', 'quadCoeffDiv'));\n  // words * 3 + words ^2 / 512\n  var cost = words.mul(fee).add(words.mul(words).div(quadCoeff));\n  if (cost.gt(runState.highestMemCost)) {\n    runState.eei.useGas(cost.sub(runState.highestMemCost));\n    runState.highestMemCost = cost;\n  }\n  runState.memoryWordCount = newMemoryWordCount;\n}\n/**\n * Returns an overflow-safe slice of an array. It right-pads\n * the data with zeros to `length`.\n * @param {BN} offset\n * @param {BN} length\n * @param {Buffer} data\n */\nfunction getDataSlice(data, offset, length) {\n  var len = new BN(data.length);\n  if (offset.gt(len)) {\n    offset = len;\n  }\n  var end = offset.add(length);\n  if (end.gt(len)) {\n    end = len;\n  }\n  data = data.slice(offset.toNumber(), end.toNumber());\n  // Right-pad with zeros to fill dataLength bytes\n  data = utils.setLengthRight(data, length.toNumber());\n  return data;\n}\n// checks if a jump is valid given a destination\nfunction jumpIsValid(runState, dest) {\n  return runState.validJumps.indexOf(dest) !== -1;\n}\nfunction maxCallGas(gasLimit, gasLeft) {\n  var gasAllowed = gasLeft.sub(gasLeft.divn(64));\n  return gasLimit.gt(gasAllowed) ? gasAllowed : gasLimit;\n}\nfunction getContractStorage(runState, address, key) {\n  return new Promise(function (resolve, reject) {\n    var cb = function cb(err, res) {\n      if (err) return reject(err);\n      resolve(res);\n    };\n    runState.stateManager.getContractStorage(address, key, function (err, current) {\n      if (err) return cb(err, null);\n      if (runState._common.hardfork() === 'constantinople' || runState._common.gteHardfork('istanbul')) {\n        runState.stateManager.getOriginalContractStorage(address, key, function (err, original) {\n          if (err) return cb(err, null);\n          cb(null, {\n            current: current,\n            original: original\n          });\n        });\n      } else {\n        cb(null, current);\n      }\n    });\n  });\n}\nfunction updateSstoreGas(runState, found, value) {\n  if (runState._common.hardfork() === 'constantinople') {\n    var original = found.original;\n    var current = found.current;\n    if (current.equals(value)) {\n      // If current value equals new value (this is a no-op), 200 gas is deducted.\n      runState.eei.useGas(new BN(runState._common.param('gasPrices', 'netSstoreNoopGas')));\n      return;\n    }\n    // If current value does not equal new value\n    if (original.equals(current)) {\n      // If original value equals current value (this storage slot has not been changed by the current execution context)\n      if (original.length === 0) {\n        // If original value is 0, 20000 gas is deducted.\n        return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'netSstoreInitGas')));\n      }\n      if (value.length === 0) {\n        // If new value is 0, add 15000 gas to refund counter.\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'netSstoreClearRefund')));\n      }\n      // Otherwise, 5000 gas is deducted.\n      return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'netSstoreCleanGas')));\n    }\n    // If original value does not equal current value (this storage slot is dirty), 200 gas is deducted. Apply both of the following clauses.\n    if (original.length !== 0) {\n      // If original value is not 0\n      if (current.length === 0) {\n        // If current value is 0 (also means that new value is not 0), remove 15000 gas from refund counter. We can prove that refund counter will never go below 0.\n        runState.eei.subRefund(new BN(runState._common.param('gasPrices', 'netSstoreClearRefund')));\n      } else if (value.length === 0) {\n        // If new value is 0 (also means that current value is not 0), add 15000 gas to refund counter.\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'netSstoreClearRefund')));\n      }\n    }\n    if (original.equals(value)) {\n      // If original value equals new value (this storage slot is reset)\n      if (original.length === 0) {\n        // If original value is 0, add 19800 gas to refund counter.\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'netSstoreResetClearRefund')));\n      } else {\n        // Otherwise, add 4800 gas to refund counter.\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'netSstoreResetRefund')));\n      }\n    }\n    return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'netSstoreDirtyGas')));\n  } else if (runState._common.gteHardfork('istanbul')) {\n    // EIP-2200\n    var original_1 = found.original;\n    var current_1 = found.current;\n    // Fail if not enough gas is left\n    if (runState.eei.getGasLeft().lten(runState._common.param('gasPrices', 'sstoreSentryGasEIP2200'))) {\n      trap(exceptions_1.ERROR.OUT_OF_GAS);\n    }\n    // Noop\n    if (current_1.equals(value)) {\n      return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreNoopGasEIP2200')));\n    }\n    if (original_1.equals(current_1)) {\n      // Create slot\n      if (original_1.length === 0) {\n        return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreInitGasEIP2200')));\n      }\n      // Delete slot\n      if (value.length === 0) {\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'sstoreClearRefundEIP2200')));\n      }\n      // Write existing slot\n      return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreCleanGasEIP2200')));\n    }\n    if (original_1.length > 0) {\n      if (current_1.length === 0) {\n        // Recreate slot\n        runState.eei.subRefund(new BN(runState._common.param('gasPrices', 'sstoreClearRefundEIP2200')));\n      } else if (value.length === 0) {\n        // Delete slot\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'sstoreClearRefundEIP2200')));\n      }\n    }\n    if (original_1.equals(value)) {\n      if (original_1.length === 0) {\n        // Reset to original non-existent slot\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'sstoreInitRefundEIP2200')));\n      } else {\n        // Reset to original existing slot\n        runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'sstoreCleanRefundEIP2200')));\n      }\n    }\n    // Dirty update\n    return runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreDirtyGasEIP2200')));\n  } else {\n    if (value.length === 0 && !found.length) {\n      runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreReset')));\n    } else if (value.length === 0 && found.length) {\n      runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreReset')));\n      runState.eei.refundGas(new BN(runState._common.param('gasPrices', 'sstoreRefund')));\n    } else if (value.length !== 0 && !found.length) {\n      runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreSet')));\n    } else if (value.length !== 0 && found.length) {\n      runState.eei.useGas(new BN(runState._common.param('gasPrices', 'sstoreReset')));\n    }\n  }\n}\nfunction writeCallOutput(runState, outOffset, outLength) {\n  var returnData = runState.eei.getReturnData();\n  if (returnData.length > 0) {\n    var memOffset = outOffset.toNumber();\n    var dataLength = outLength.toNumber();\n    if (returnData.length < dataLength) {\n      dataLength = returnData.length;\n    }\n    var data = getDataSlice(returnData, new BN(0), new BN(dataLength));\n    runState.memory.extend(memOffset, dataLength);\n    runState.memory.write(memOffset, dataLength, data);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}