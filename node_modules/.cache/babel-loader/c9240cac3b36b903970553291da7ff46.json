{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _slicedToArray from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport { BigNumber, ethers } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { getRandomInt, promisify } from '@0xsequence/utils';\nimport { sequenceContext, JsonRpcVersion } from '@0xsequence/network';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar JsonRpcMethod;\n(function (JsonRpcMethod) {\n  JsonRpcMethod[\"ethCall\"] = \"eth_call\";\n  JsonRpcMethod[\"ethGetBalance\"] = \"eth_getBalance\";\n  JsonRpcMethod[\"ethGetCode\"] = \"eth_getCode\";\n})(JsonRpcMethod || (JsonRpcMethod = {}));\nfunction safeSolve(_x, _x2) {\n  return _safeSolve.apply(this, arguments);\n}\nfunction _safeSolve() {\n  _safeSolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(promise, def) {\n    var d;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          _context10.prev = 0;\n          _context10.next = 3;\n          return promise;\n        case 3:\n          return _context10.abrupt(\"return\", _context10.sent);\n        case 6:\n          _context10.prev = 6;\n          _context10.t0 = _context10[\"catch\"](0);\n          d = def instanceof Function ? def(_context10.t0) : def;\n          return _context10.abrupt(\"return\", d);\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10, null, [[0, 6]]);\n  }));\n  return _safeSolve.apply(this, arguments);\n}\nfunction partition(array, callback) {\n  return array.reduce(function (result, element, i) {\n    callback(element, i) ? result[0].push(element) : result[1].push(element);\n    return result;\n  }, [[], []]);\n}\nfunction parseBlockTag(cand) {\n  if (cand === undefined) return 'latest';\n  switch (cand) {\n    case 'earliest':\n    case 'latest':\n    case 'pending':\n      return cand;\n  }\n  return BigNumber.from(cand);\n}\nfunction eqBlockTag(a, b) {\n  if (a === b) return true;\n  if (BigNumber.isBigNumber(a)) {\n    if (BigNumber.isBigNumber(b)) return a.eq(b);\n    return false;\n  }\n  if (BigNumber.isBigNumber(b)) return false;\n  return a === b;\n}\nvar DefaultMulticallOptions = {\n  batchSize: 50,\n  timeWindow: 50,\n  contract: sequenceContext.sequenceUtils,\n  verbose: false\n};\nvar Multicall = /*#__PURE__*/function () {\n  function Multicall(options) {\n    var _this2 = this;\n    _classCallCheck(this, Multicall);\n    var _this = this;\n    this.batchableJsonRpcMethods = [JsonRpcMethod.ethCall, JsonRpcMethod.ethGetCode, JsonRpcMethod.ethGetBalance];\n    this.multicallInterface = new ethers.utils.Interface(walletContracts.sequenceUtils.abi);\n    this.options = void 0;\n    this.timeout = void 0;\n    this.queue = [];\n    this.scheduleExecution = function () {\n      if (_this2.queue.length > 0) {\n        if (_this2.timeout) clearTimeout(_this2.timeout);\n        _this2.timeout = setTimeout(_this2.run, _this2.options.timeWindow);\n      }\n    };\n    this.handle = function (next, request, callback) {\n      // Schedule for batching and return\n      if (_this2.batchableJsonRpcMethods.find(function (m) {\n        return m === request.method;\n      })) {\n        _this2.queue.push({\n          request: request,\n          callback: callback,\n          next: next\n        });\n        if (_this2.options.verbose) console.log('Scheduling call', request.method);\n        _this2.scheduleExecution();\n        return;\n      }\n      if (_this2.options.verbose) console.log('Forwarded call', request.method); // Move to next handler\n\n      return next(request, callback);\n    };\n    this.run = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var limit, items, next, blockTag, _partition, _partition2, discartItems, callParams, _partition3, _partition4, encodedCall, reqId, res, decoded;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            /* eslint-disable no-var */\n            if (_this.options.verbose) console.log('Processing multicall'); // Read items from queue\n            limit = Math.min(_this.options.batchSize, _this.queue.length);\n            if (!(limit === 0)) {\n              _context.next = 4;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 4:\n            if (!(limit === 1)) {\n              _context.next = 9;\n              break;\n            }\n            _this.forward(_this.queue[0]);\n            _this.queue = [];\n            if (_this.options.verbose) console.log('Skip multicall, single item');\n            return _context.abrupt(\"return\");\n          case 9:\n            if (_this.options.verbose) console.log('Resolving', limit); // Get batch from queue\n            items = _this.queue.slice(0, limit); // Update queue\n            _this.queue = limit === _this.queue.length ? [] : _this.queue.slice(limit);\n            if (_this.options.verbose) console.log('Updated queue', _this.queue.length);\n            if (_this.queue.length !== 0) {\n              _this.scheduleExecution();\n            } // Get next candidate\n            next = items[0].next;\n            // Partition incompatible calls\n            _partition = partition(items, function (item) {\n              try {\n                // Mixed next callbacks\n                if (item.next !== next) return false;\n                switch (item.request.method) {\n                  case JsonRpcMethod.ethCall:\n                    // Unsupported eth_call parameters\n                    if (item.request.params[0].from || item.request.params[0].gasPrice || item.request.params[0].value) {\n                      return false;\n                    }\n                  case JsonRpcMethod.ethGetBalance:\n                  case JsonRpcMethod.ethGetCode:\n                    // Mixed blockTags\n                    var itemBlockTag = parseBlockTag(item.request.params[1]);\n                    if (blockTag === undefined) blockTag = itemBlockTag;\n                    if (!eqBlockTag(itemBlockTag, blockTag)) return false;\n                }\n                return true;\n              } catch (_unused) {\n                return false;\n              }\n            }), _partition2 = _slicedToArray(_partition, 2), items = _partition2[0], discartItems = _partition2[1]; // Forward discarted items\n            // end execution if no items remain\n            if (!(discartItems.length !== 0)) {\n              _context.next = 21;\n              break;\n            }\n            if (_this.options.verbose) console.log('Forwarding incompatible calls', discartItems.length);\n            _this.forward(discartItems);\n            if (!(items.length === 0)) {\n              _context.next = 21;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 21:\n            // Aggregate all calls\n            callParams = items.map(function (v) {\n              try {\n                switch (v.request.method) {\n                  case JsonRpcMethod.ethCall:\n                    return {\n                      delegateCall: false,\n                      revertOnError: false,\n                      target: v.request.params[0].to,\n                      data: v.request.params[0].data,\n                      gasLimit: v.request.params[0].gas ? v.request.params[0].gas : 0,\n                      value: 0\n                    };\n                  case JsonRpcMethod.ethGetCode:\n                    return {\n                      delegateCall: false,\n                      revertOnError: false,\n                      target: _this.options.contract,\n                      gasLimit: 0,\n                      value: 0,\n                      data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('callCode'), [v.request.params[0]])\n                    };\n                  case JsonRpcMethod.ethGetBalance:\n                    return {\n                      delegateCall: false,\n                      revertOnError: false,\n                      target: _this.options.contract,\n                      gasLimit: 0,\n                      value: 0,\n                      data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('callBalanceOf'), [v.request.params[0]])\n                    };\n                  default:\n                    return null;\n                }\n              } catch (_unused2) {\n                return null;\n              }\n            }); // Filter calls with enconding errors and forward items\n            _partition3 = partition(items, function (_, i) {\n              return callParams[i] !== undefined;\n            }), _partition4 = _slicedToArray(_partition3, 2), items = _partition4[0], discartItems = _partition4[1];\n            callParams = callParams.filter(function (c) {\n              return c;\n            });\n            if (!(discartItems.length !== 0)) {\n              _context.next = 29;\n              break;\n            }\n            if (_this.options.verbose) console.log('Forwarding calls on error', discartItems.length);\n            _this.forward(discartItems);\n            if (!(items.length === 0)) {\n              _context.next = 29;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 29:\n            _context.prev = 29;\n            encodedCall = _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('multiCall'), [callParams]);\n            _context.next = 37;\n            break;\n          case 33:\n            _context.prev = 33;\n            _context.t0 = _context[\"catch\"](29);\n            _this.forward(items);\n            return _context.abrupt(\"return\");\n          case 37:\n            // Forward single multicall rpc call\n            reqId = getRandomInt(); // TODO: fix types below..\n            _context.next = 40;\n            return safeSolve(\n            // @ts-ignore\n            promisify(next)({\n              id: reqId,\n              jsonrpc: JsonRpcVersion,\n              method: JsonRpcMethod.ethCall,\n              params: [{\n                to: _this.options.contract,\n                value: 0,\n                data: encodedCall\n              }, BigNumber.isBigNumber(blockTag) ? blockTag.toNumber() : blockTag] // @ts-ignore\n            }), function (e) {\n              return {\n                jsonrpc: JsonRpcVersion,\n                id: reqId,\n                result: undefined,\n                error: e\n              };\n            });\n          case 40:\n            res = _context.sent;\n            if (!res.error) {\n              _context.next = 43;\n              break;\n            }\n            return _context.abrupt(\"return\", _this.forward(items));\n          case 43:\n            _context.prev = 43;\n            // @ts-ignore\n            decoded = _this.multicallInterface.decodeFunctionResult(_this.multicallInterface.getFunction('multiCall'), res.result);\n            _context.next = 51;\n            break;\n          case 47:\n            _context.prev = 47;\n            _context.t1 = _context[\"catch\"](43);\n            _this.forward(items);\n            return _context.abrupt(\"return\");\n          case 51:\n            // Send results for each request\n            // errors fallback through the middleware\n\n            if (_this.options.verbose) console.log('Got response for', items.length);\n            items.forEach(function (item, index) {\n              if (!decoded[0][index]) {\n                _this.forward(item);\n              } else {\n                switch (item.request.method) {\n                  case JsonRpcMethod.ethCall:\n                    item.callback(undefined, {\n                      jsonrpc: item.request.jsonrpc,\n                      id: item.request.id,\n                      result: decoded[1][index]\n                    });\n                    break;\n                  case JsonRpcMethod.ethGetCode:\n                    item.callback(undefined, {\n                      jsonrpc: item.request.jsonrpc,\n                      id: item.request.id,\n                      result: ethers.utils.defaultAbiCoder.decode(['bytes'], decoded[1][index])[0]\n                    });\n                    break;\n                  case JsonRpcMethod.ethGetBalance:\n                    item.callback(undefined, {\n                      jsonrpc: item.request.jsonrpc,\n                      id: item.request.id,\n                      result: ethers.utils.defaultAbiCoder.decode(['uint256'], decoded[1][index])[0]\n                    });\n                    break;\n                }\n              }\n            });\n          case 53:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[29, 33], [43, 47]]);\n    }));\n    this.options = options ? _extends({}, Multicall.DefaultOptions, options) : Multicall.DefaultOptions;\n    if (this.options.batchSize <= 0) throw new Error(\"Invalid batch size of \".concat(this.options.batchSize));\n  }\n  _createClass(Multicall, [{\n    key: \"forward\",\n    value: function forward(entries) {\n      if (Array.isArray(entries)) {\n        entries.forEach(function (e) {\n          return e.next(e.request, e.callback);\n        });\n      } else {\n        entries.next(entries.request, entries.callback);\n      }\n    }\n  }], [{\n    key: \"isMulticall\",\n    value: function isMulticall(cand) {\n      return cand && cand.handle !== undefined && cand.conf !== undefined && Multicall.isMulticallOptions(cand.options);\n    }\n  }, {\n    key: \"isMulticallOptions\",\n    value: function isMulticallOptions(cand) {\n      return cand !== undefined && cand.batchSize !== undefined && cand.timeWindow !== undefined && cand.contract !== undefined;\n    }\n  }]);\n  return Multicall;\n}();\nMulticall.DefaultOptions = _extends({}, DefaultMulticallOptions);\nvar ProxyMethods = ['getNetwork', 'getBlockNumber', 'getGasPrice', 'getTransactionCount', 'getStorageAt', 'sendTransaction', 'estimateGas', 'getBlock', 'getTransaction', 'getTransactionReceipt', 'getLogs', 'emit', 'litenerCount', 'addListener', 'removeListener', 'waitForTransaction', 'detectNetwork', 'getBlockWithTransactions'];\nvar MulticallProvider = /*#__PURE__*/function (_ethers$providers$Bas) {\n  _inherits(MulticallProvider, _ethers$providers$Bas);\n  function MulticallProvider(provider, multicall) {\n    var _this3;\n    _classCallCheck(this, MulticallProvider);\n    var _this;\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(MulticallProvider).call(this, provider.getNetwork()));\n    _this = _assertThisInitialized(_assertThisInitialized(_this3));\n    _this3.provider = provider;\n    _this3.multicall = void 0;\n    _this3.listenerCount = _this3.provider.listenerCount;\n    _this3.getResolver = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name) {\n        var provider, ogResolver;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              provider = _this.provider;\n              if (!provider.getResolver) {\n                _context2.next = 12;\n                break;\n              }\n              _context2.t0 = provider;\n              _context2.next = 5;\n              return name;\n            case 5:\n              _context2.t1 = _context2.sent;\n              _context2.next = 8;\n              return _context2.t0.getResolver.call(_context2.t0, _context2.t1);\n            case 8:\n              ogResolver = _context2.sent;\n              if (ogResolver) {\n                _context2.next = 11;\n                break;\n              }\n              return _context2.abrupt(\"return\", null);\n            case 11:\n              return _context2.abrupt(\"return\", new ethers.providers.Resolver(_this, ogResolver.address, ogResolver.name));\n            case 12:\n              _context2.t2 = provider;\n              _context2.next = 15;\n              return name;\n            case 15:\n              _context2.t3 = _context2.sent;\n              return _context2.abrupt(\"return\", _context2.t2.getResolver.call(_context2.t2, _context2.t3));\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    _this3.next = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(req, callback) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.t0 = req.method;\n              _context3.next = _context3.t0 === JsonRpcMethod.ethCall ? 4 : _context3.t0 === JsonRpcMethod.ethGetCode ? 12 : _context3.t0 === JsonRpcMethod.ethGetBalance ? 20 : 28;\n              break;\n            case 4:\n              _context3.t1 = _this;\n              _context3.t2 = req;\n              _context3.t3 = callback;\n              _context3.next = 9;\n              return _this.provider.call(req.params[0], req.params[1]);\n            case 9:\n              _context3.t4 = _context3.sent;\n              _context3.t1.callback.call(_context3.t1, _context3.t2, _context3.t3, _context3.t4);\n              return _context3.abrupt(\"break\", 28);\n            case 12:\n              _context3.t5 = _this;\n              _context3.t6 = req;\n              _context3.t7 = callback;\n              _context3.next = 17;\n              return _this.provider.getCode(req.params[0], req.params[1]);\n            case 17:\n              _context3.t8 = _context3.sent;\n              _context3.t5.callback.call(_context3.t5, _context3.t6, _context3.t7, _context3.t8);\n              return _context3.abrupt(\"break\", 28);\n            case 20:\n              _context3.t9 = _this;\n              _context3.t10 = req;\n              _context3.t11 = callback;\n              _context3.next = 25;\n              return _this.provider.getBalance(req.params[0], req.params[1]);\n            case 25:\n              _context3.t12 = _context3.sent;\n              _context3.t9.callback.call(_context3.t9, _context3.t10, _context3.t11, _context3.t12);\n              return _context3.abrupt(\"break\", 28);\n            case 28:\n              _context3.next = 33;\n              break;\n            case 30:\n              _context3.prev = 30;\n              _context3.t13 = _context3[\"catch\"](0);\n              _this.callback(req, callback, undefined, _context3.t13);\n            case 33:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[0, 30]]);\n      }));\n      return function (_x4, _x5) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    _this3.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n    ProxyMethods.forEach(function (m) {\n      if (provider[m] !== undefined) {\n        _this3[m] = function () {\n          return provider[m].apply(provider, arguments);\n        };\n      }\n    });\n    return _this3;\n  }\n  _createClass(MulticallProvider, [{\n    key: \"callback\",\n    value: function callback(req, _callback, resp, err) {\n      _callback(err, {\n        jsonrpc: JsonRpcVersion,\n        id: req.id,\n        result: resp,\n        error: err\n      });\n    }\n  }, {\n    key: \"call\",\n    value: function () {\n      var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", this.rpcCall(JsonRpcMethod.ethCall, transaction, blockTag));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function call(_x6, _x7) {\n        return _call.apply(this, arguments);\n      }\n      return call;\n    }()\n  }, {\n    key: \"getCode\",\n    value: function () {\n      var _getCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(addressOrName, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", this.rpcCall(JsonRpcMethod.ethGetCode, addressOrName, blockTag));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getCode(_x8, _x9) {\n        return _getCode.apply(this, arguments);\n      }\n      return getCode;\n    }()\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(addressOrName, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.rpcCall(JsonRpcMethod.ethGetBalance, addressOrName, blockTag));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getBalance(_x10, _x11) {\n        return _getBalance.apply(this, arguments);\n      }\n      return getBalance;\n    }()\n  }, {\n    key: \"rpcCall\",\n    value: function () {\n      var _rpcCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(method) {\n        var reqId,\n          _len,\n          params,\n          _key,\n          resp,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              reqId = getRandomInt();\n              for (_len = _args7.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                params[_key - 1] = _args7[_key];\n              }\n              _context7.next = 4;\n              return promisify(this.multicall.handle)(this.next, {\n                jsonrpc: JsonRpcVersion,\n                id: reqId,\n                method: method,\n                params: params\n              });\n            case 4:\n              resp = _context7.sent;\n              return _context7.abrupt(\"return\", resp.result);\n            case 6:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function rpcCall(_x12) {\n        return _rpcCall.apply(this, arguments);\n      }\n      return rpcCall;\n    }()\n  }]);\n  return MulticallProvider;\n}(ethers.providers.BaseProvider);\nvar MulticallExternalProvider = /*#__PURE__*/function () {\n  function MulticallExternalProvider(provider, multicall) {\n    var _this4 = this;\n    _classCallCheck(this, MulticallExternalProvider);\n    this.provider = provider;\n    this.multicall = void 0;\n    this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n    if (provider.send) {\n      var next = /*#__PURE__*/function () {\n        var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(req, callback) {\n          return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n            while (1) switch (_context8.prev = _context8.next) {\n              case 0:\n                provider.send(req, callback);\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }, _callee8);\n        }));\n        function next(_x13, _x14) {\n          return _next.apply(this, arguments);\n        }\n        return next;\n      }();\n      this.send = function (request, callback) {\n        _this4.multicall.handle(next, request, callback);\n      };\n    }\n    if (provider.sendAsync) {\n      var _next2 = /*#__PURE__*/function () {\n        var _next3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(req, callback) {\n          return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n            while (1) switch (_context9.prev = _context9.next) {\n              case 0:\n                provider.sendAsync(req, callback);\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }, _callee9);\n        }));\n        function next(_x15, _x16) {\n          return _next3.apply(this, arguments);\n        }\n        return next;\n      }();\n      this.sendAsync = function (request, callback) {\n        _this4.multicall.handle(_next2, request, callback);\n      };\n    }\n  }\n  _createClass(MulticallExternalProvider, [{\n    key: \"isMetaMask\",\n    get: function get() {\n      return this.provider.isMetaMask;\n    }\n  }, {\n    key: \"isStatus\",\n    get: function get() {\n      return this.provider.isStatus;\n    }\n  }]);\n  return MulticallExternalProvider;\n}();\nvar multicallMiddleware = function multicallMiddleware(multicall) {\n  return function (next) {\n    var lib = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n    return function (request, callback) {\n      return lib.handle(next, request, callback);\n    };\n  };\n};\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ProxyMethods: ProxyMethods,\n  MulticallProvider: MulticallProvider,\n  MulticallExternalProvider: MulticallExternalProvider,\n  multicallMiddleware: multicallMiddleware\n});\nexport { Multicall, index as providers };","map":null,"metadata":{},"sourceType":"module"}