{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hexUtils = void 0;\nvar crypto = require(\"crypto\");\nvar ethUtil = require(\"ethereumjs-util\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n// tslint:disable:custom-no-magic-numbers\nvar WORD_LENGTH = 32;\nvar WORD_CEIL = new configured_bignumber_1.BigNumber(2).pow(WORD_LENGTH * 8);\nexports.hexUtils = {\n  concat: concat,\n  random: random,\n  leftPad: leftPad,\n  rightPad: rightPad,\n  invert: invert,\n  slice: slice,\n  hash: hash,\n  size: size,\n  toHex: toHex,\n  isHex: isHex\n};\n/**\n * Concatenate all arguments as a hex string.\n */\nfunction concat() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return ethUtil.bufferToHex(Buffer.concat(args.map(function (h) {\n    return ethUtil.toBuffer(h);\n  })));\n}\n/**\n * Generate a random hex string.\n */\nfunction random() {\n  var _size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : WORD_LENGTH;\n  return ethUtil.bufferToHex(crypto.randomBytes(_size));\n}\n/**\n * Left-pad a hex number to a number of bytes.\n */\nfunction leftPad(n) {\n  var _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n  return ethUtil.bufferToHex(ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Right-pad a hex number to a number of bytes.\n */\nfunction rightPad(n) {\n  var _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n  return ethUtil.bufferToHex(ethUtil.setLengthRight(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size));\n}\n/**\n * Inverts a hex word.\n */\nfunction invert(n) {\n  var _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n  var buf = ethUtil.setLengthLeft(ethUtil.toBuffer(exports.hexUtils.toHex(n)), _size);\n  // tslint:disable-next-line: no-bitwise\n  return ethUtil.bufferToHex(Buffer.from(buf.map(function (b) {\n    return ~b;\n  })));\n}\n/**\n * Slices a hex number.\n */\nfunction slice(n, start, end) {\n  var hex = exports.hexUtils.toHex(n).substr(2);\n  var sliceStart = start >= 0 ? start * 2 : Math.max(0, hex.length + start * 2);\n  var sliceEnd = hex.length;\n  if (end !== undefined) {\n    sliceEnd = end >= 0 ? end * 2 : Math.max(0, hex.length + end * 2);\n  }\n  return '0x'.concat(hex.substring(sliceStart, sliceEnd));\n}\n/**\n * Get the keccak hash of some data.\n */\nfunction hash(n) {\n  var buf = Buffer.isBuffer(n) ? n : ethUtil.toBuffer(exports.hexUtils.toHex(n));\n  return ethUtil.bufferToHex(ethUtil.keccak256(buf));\n}\n/**\n * Get the length, in bytes, of a hex string.\n */\nfunction size(hex) {\n  return Math.ceil((hex.length - 2) / 2);\n}\n/**\n * Convert a string, a number, a Buffer, or a BigNumber into a hex string.\n * Works with negative numbers, as well.\n */\nfunction toHex(n) {\n  var _size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WORD_LENGTH;\n  if (Buffer.isBuffer(n)) {\n    return \"0x\".concat(n.toString('hex'));\n  }\n  if (typeof n === 'string' && isHex(n)) {\n    // Already a hex.\n    return n;\n  }\n  var _n = new configured_bignumber_1.BigNumber(n);\n  if (_n.isNegative()) {\n    // Perform two's-complement.\n    // prettier-ignore\n    _n = new configured_bignumber_1.BigNumber(invert(toHex(_n.abs()), _size).substr(2), 16).plus(1).mod(WORD_CEIL);\n  }\n  return \"0x\".concat(_n.toString(16));\n}\n/**\n * Check if a string is a hex string.\n */\nfunction isHex(s) {\n  return /^0x[0-9a-f]*$/i.test(s);\n}","map":null,"metadata":{},"sourceType":"script"}