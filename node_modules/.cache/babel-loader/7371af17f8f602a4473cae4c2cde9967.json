{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeProxyCall = exports.encodeTransferCall = exports.encodeAtomicizedTransfer = exports.encodeDefaultCall = exports.encodeBuy = exports.encodeAtomicizedBuy = exports.encodeAtomicizedSell = exports.encodeSell = exports.encodeCall = exports.encodeReplacementPattern = exports.AbiType = void 0;\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar ethABI = __importStar(require(\"ethereumjs-abi\"));\nvar wyvern_js_1 = require(\"wyvern-js\");\nvar types_1 = require(\"wyvern-schemas/dist/types\");\nvar Proxy_1 = require(\"../abi/Proxy\");\nvar types_2 = require(\"../types\");\nvar wyvern_schemas_1 = require(\"wyvern-schemas\");\nObject.defineProperty(exports, \"AbiType\", {\n  enumerable: true,\n  get: function get() {\n    return wyvern_schemas_1.AbiType;\n  }\n});\nexports.encodeReplacementPattern = wyvern_js_1.WyvernProtocol.encodeReplacementPattern;\nvar encodeCall = function encodeCall(abi, parameters) {\n  var inputTypes = abi.inputs.map(function (i) {\n    return i.type;\n  });\n  return \"0x\" + Buffer.concat([ethABI.methodID(abi.name, inputTypes), ethABI.rawEncode(inputTypes, parameters)]).toString(\"hex\");\n};\nexports.encodeCall = encodeCall;\nvar encodeSell = function encodeSell(schema, asset, address, validatorAddress) {\n  var transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset);\n  return {\n    target: transfer.target,\n    calldata: (0, exports.encodeDefaultCall)(transfer, address),\n    replacementPattern: (0, exports.encodeReplacementPattern)(transfer)\n  };\n};\nexports.encodeSell = encodeSell;\nvar encodeAtomicizedSell = function encodeAtomicizedSell(schemas, assets, address, wyvernProtocol, networkName) {\n  var atomicizer = wyvernProtocol.wyvernAtomicizer;\n  var _a = encodeAtomicizedCalldata(atomicizer, schemas, assets, address, types_2.OrderSide.Sell),\n    atomicizedCalldata = _a.atomicizedCalldata,\n    atomicizedReplacementPattern = _a.atomicizedReplacementPattern;\n  return {\n    calldata: atomicizedCalldata,\n    replacementPattern: atomicizedReplacementPattern,\n    target: wyvern_js_1.WyvernProtocol.getAtomicizerContractAddress(networkName)\n  };\n};\nexports.encodeAtomicizedSell = encodeAtomicizedSell;\nvar encodeAtomicizedBuy = function encodeAtomicizedBuy(schemas, assets, address, wyvernProtocol, networkName) {\n  var atomicizer = wyvernProtocol.wyvernAtomicizer;\n  var _a = encodeAtomicizedCalldata(atomicizer, schemas, assets, address, types_2.OrderSide.Buy),\n    atomicizedCalldata = _a.atomicizedCalldata,\n    atomicizedReplacementPattern = _a.atomicizedReplacementPattern;\n  return {\n    calldata: atomicizedCalldata,\n    replacementPattern: atomicizedReplacementPattern,\n    target: wyvern_js_1.WyvernProtocol.getAtomicizerContractAddress(networkName)\n  };\n};\nexports.encodeAtomicizedBuy = encodeAtomicizedBuy;\nvar encodeBuy = function encodeBuy(schema, asset, address, validatorAddress) {\n  var transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset);\n  var replaceables = transfer.inputs.filter(function (i) {\n    return i.kind === types_1.FunctionInputKind.Replaceable;\n  });\n  var ownerInputs = transfer.inputs.filter(function (i) {\n    return i.kind === types_1.FunctionInputKind.Owner;\n  });\n  // Validate\n  if (replaceables.length !== 1) {\n    throw new Error(\"Only 1 input can match transfer destination, but instead \" + replaceables.length + \" did\");\n  }\n  // Compute calldata\n  var parameters = transfer.inputs.map(function (input) {\n    switch (input.kind) {\n      case types_1.FunctionInputKind.Replaceable:\n        return address;\n      case types_1.FunctionInputKind.Owner:\n        return wyvern_js_1.WyvernProtocol.generateDefaultValue(input.type);\n      default:\n        try {\n          return input.value.toString();\n        } catch (e) {\n          console.error(schema);\n          console.error(asset);\n          throw e;\n        }\n    }\n  });\n  var calldata = (0, exports.encodeCall)(transfer, parameters);\n  // Compute replacement pattern\n  var replacementPattern = \"0x\";\n  if (ownerInputs.length > 0) {\n    replacementPattern = (0, exports.encodeReplacementPattern)(transfer, types_1.FunctionInputKind.Owner);\n  }\n  return {\n    target: transfer.target,\n    calldata: calldata,\n    replacementPattern: replacementPattern\n  };\n};\nexports.encodeBuy = encodeBuy;\nvar encodeDefaultCall = function encodeDefaultCall(abi, address) {\n  var parameters = abi.inputs.map(function (input) {\n    switch (input.kind) {\n      case types_1.FunctionInputKind.Replaceable:\n        return wyvern_js_1.WyvernProtocol.generateDefaultValue(input.type);\n      case types_1.FunctionInputKind.Owner:\n        return address;\n      case types_1.FunctionInputKind.Asset:\n      default:\n        return input.value;\n    }\n  });\n  return (0, exports.encodeCall)(abi, parameters);\n};\nexports.encodeDefaultCall = encodeDefaultCall;\n/**\n * Encode the atomicized transfer of many assets\n * @param schema Wyvern Schema for the assets\n * @param assets List of assets to transfer\n * @param from Current address owning the assets\n * @param to Destination address\n * @param atomicizer Wyvern Atomicizer instance\n */\nfunction encodeAtomicizedTransfer(schemas, assets, from, to, wyvernProtocol, networkName) {\n  var atomicizer = wyvernProtocol.wyvernAtomicizer;\n  var transactions = assets.map(function (asset, i) {\n    var schema = schemas[i];\n    var transfer = schema.functions.transfer(asset);\n    var calldata = encodeTransferCall(transfer, from, to);\n    return {\n      calldata: calldata,\n      address: transfer.target,\n      value: new bignumber_js_1.BigNumber(0)\n    };\n  });\n  var atomicizedCalldata = atomicizer.atomicize(transactions.map(function (t) {\n    return t.address;\n  }), transactions.map(function (t) {\n    return t.value;\n  }), transactions.map(function (t) {\n    return new bignumber_js_1.BigNumber((t.calldata.length - 2) / 2);\n  }),\n  // subtract 2 for '0x', divide by 2 for hex\n  transactions.map(function (t) {\n    return t.calldata;\n  }).reduce(function (x, current) {\n    return x + current.slice(2);\n  }, \"0x\") // cut off the '0x'\n  ).getABIEncodedTransactionData();\n  return {\n    calldata: atomicizedCalldata,\n    target: wyvern_js_1.WyvernProtocol.getAtomicizerContractAddress(networkName)\n  };\n}\nexports.encodeAtomicizedTransfer = encodeAtomicizedTransfer;\n/**\n * Encode a transfer call for a Wyvern schema function\n * @param transferAbi Annotated Wyvern ABI\n * @param from From address\n * @param to To address\n */\nfunction encodeTransferCall(transferAbi, from, to) {\n  var parameters = transferAbi.inputs.map(function (input) {\n    switch (input.kind) {\n      case types_1.FunctionInputKind.Replaceable:\n        return to;\n      case types_1.FunctionInputKind.Owner:\n        return from;\n      case types_1.FunctionInputKind.Asset:\n      default:\n        if (input.value == null) {\n          throw new Error(\"Unsupported function input kind: \".concat(input.kind));\n        }\n        return input.value;\n    }\n  });\n  return (0, exports.encodeCall)(transferAbi, parameters);\n}\nexports.encodeTransferCall = encodeTransferCall;\n/**\n * Encode a call to a user's proxy contract\n * @param address The address for the proxy to call\n * @param howToCall How to call the addres\n * @param calldata The data to use in the call\n * @param shouldAssert Whether to assert success in the proxy call\n */\nfunction encodeProxyCall(address, howToCall, calldata, shouldAssert) {\n  if (shouldAssert === void 0) {\n    shouldAssert = true;\n  }\n  var abi = shouldAssert ? Proxy_1.proxyAssertABI : Proxy_1.proxyABI;\n  return (0, exports.encodeCall)(abi, [address, howToCall, Buffer.from(calldata.slice(2), \"hex\")]);\n}\nexports.encodeProxyCall = encodeProxyCall;\n// Helpers for atomicizer\nfunction encodeAtomicizedCalldata(atomicizer, schemas, assets, address, side) {\n  var encoder = side === types_2.OrderSide.Sell ? exports.encodeSell : exports.encodeBuy;\n  try {\n    var transactions = assets.map(function (asset, i) {\n      var schema = schemas[i];\n      var _a = encoder(schema, asset, address),\n        target = _a.target,\n        calldata = _a.calldata;\n      return {\n        calldata: calldata,\n        abi: schema.functions.transfer(asset),\n        address: target,\n        value: new bignumber_js_1.BigNumber(0)\n      };\n    });\n    var atomicizedCalldata = atomicizer.atomicize(transactions.map(function (t) {\n      return t.address;\n    }), transactions.map(function (t) {\n      return t.value;\n    }), transactions.map(function (t) {\n      return new bignumber_js_1.BigNumber((t.calldata.length - 2) / 2);\n    }),\n    // subtract 2 for '0x', divide by 2 for hex\n    transactions.map(function (t) {\n      return t.calldata;\n    }).reduce(function (x, y) {\n      return x + y.slice(2);\n    }) // cut off the '0x'\n    ).getABIEncodedTransactionData();\n    var kind = side === types_2.OrderSide.Buy ? types_1.FunctionInputKind.Owner : undefined;\n    var atomicizedReplacementPattern = wyvern_js_1.WyvernProtocol.encodeAtomicizedReplacementPattern(transactions.map(function (t) {\n      return t.abi;\n    }), kind);\n    if (!atomicizedCalldata || !atomicizedReplacementPattern) {\n      throw new Error(\"Invalid calldata: \".concat(atomicizedCalldata, \", \").concat(atomicizedReplacementPattern));\n    }\n    return {\n      atomicizedCalldata: atomicizedCalldata,\n      atomicizedReplacementPattern: atomicizedReplacementPattern\n    };\n  } catch (error) {\n    console.error({\n      schemas: schemas,\n      assets: assets,\n      address: address,\n      side: side\n    });\n    throw new Error(\"Failed to construct your order: likely something strange about this type of item. OpenSea has been notified. Please contact us in Discord! Original error: \".concat(error));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}