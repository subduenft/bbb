{"ast":null,"code":"var assert = require('assert');\nvar levelup = require('levelup');\nvar memdown = require('memdown');\nvar async = require('async');\nvar rlp = require('rlp');\nvar ethUtil = require('ethereumjs-util');\nvar semaphore = require('semaphore');\nvar TrieNode = require('./trieNode');\nvar ReadStream = require('./readStream');\nvar PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\nvar matchingNibbleLength = require('./util').matchingNibbleLength;\nvar doKeysMatch = require('./util').doKeysMatch;\nvar callTogether = require('./util').callTogether;\nvar asyncFirstSeries = require('./util').asyncFirstSeries;\nmodule.exports = Trie;\n\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\nfunction Trie(db, root) {\n  var self = this;\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n  this.sem = semaphore(1);\n\n  // setup dbs\n  this.db = db || levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this.db];\n  this._putDBs = [this.db];\n  Object.defineProperty(this, 'root', {\n    set: function set(value) {\n      if (value) {\n        value = ethUtil.toBuffer(value);\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n      } else {\n        value = self.EMPTY_TRIE_ROOT;\n      }\n      this._root = value;\n    },\n    get: function get() {\n      return this._root;\n    }\n  });\n  this.root = root;\n}\n\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\nTrie.prototype.get = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null;\n    if (node && remainder.length === 0) {\n      value = node.value;\n    }\n    cb(err, value);\n  });\n};\n\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.put = function (key, value, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  value = ethUtil.toBuffer(value);\n  if (!value || value.toString() === '') {\n    self.del(key, cb);\n  } else {\n    cb = callTogether(cb, self.sem.leave);\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          }\n          // then update\n          self._updateNode(key, value, keyRemainder, stack, cb);\n        });\n      } else {\n        self._createInitialNode(key, value, cb); // if no root initialize this trie\n      }\n    });\n  }\n};\n\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\nTrie.prototype.del = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err);\n      }\n      if (foundValue) {\n        self._deleteNode(key, stack, cb);\n      } else {\n        cb();\n      }\n    });\n  });\n};\n\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key);\n  function dbGet(db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null);\n      } else {\n        cb2(null, foundNode);\n      }\n    });\n  }\n  asyncFirstSeries(this._getDBs, dbGet, cb);\n};\n\n// retrieves a node from dbs by hash\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node));\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err;\n      }\n      if (value) {\n        value = new TrieNode(rlp.decode(value));\n      }\n      cb(value);\n    });\n  }\n};\n\n// TODO: remove the proxy method when changing the caching\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n  async.each(this._putDBs, dbPut, cb);\n};\n\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.putRaw = Trie.prototype._putRaw;\n\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.delRaw = function (key, cb) {\n  function del(db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2);\n  }\n  async.each(this._putDBs, del, cb);\n};\n\n// writes a single node to dbs\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash();\n  var serialized = node.serialize();\n  this._putRaw(hash, serialized, cb);\n};\n\n// writes many nodes to db\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch(db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb);\n  }\n  async.each(this._putDBs, dbBatch, cb);\n};\n\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this;\n  var root = self.root;\n  var stack = [];\n  targetKey = TrieNode.stringToNibbles(targetKey);\n  this._walkTrie(root, processNode, cb);\n  function processNode(nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || [];\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n    stack.push(node);\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack);\n        // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0];\n        var branchNode = node.getValue(branchIndex);\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack);\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex);\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack);\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack);\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack);\n      } else {\n        // keys match, continue search\n        walkController.next();\n      }\n    }\n  }\n};\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments);\n  });\n};\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key;\n    if (node.key) {\n      fullKey = key.concat(node.key);\n    }\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else {\n      // keep looking for value nodes\n      walkController.next();\n    }\n  }, cb);\n};\n\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next();\n    } else {\n      onFound(nodeRef, node, key, walkController.next);\n    }\n  }, cb);\n};\n\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = [];\n  var lastNode = stack.pop();\n\n  // add the new nodes\n  key = TrieNode.stringToNibbles(key);\n\n  // Check if the last node is a leaf and the key matches to this\n  var matchLeaf = false;\n  if (lastNode.type === 'leaf') {\n    var l = 0;\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i];\n      if (n.type === 'branch') {\n        l++;\n      } else {\n        l += n.key.length;\n      }\n    }\n    if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n      matchLeaf = true;\n    }\n  }\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value;\n    stack.push(lastNode);\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode);\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift();\n      // create a new leaf\n      var newLeaf = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeaf);\n    } else {\n      lastNode.value = value;\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key;\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n    var newBranchNode = new TrieNode('branch');\n\n    // create a new extention node\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength);\n      var newExtNode = new TrieNode('extention', newKey, value);\n      stack.push(newExtNode);\n      lastKey.splice(0, matchingLength);\n      keyRemainder.splice(0, matchingLength);\n    }\n    stack.push(newBranchNode);\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift();\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey;\n        var formatedNode = this._formatNode(lastNode, false, toSave);\n        newBranchNode.setValue(branchKey, formatedNode);\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave);\n        newBranchNode.setValue(branchKey, lastNode.value);\n      }\n    } else {\n      newBranchNode.value = lastNode.value;\n    }\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift();\n      // add a leaf node to the new branch node\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeafNode);\n    } else {\n      newBranchNode.value = value;\n    }\n  }\n  this._saveStack(key, stack, toSave, cb);\n};\n\n// walk tree\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this;\n  root = root || self.root;\n  onDone = onDone || function () {};\n  var aborted = false;\n  var returnValues = [];\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone();\n  }\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err);\n      }\n      onDone.apply(null, returnValues);\n    });\n  });\n\n  // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n  var maxPoolSize = 500;\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n  function processNode(nodeRef, node, key, cb) {\n    if (!node) return cb();\n    if (aborted) return cb();\n    var stopped = false;\n    key = key || [];\n    var walkController = {\n      stop: function stop() {\n        stopped = true;\n        cb();\n      },\n      // end all traversal and return values to the onDone cb\n      return: function _return() {\n        aborted = true;\n        returnValues = arguments;\n        cb();\n      },\n      next: function next() {\n        if (aborted) {\n          return cb();\n        }\n        if (stopped) {\n          return cb();\n        }\n        var children = node.getChildren();\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0];\n          var childRef = childData[1];\n          var childKey = key.concat(keyExtension);\n          var priority = childKey.length;\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback();\n              processNode(childRef, childNode, childKey, cb);\n            });\n          });\n        }, cb);\n      },\n      only: function only(childIndex) {\n        var childRef = node.getValue(childIndex);\n        var childKey = key.slice();\n        childKey.push(childIndex);\n        var priority = childKey.length;\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback();\n            processNode(childRef, childNode, childKey, cb);\n          });\n        });\n      }\n    };\n    onNode(nodeRef, node, key, walkController);\n  }\n};\n\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot;\n\n  // update nodes\n  while (stack.length) {\n    var node = stack.pop();\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length);\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length);\n      if (lastRoot) {\n        node.value = lastRoot;\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop();\n        node.setValue(branchKey, lastRoot);\n      }\n    }\n    lastRoot = this._formatNode(node, stack.length === 0, opStack);\n  }\n  if (lastRoot) {\n    this.root = lastRoot;\n  }\n  this._batchNodes(opStack, cb);\n};\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key;\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null);\n        stack.push(extentionNode);\n        key.push(branchKey);\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey);\n        branchNode.key = branchNodeKey;\n\n        // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n        branchNodeKey.unshift(0);\n        branchNodeKey.unshift(key.length);\n        key.splice.apply(key, branchNodeKey);\n      }\n      stack.push(branchNode);\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key;\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey);\n        key.push(branchKey);\n        parentNode.key = parentKey;\n        stack.push(parentNode);\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey);\n        key = key.concat(branchNodeKey);\n        parentKey = parentKey.concat(branchNodeKey);\n        branchNode.key = parentKey;\n      }\n      stack.push(branchNode);\n    }\n    return key;\n  }\n  var lastNode = stack.pop();\n  var parentNode = stack.pop();\n  var opStack = [];\n  var self = this;\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key);\n  }\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT;\n    cb();\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null;\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key;\n      key.splice(key.length - lastNodeKey.length);\n      // delete the value\n      this._formatNode(lastNode, false, true, opStack);\n      parentNode.setValue(key.pop(), null);\n      lastNode = parentNode;\n      parentNode = stack.pop();\n    }\n\n    // nodes on the branch\n    var branchNodes = [];\n    // count the number of nodes on the branch\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i);\n      if (val) branchNodes.push([i, val]);\n    });\n\n    // if there is only one branch node left, collapse the branch node\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1];\n      var branchNodeKey = branchNodes[0][0];\n\n      // look up node\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n        self._saveStack(key, stack, opStack, cb);\n      });\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n      stack.push(lastNode);\n      self._saveStack(key, stack, opStack, cb);\n    }\n  }\n};\n\n// Creates the initial node from an empty tree\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value);\n  this.root = newNode.hash();\n  this._putNode(newNode, cb);\n};\n\n// formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove;\n    remove = false;\n  }\n  var rlpNode = node.serialize();\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash();\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      });\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      });\n    }\n    return hashRoot;\n  }\n  return node.raw;\n};\n\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this);\n};\n\n// creates a new trie backed by the same db\n// and starting at the same root\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root);\n};\n\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\nTrie.prototype.batch = function (ops, cb) {\n  var self = this;\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2);\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2);\n    } else {\n      cb2();\n    }\n  }, cb);\n};\n\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root);\n  this._lookupNode(root, function (value) {\n    cb(null, !!value);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}