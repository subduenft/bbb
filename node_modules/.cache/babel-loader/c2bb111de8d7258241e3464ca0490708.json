{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextLayer = exports.getRoot = exports.fillArray = exports.hashConcat = exports.bufferKeccak = exports.hexToBuffer = exports.bufferToHex = exports.chunk = exports.makeArray = void 0;\nvar utils_1 = require(\"ethers/lib/utils\");\nvar makeArray = function makeArray(len, getValue) {\n  return Array(len).fill(0).map(function (_, i) {\n    return getValue(i);\n  });\n};\nexports.makeArray = makeArray;\nvar chunk = function chunk(array, size) {\n  return (0, exports.makeArray)(Math.ceil(array.length / size), function (i) {\n    return array.slice(i * size, (i + 1) * size);\n  });\n};\nexports.chunk = chunk;\nvar bufferToHex = function bufferToHex(buf) {\n  return (0, utils_1.hexlify)(buf);\n};\nexports.bufferToHex = bufferToHex;\nvar hexToBuffer = function hexToBuffer(value) {\n  return Buffer.from(value.slice(2), \"hex\");\n};\nexports.hexToBuffer = hexToBuffer;\nvar bufferKeccak = function bufferKeccak(value) {\n  return (0, exports.hexToBuffer)((0, utils_1.keccak256)(value));\n};\nexports.bufferKeccak = bufferKeccak;\nvar hashConcat = function hashConcat(arr) {\n  return (0, exports.bufferKeccak)((0, utils_1.hexConcat)(arr));\n};\nexports.hashConcat = hashConcat;\nvar fillArray = function fillArray(arr, length, value) {\n  if (length > arr.length) arr.push.apply(arr, __spreadArray([], __read(Array(length - arr.length).fill(value)), false));\n  return arr;\n};\nexports.fillArray = fillArray;\nvar getRoot = function getRoot(elements, hashLeaves) {\n  if (hashLeaves === void 0) {\n    hashLeaves = true;\n  }\n  if (elements.length === 0) throw new Error(\"empty tree\");\n  var leaves = elements.map(function (e) {\n    var leaf = Buffer.isBuffer(e) ? e : (0, exports.hexToBuffer)(e);\n    return hashLeaves ? (0, exports.bufferKeccak)(leaf) : leaf;\n  });\n  var layers = [leaves];\n  // Get next layer until we reach the root\n  while (layers[layers.length - 1].length > 1) {\n    layers.push((0, exports.getNextLayer)(layers[layers.length - 1]));\n  }\n  return layers[layers.length - 1][0];\n};\nexports.getRoot = getRoot;\nvar getNextLayer = function getNextLayer(elements) {\n  return (0, exports.chunk)(elements, 2).map(exports.hashConcat);\n};\nexports.getNextLayer = getNextLayer;","map":null,"metadata":{},"sourceType":"script"}