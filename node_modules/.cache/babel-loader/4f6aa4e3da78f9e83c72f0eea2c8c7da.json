{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar utilities_1 = require(\"./utilities\");\nexports.reconcileBlockHistory = function (getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention) {\n  if (blockRetention === void 0) {\n    blockRetention = 100;\n  }\n  return __awaiter(_this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, blockHistory];\n        case 1:\n          blockHistory = _a.sent();\n          if (!isFirstBlock(blockHistory)) return [3 /*break*/, 3];\n          return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\n        case 2:\n          return [2 /*return*/, _a.sent()];\n        case 3:\n          if (!isOlderThanOldestBlock(blockHistory, newBlock)) return [3 /*break*/, 6];\n          return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\n        case 4:\n          blockHistory = _a.sent();\n          return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\n        case 5:\n          return [2 /*return*/, _a.sent()];\n        case 6:\n          if (isAlreadyInHistory(blockHistory, newBlock)) return [2 /*return*/, blockHistory];\n          if (!isNewHeadBlock(blockHistory, newBlock)) return [3 /*break*/, 8];\n          return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\n        case 7:\n          return [2 /*return*/, _a.sent()];\n        case 8:\n          if (!parentHashIsInHistory(blockHistory, newBlock)) return [3 /*break*/, 13];\n          _a.label = 9;\n        case 9:\n          if (!(blockHistory.last().hash !== newBlock.parentHash)) return [3 /*break*/, 11];\n          return [4 /*yield*/, removeHeadBlock(blockHistory, onBlockRemoved)];\n        case 10:\n          blockHistory = _a.sent();\n          return [3 /*break*/, 9];\n        case 11:\n          return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\n        case 12:\n          return [2 /*return*/, _a.sent()];\n        case 13:\n          return [4 /*yield*/, backfill(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention)];\n        case 14:\n          return [2 /*return*/, _a.sent()];\n      }\n    });\n  });\n};\nvar rollback = function rollback(blockHistory, onBlockRemoved) {\n  return __awaiter(_this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!!blockHistory.isEmpty()) return [3 /*break*/, 2];\n          return [4 /*yield*/, removeHeadBlock(blockHistory, onBlockRemoved)];\n        case 1:\n          // CONSIDER: if this throws an exception, removals may have been announced that are actually still in history since throwing will result in no history update. we can't catch errors here because there isn't a clear way to recover from them, the failure may be a downstream system telling us that the block removal isn't possible because they are in a bad state. we could try re-announcing the successfully added blocks, but there would still be a problem with the failed block (should it be re-announced?) and the addition announcements may also fail\n          blockHistory = _a.sent();\n          return [3 /*break*/, 0];\n        case 2:\n          return [2 /*return*/, blockHistory];\n      }\n    });\n  });\n};\nvar backfill = function backfill(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention) {\n  return __awaiter(_this, void 0, void 0, function () {\n    var parentBlock;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(newBlock.parentHash === \"0x0000000000000000000000000000000000000000000000000000000000000000\")) return [3 /*break*/, 2];\n          return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\n        case 1:\n          return [2 /*return*/, _a.sent()];\n        case 2:\n          return [4 /*yield*/, getBlockByHash(newBlock.parentHash)];\n        case 3:\n          parentBlock = _a.sent();\n          if (parentBlock === null) throw new Error(\"Failed to fetch parent block.\");\n          if (!(utilities_1.parseHexInt(parentBlock.number) + blockRetention < utilities_1.parseHexInt(blockHistory.last().number))) return [3 /*break*/, 5];\n          return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\n        case 4:\n          return [2 /*return*/, _a.sent()];\n        case 5:\n          return [4 /*yield*/, exports.reconcileBlockHistory(getBlockByHash, blockHistory, parentBlock, onBlockAdded, onBlockRemoved, blockRetention)];\n        case 6:\n          blockHistory = _a.sent();\n          return [4 /*yield*/, exports.reconcileBlockHistory(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention)];\n        case 7:\n          return [2 /*return*/, _a.sent()];\n      }\n    });\n  });\n};\nvar addNewHeadBlock = function addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention) {\n  return __awaiter(_this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          // this is here as a final sanity check, in case we somehow got into an unexpected state, there are no known (and should never be) ways to reach this exception\n          if (!blockHistory.isEmpty() && blockHistory.last().hash !== newBlock.parentHash) throw new Error(\"New head block's parent isn't our current head.\");\n          // CONSIDER: the user getting this notification won't have any visibility into the updated block history yet. should we announce new blocks in a `setTimeout`? should we provide block history with new logs? an announcement failure will result in unwinding the stack and returning the original blockHistory, if we are in the process of backfilling we may have already announced previous blocks that won't actually end up in history (they won't get removed if a re-org occurs and may be re-announced). we can't catch errors thrown by the callback because it may be trying to signal to use that the block has become invalid and is un-processable\n          return [4 /*yield*/, onBlockAdded(newBlock)];\n        case 1:\n          // CONSIDER: the user getting this notification won't have any visibility into the updated block history yet. should we announce new blocks in a `setTimeout`? should we provide block history with new logs? an announcement failure will result in unwinding the stack and returning the original blockHistory, if we are in the process of backfilling we may have already announced previous blocks that won't actually end up in history (they won't get removed if a re-org occurs and may be re-announced). we can't catch errors thrown by the callback because it may be trying to signal to use that the block has become invalid and is un-processable\n          _a.sent();\n          blockHistory = blockHistory.push(newBlock);\n          return [2 /*return*/, blockHistory.takeLast(blockRetention).toList()];\n      }\n    });\n  });\n};\nvar removeHeadBlock = function removeHeadBlock(blockHistory, onBlockRemoved) {\n  return __awaiter(_this, void 0, void 0, function () {\n    var removedBlock;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          removedBlock = blockHistory.last();\n          blockHistory = blockHistory.pop();\n          return [4 /*yield*/, onBlockRemoved(removedBlock)];\n        case 1:\n          _a.sent();\n          return [2 /*return*/, blockHistory];\n      }\n    });\n  });\n};\nvar isFirstBlock = function isFirstBlock(blockHistory) {\n  return blockHistory.isEmpty();\n};\nvar isOlderThanOldestBlock = function isOlderThanOldestBlock(blockHistory, newBlock) {\n  return utilities_1.parseHexInt(blockHistory.first().number) > utilities_1.parseHexInt(newBlock.number);\n};\nvar isAlreadyInHistory = function isAlreadyInHistory(blockHistory, newBlock) {\n  // `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\n  return blockHistory.some(function (block) {\n    return block.hash === newBlock.hash;\n  });\n};\nvar isNewHeadBlock = function isNewHeadBlock(blockHistory, newBlock) {\n  return blockHistory.last().hash === newBlock.parentHash;\n};\nvar parentHashIsInHistory = function parentHashIsInHistory(blockHistory, newBlock) {\n  // `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\n  return blockHistory.some(function (block) {\n    return block.hash === newBlock.parentHash;\n  });\n};","map":null,"metadata":{},"sourceType":"script"}