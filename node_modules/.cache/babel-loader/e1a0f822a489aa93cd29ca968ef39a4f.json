{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar async = require(\"async\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar ethereumjs_common_1 = require(\"ethereumjs-common\");\nvar callbackify_1 = require(\"./callbackify\");\nvar dbManager_1 = require(\"./dbManager\");\nvar util_1 = require(\"./util\");\nvar Block = require('ethereumjs-block');\nvar Ethash = require('ethashjs');\nvar Stoplight = require('flow-stoplight');\nvar level = require('level-mem');\nvar semaphore = require('semaphore');\n/**\n * This class stores and interacts with blocks.\n */\nvar Blockchain = /** @class */function () {\n  /**\n   * Creates new Blockchain object\n   *\n   * @param opts - An object with the options that this constructor takes. See [[BlockchainOptions]].\n   */\n  function Blockchain(opts) {\n    var _this = this;\n    if (opts === void 0) {\n      opts = {};\n    }\n    /**\n     * This field is always `true`. It's here only for backwards compatibility.\n     *\n     * @deprecated\n     */\n    this.validate = true;\n    if (opts.common) {\n      if (opts.chain) {\n        throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!');\n      }\n      this._common = opts.common;\n    } else {\n      var chain = opts.chain ? opts.chain : 'mainnet';\n      var hardfork = opts.hardfork ? opts.hardfork : null;\n      this._common = new ethereumjs_common_1.default(chain, hardfork);\n    }\n    if (opts.validate !== undefined) {\n      if (opts.validatePow !== undefined || opts.validateBlocks !== undefined) {\n        throw new Error(\"opts.validate can't be used at the same time than opts.validatePow nor opts.validateBlocks\");\n      }\n    }\n    // defaults\n    if (opts.validate !== undefined) {\n      this._validatePow = opts.validate;\n      this._validateBlocks = opts.validate;\n    } else {\n      this._validatePow = opts.validatePow !== undefined ? opts.validatePow : true;\n      this._validateBlocks = opts.validateBlocks !== undefined ? opts.validateBlocks : true;\n    }\n    this.db = opts.db ? opts.db : level();\n    this.dbManager = new dbManager_1.default(this.db, this._common);\n    this.ethash = this._validatePow ? new Ethash(this.db) : null;\n    this._heads = {};\n    this._genesis = null;\n    this._headHeader = null;\n    this._headBlock = null;\n    this._initDone = false;\n    this._putSemaphore = semaphore(1);\n    this._initLock = new Stoplight();\n    this._init(function (err) {\n      if (err) {\n        throw err;\n      }\n      _this._initLock.go();\n    });\n  }\n  Object.defineProperty(Blockchain.prototype, \"meta\", {\n    /**\n     * Returns an object with metadata about the Blockchain. It's defined for backwards compatibility.\n     */\n    get: function get() {\n      return {\n        rawHead: this._headHeader,\n        heads: this._heads,\n        genesis: this._genesis\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Fetches the meta info about the blockchain from the db. Meta info contains\n   * hashes of the headerchain head, blockchain head, genesis block and iterator\n   * heads.\n   *\n   * @hidden\n   */\n  Blockchain.prototype._init = function (cb) {\n    var self = this;\n    async.waterfall([function (cb) {\n      return self._numberToHash(new ethereumjs_util_1.BN(0), cb);\n    }, callbackify_1.callbackify(getHeads.bind(this))], function (err) {\n      if (err) {\n        // if genesis block doesn't exist, create one\n        return self._setCanonicalGenesisBlock(function (err) {\n          if (err) {\n            return cb(err);\n          }\n          self._heads = {};\n          self._headHeader = self._genesis;\n          self._headBlock = self._genesis;\n          cb();\n        });\n      }\n      cb();\n    });\n    function getHeads(genesisHash) {\n      return __awaiter(this, void 0, void 0, function () {\n        var heads_1, e_1, hash, e_2, e_3;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              self._genesis = genesisHash;\n              _a.label = 1;\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n              return [4 /*yield*/, self.dbManager.getHeads()];\n            case 2:\n              heads_1 = _a.sent();\n              Object.keys(heads_1).forEach(function (key) {\n                heads_1[key] = Buffer.from(heads_1[key]);\n              });\n              self._heads = heads_1;\n              return [3 /*break*/, 4];\n            case 3:\n              e_1 = _a.sent();\n              self._heads = {};\n              return [3 /*break*/, 4];\n            case 4:\n              _a.trys.push([4, 6,, 7]);\n              return [4 /*yield*/, self.dbManager.getHeadHeader()];\n            case 5:\n              hash = _a.sent();\n              self._headHeader = hash;\n              return [3 /*break*/, 7];\n            case 6:\n              e_2 = _a.sent();\n              self._headHeader = genesisHash;\n              return [3 /*break*/, 7];\n            case 7:\n              _a.trys.push([7, 9,, 10]);\n              return [4 /*yield*/, self.dbManager.getHeadBlock()];\n            case 8:\n              hash = _a.sent();\n              self._headBlock = hash;\n              return [3 /*break*/, 10];\n            case 9:\n              e_3 = _a.sent();\n              self._headBlock = genesisHash;\n              return [3 /*break*/, 10];\n            case 10:\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n  };\n  /**\n   * Sets the default genesis block\n   *\n   * @hidden\n   */\n  Blockchain.prototype._setCanonicalGenesisBlock = function (cb) {\n    var genesisBlock = new Block(null, {\n      common: this._common\n    });\n    genesisBlock.setGenesisParams();\n    this._putBlockOrHeader(genesisBlock, cb, true);\n  };\n  /**\n   * Puts the genesis block in the database\n   *\n   * @param genesis - The genesis block to be added\n   * @param cb - The callback. It is given two parameters `err` and the saved `block`\n   */\n  Blockchain.prototype.putGenesis = function (genesis, cb) {\n    this.putBlock(genesis, cb, true);\n  };\n  /**\n   * Returns the specified iterator head.\n   *\n   * @param name - Optional name of the state root head (default: 'vm')\n   * @param cb - The callback. It is given two parameters `err` and the returned `block`\n   */\n  Blockchain.prototype.getHead = function (name, cb) {\n    var _this = this;\n    // handle optional args\n    if (typeof name === 'function') {\n      cb = name;\n      name = 'vm';\n    }\n    // ensure init completed\n    this._initLock.await(function () {\n      // if the head is not found return the headHeader\n      var hash = _this._heads[name] || _this._headBlock;\n      if (!hash) {\n        return cb(new Error('No head found.'));\n      }\n      _this.getBlock(hash, cb);\n    });\n  };\n  /**\n   * Returns the latest header in the canonical chain.\n   *\n   * @param cb - The callback. It is given two parameters `err` and the returned `header`\n   */\n  Blockchain.prototype.getLatestHeader = function (cb) {\n    var _this = this;\n    // ensure init completed\n    this._initLock.await(function () {\n      _this.getBlock(_this._headHeader, function (err, block) {\n        if (err) {\n          return cb(err);\n        }\n        cb(null, block.header);\n      });\n    });\n  };\n  /**\n   * Returns the latest full block in the canonical chain.\n   *\n   * @param cb - The callback. It is given two parameters `err` and the returned `block`\n   */\n  Blockchain.prototype.getLatestBlock = function (cb) {\n    var _this = this;\n    // ensure init completed\n    this._initLock.await(function () {\n      _this.getBlock(_this._headBlock, cb);\n    });\n  };\n  /**\n   * Adds many blocks to the blockchain.\n   *\n   * @param blocks - The blocks to be added to the blockchain\n   * @param cb - The callback. It is given two parameters `err` and the last of the saved `blocks`\n   */\n  Blockchain.prototype.putBlocks = function (blocks, cb) {\n    var _this = this;\n    async.eachSeries(blocks, function (block, done) {\n      _this.putBlock(block, done);\n    }, cb);\n  };\n  /**\n   * Adds a block to the blockchain.\n   *\n   * @param block - The block to be added to the blockchain\n   * @param cb - The callback. It is given two parameters `err` and the saved `block`\n   */\n  Blockchain.prototype.putBlock = function (block, cb, isGenesis) {\n    var _this = this;\n    // make sure init has completed\n    this._initLock.await(function () {\n      // perform put with mutex dance\n      _this._lockUnlock(function (done) {\n        _this._putBlockOrHeader(block, done, isGenesis);\n      }, cb);\n    });\n  };\n  /**\n   * Adds many headers to the blockchain.\n   *\n   * @param headers - The headers to be added to the blockchain\n   * @param cb - The callback. It is given two parameters `err` and the last of the saved `headers`\n   */\n  Blockchain.prototype.putHeaders = function (headers, cb) {\n    var _this = this;\n    async.eachSeries(headers, function (header, done) {\n      _this.putHeader(header, done);\n    }, cb);\n  };\n  /**\n   * Adds a header to the blockchain.\n   *\n   * @param header - The header to be added to the blockchain\n   * @param cb - The callback. It is given two parameters `err` and the saved `header`\n   */\n  Blockchain.prototype.putHeader = function (header, cb) {\n    var _this = this;\n    // make sure init has completed\n    this._initLock.await(function () {\n      // perform put with mutex dance\n      _this._lockUnlock(function (done) {\n        _this._putBlockOrHeader(header, done);\n      }, cb);\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._putBlockOrHeader = function (item, cb, isGenesis) {\n    var self = this;\n    var isHeader = item instanceof Block.Header;\n    var block = isHeader ? new Block([item.raw, [], []], {\n      common: item._common\n    }) : item;\n    var header = block.header;\n    var hash = block.hash();\n    var number = new ethereumjs_util_1.BN(header.number);\n    var td = new ethereumjs_util_1.BN(header.difficulty);\n    var currentTd = {\n      header: null,\n      block: null\n    };\n    var dbOps = [];\n    if (block.constructor !== Block) {\n      block = new Block(block, {\n        common: self._common\n      });\n    }\n    if (block._common.chainId() !== self._common.chainId()) {\n      return cb(new Error('Chain mismatch while trying to put block or header'));\n    }\n    async.series([verify, verifyPOW, getCurrentTd, getBlockTd, rebuildInfo, function (cb) {\n      return self._batchDbOps(dbOps.concat(self._saveHeadOps()), cb);\n    }], cb);\n    function verify(next) {\n      if (!self._validateBlocks) {\n        return next();\n      }\n      if (!isGenesis && block.isGenesis()) {\n        return next(new Error('already have genesis set'));\n      }\n      block.validate(self, next);\n    }\n    function verifyPOW(next) {\n      if (!self._validatePow) {\n        return next();\n      }\n      self.ethash.verifyPOW(block, function (valid) {\n        next(valid ? null : new Error('invalid POW'));\n      });\n    }\n    function getCurrentTd(next) {\n      if (isGenesis) {\n        currentTd.header = new ethereumjs_util_1.BN(0);\n        currentTd.block = new ethereumjs_util_1.BN(0);\n        return next();\n      }\n      async.parallel([function (cb) {\n        return self._getTd(self._headHeader, function (err, td) {\n          currentTd.header = td;\n          cb(err);\n        });\n      }, function (cb) {\n        return self._getTd(self._headBlock, function (err, td) {\n          currentTd.block = td;\n          cb(err);\n        });\n      }], next);\n    }\n    function getBlockTd(next) {\n      // calculate the total difficulty of the new block\n      if (isGenesis) {\n        return next();\n      }\n      self._getTd(header.parentHash, number.subn(1), function (err, parentTd) {\n        if (err) {\n          return next(err);\n        }\n        td.iadd(parentTd);\n        next();\n      });\n    }\n    function rebuildInfo(next) {\n      // save block and total difficulty to the database\n      var key = util_1.tdKey(number, hash);\n      var value = ethereumjs_util_1.rlp.encode(td);\n      dbOps.push({\n        type: 'put',\n        key: key,\n        keyEncoding: 'binary',\n        valueEncoding: 'binary',\n        value: value\n      });\n      self.dbManager._cache.td.set(key, value);\n      // save header\n      key = util_1.headerKey(number, hash);\n      value = ethereumjs_util_1.rlp.encode(header.raw);\n      dbOps.push({\n        type: 'put',\n        key: key,\n        keyEncoding: 'binary',\n        valueEncoding: 'binary',\n        value: value\n      });\n      self.dbManager._cache.header.set(key, value);\n      // store body if it exists\n      if (isGenesis || block.transactions.length || block.uncleHeaders.length) {\n        var body = block.serialize(false).slice(1);\n        key = util_1.bodyKey(number, hash);\n        value = ethereumjs_util_1.rlp.encode(body);\n        dbOps.push({\n          type: 'put',\n          key: key,\n          keyEncoding: 'binary',\n          valueEncoding: 'binary',\n          value: value\n        });\n        self.dbManager._cache.body.set(key, value);\n      }\n      // if total difficulty is higher than current, add it to canonical chain\n      if (block.isGenesis() || td.gt(currentTd.header)) {\n        self._headHeader = hash;\n        if (!isHeader) {\n          self._headBlock = hash;\n        }\n        if (block.isGenesis()) {\n          self._genesis = hash;\n        }\n        // delete higher number assignments and overwrite stale canonical chain\n        async.parallel([function (cb) {\n          return self._deleteStaleAssignments(number.addn(1), hash, dbOps, cb);\n        }, function (cb) {\n          return self._rebuildCanonical(header, dbOps, cb);\n        }], next);\n      } else {\n        if (td.gt(currentTd.block) && !isHeader) {\n          self._headBlock = hash;\n        }\n        // save hash to number lookup info even if rebuild not needed\n        key = util_1.hashToNumberKey(hash);\n        value = util_1.bufBE8(number);\n        dbOps.push({\n          type: 'put',\n          key: key,\n          keyEncoding: 'binary',\n          valueEncoding: 'binary',\n          value: value\n        });\n        self.dbManager._cache.hashToNumber.set(key, value);\n        next();\n      }\n    }\n  };\n  /**\n   * Gets a block by its hash.\n   *\n   * @param blockTag - The block's hash or number\n   * @param cb - The callback. It is given two parameters `err` and the found `block` (an instance of https://github.com/ethereumjs/ethereumjs-block) if any.\n   */\n  Blockchain.prototype.getBlock = function (blockTag, cb) {\n    var _this = this;\n    // ensure init completed\n    this._initLock.await(function () {\n      _this._getBlock(blockTag, cb);\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._getBlock = function (blockTag, cb) {\n    callbackify_1.callbackify(this.dbManager.getBlock.bind(this.dbManager))(blockTag, cb);\n  };\n  /**\n   * Looks up many blocks relative to blockId\n   *\n   * @param blockId - The block's hash or number\n   * @param maxBlocks - Max number of blocks to return\n   * @param skip - Number of blocks to skip apart\n   * @param reverse - Fetch blocks in reverse\n   * @param cb - The callback. It is given two parameters `err` and the found `blocks` if any.\n   */\n  Blockchain.prototype.getBlocks = function (blockId, maxBlocks, skip, reverse, cb) {\n    var self = this;\n    var blocks = [];\n    var i = -1;\n    function nextBlock(blockId) {\n      self.getBlock(blockId, function (err, block) {\n        i++;\n        if (err) {\n          if (err.notFound) {\n            return cb(null, blocks);\n          } else {\n            return cb(err);\n          }\n        }\n        var nextBlockNumber = new ethereumjs_util_1.BN(block.header.number).addn(reverse ? -1 : 1);\n        if (i !== 0 && skip && i % (skip + 1) !== 0) {\n          return nextBlock(nextBlockNumber);\n        }\n        blocks.push(block);\n        if (blocks.length === maxBlocks) {\n          return cb(null, blocks);\n        }\n        nextBlock(nextBlockNumber);\n      });\n    }\n    nextBlock(blockId);\n  };\n  /**\n   * This method used to return block details by its hash. It's only here for backwards compatibility.\n   *\n   * @deprecated\n   */\n  Blockchain.prototype.getDetails = function (_, cb) {\n    cb(null, {});\n  };\n  /**\n   * Given an ordered array, returns to the callback an array of hashes that are not in the blockchain yet.\n   *\n   * @param hashes - Ordered array of hashes\n   * @param cb - The callback. It is given two parameters `err` and hashes found.\n   */\n  Blockchain.prototype.selectNeededHashes = function (hashes, cb) {\n    var self = this;\n    var max, mid, min;\n    max = hashes.length - 1;\n    mid = min = 0;\n    async.whilst(function test() {\n      return max >= min;\n    }, function iterate(cb2) {\n      self._hashToNumber(hashes[mid], function (err, number) {\n        if (!err && number) {\n          min = mid + 1;\n        } else {\n          max = mid - 1;\n        }\n        mid = Math.floor((min + max) / 2);\n        cb2();\n      });\n    }, function onDone(err) {\n      if (err) return cb(err);\n      cb(null, hashes.slice(min));\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._saveHeadOps = function () {\n    return [{\n      type: 'put',\n      key: 'heads',\n      keyEncoding: 'binary',\n      valueEncoding: 'json',\n      value: this._heads\n    }, {\n      type: 'put',\n      key: util_1.headHeaderKey,\n      keyEncoding: 'binary',\n      valueEncoding: 'binary',\n      value: this._headHeader\n    }, {\n      type: 'put',\n      key: util_1.headBlockKey,\n      keyEncoding: 'binary',\n      valueEncoding: 'binary',\n      value: this._headBlock\n    }];\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._saveHeads = function (cb) {\n    this._batchDbOps(this._saveHeadOps(), cb);\n  };\n  /**\n   * Delete canonical number assignments for specified number and above\n   *\n   * @hidden\n   */\n  Blockchain.prototype._deleteStaleAssignments = function (number, headHash, ops, cb) {\n    var _this = this;\n    var key = util_1.numberToHashKey(number);\n    this._numberToHash(number, function (err, hash) {\n      if (err) {\n        return cb();\n      }\n      ops.push({\n        type: 'del',\n        key: key,\n        keyEncoding: 'binary'\n      });\n      _this.dbManager._cache.numberToHash.del(key);\n      // reset stale iterator heads to current canonical head\n      Object.keys(_this._heads).forEach(function (name) {\n        if (_this._heads[name].equals(hash)) {\n          _this._heads[name] = headHash;\n        }\n      });\n      // reset stale headBlock to current canonical\n      if (_this._headBlock.equals(hash)) {\n        _this._headBlock = headHash;\n      }\n      _this._deleteStaleAssignments(number.addn(1), headHash, ops, cb);\n    });\n  };\n  /**\n   * Overwrites stale canonical number assignments.\n   *\n   * @hidden\n   */\n  Blockchain.prototype._rebuildCanonical = function (header, ops, cb) {\n    var self = this;\n    var hash = header.hash();\n    var number = new ethereumjs_util_1.BN(header.number);\n    function saveLookups(hash, number) {\n      var key = util_1.numberToHashKey(number);\n      var value;\n      ops.push({\n        type: 'put',\n        key: key,\n        keyEncoding: 'binary',\n        valueEncoding: 'binary',\n        value: hash\n      });\n      self.dbManager._cache.numberToHash.set(key, hash);\n      key = util_1.hashToNumberKey(hash);\n      value = util_1.bufBE8(number);\n      ops.push({\n        type: 'put',\n        key: key,\n        keyEncoding: 'binary',\n        valueEncoding: 'binary',\n        value: value\n      });\n      self.dbManager._cache.hashToNumber.set(key, value);\n    }\n    // handle genesis block\n    if (number.cmpn(0) === 0) {\n      saveLookups(hash, number);\n      return cb();\n    }\n    self._numberToHash(number, function (err, staleHash) {\n      if (err) {\n        staleHash = null;\n      }\n      if (!staleHash || !hash.equals(staleHash)) {\n        saveLookups(hash, number);\n        // flag stale head for reset\n        Object.keys(self._heads).forEach(function (name) {\n          if (staleHash && self._heads[name].equals(staleHash)) {\n            self._staleHeads = self._staleHeads || [];\n            self._staleHeads.push(name);\n          }\n        });\n        // flag stale headBlock for reset\n        if (staleHash && self._headBlock.equals(staleHash)) {\n          self._staleHeadBlock = true;\n        }\n        self._getHeader(header.parentHash, number.subn(1), function (err, header) {\n          if (err) {\n            delete self._staleHeads;\n            return cb(err);\n          }\n          self._rebuildCanonical(header, ops, cb);\n        });\n      } else {\n        // set stale heads to last previously valid canonical block\n        ;\n        (self._staleHeads || []).forEach(function (name) {\n          self._heads[name] = hash;\n        });\n        delete self._staleHeads;\n        // set stale headBlock to last previously valid canonical block\n        if (self._staleHeadBlock) {\n          self._headBlock = hash;\n          delete self._staleHeadBlock;\n        }\n        cb();\n      }\n    });\n  };\n  /**\n   * Deletes a block from the blockchain. All child blocks in the chain are deleted and any\n   * encountered heads are set to the parent block.\n   *\n   * @param blockHash - The hash of the block to be deleted\n   * @param cb - A callback.\n   */\n  Blockchain.prototype.delBlock = function (blockHash, cb) {\n    var _this = this;\n    // make sure init has completed\n    this._initLock.await(function () {\n      // perform put with mutex dance\n      _this._lockUnlock(function (done) {\n        _this._delBlock(blockHash, done);\n      }, cb);\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._delBlock = function (blockHash, cb) {\n    var self = this;\n    var dbOps = [];\n    var blockHeader = null;\n    var blockNumber = null;\n    var parentHash = null;\n    var inCanonical = null;\n    if (!Buffer.isBuffer(blockHash)) {\n      blockHash = blockHash.hash();\n    }\n    async.series([getHeader, checkCanonical, buildDBops, deleteStaleAssignments, function (cb) {\n      return self._batchDbOps(dbOps, cb);\n    }], cb);\n    function getHeader(cb2) {\n      self._getHeader(blockHash, function (err, header) {\n        if (err) return cb2(err);\n        blockHeader = header;\n        blockNumber = new ethereumjs_util_1.BN(blockHeader.number);\n        parentHash = blockHeader.parentHash;\n        cb2();\n      });\n    }\n    // check if block is in the canonical chain\n    function checkCanonical(cb2) {\n      self._numberToHash(blockNumber, function (err, hash) {\n        inCanonical = !err && hash.equals(blockHash);\n        cb2();\n      });\n    }\n    // delete the block, and if block is in the canonical chain, delete all\n    // children as well\n    function buildDBops(cb2) {\n      self._delChild(blockHash, blockNumber, inCanonical ? parentHash : null, dbOps, cb2);\n    }\n    // delete all number to hash mappings for deleted block number and above\n    function deleteStaleAssignments(cb2) {\n      if (inCanonical) {\n        self._deleteStaleAssignments(blockNumber, parentHash, dbOps, cb2);\n      } else {\n        cb2();\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._delChild = function (hash, number, headHash, ops, cb) {\n    var self = this;\n    // delete header, body, hash to number mapping and td\n    ops.push({\n      type: 'del',\n      key: util_1.headerKey(number, hash),\n      keyEncoding: 'binary'\n    });\n    self.dbManager._cache.header.del(util_1.headerKey(number, hash));\n    ops.push({\n      type: 'del',\n      key: util_1.bodyKey(number, hash),\n      keyEncoding: 'binary'\n    });\n    self.dbManager._cache.body.del(util_1.bodyKey(number, hash));\n    ops.push({\n      type: 'del',\n      key: util_1.hashToNumberKey(hash),\n      keyEncoding: 'binary'\n    });\n    self.dbManager._cache.hashToNumber.del(util_1.hashToNumberKey(hash));\n    ops.push({\n      type: 'del',\n      key: util_1.tdKey(number, hash),\n      keyEncoding: 'binary'\n    });\n    self.dbManager._cache.td.del(util_1.tdKey(number, hash));\n    if (!headHash) {\n      return cb();\n    }\n    if (hash.equals(self._headHeader)) {\n      self._headHeader = headHash;\n    }\n    if (hash.equals(self._headBlock)) {\n      self._headBlock = headHash;\n    }\n    self._getCanonicalHeader(number.addn(1), function (err, childHeader) {\n      if (err) {\n        return cb();\n      }\n      self._delChild(childHeader.hash(), new ethereumjs_util_1.BN(childHeader.number), headHash, ops, cb);\n    });\n  };\n  /**\n   * Iterates through blocks starting at the specified iterator head and calls the onBlock function\n   * on each block. The current location of an iterator head can be retrieved using the `getHead()`\n   * method.\n   *\n   * @param name - Name of the state root head\n   * @param onBlock - Function called on each block with params (block, reorg, cb)\n   * @param cb - A callback function\n   */\n  Blockchain.prototype.iterator = function (name, onBlock, cb) {\n    var _this = this;\n    // ensure init completed\n    this._initLock.await(function () {\n      _this._iterator(name, onBlock, cb);\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._iterator = function (name, func, cb) {\n    var self = this;\n    var blockHash = self._heads[name] || self._genesis;\n    var blockNumber;\n    var lastBlock;\n    if (!blockHash) {\n      return cb();\n    }\n    self._hashToNumber(blockHash, function (err, number) {\n      if (err) return cb(err);\n      blockNumber = number.addn(1);\n      async.whilst(function () {\n        return blockNumber;\n      }, run, function (err) {\n        return err ? cb(err) : self._saveHeads(cb);\n      });\n    });\n    function run(cb2) {\n      var block;\n      async.series([getBlock, runFunc], function (err) {\n        if (!err) {\n          blockNumber.iaddn(1);\n        } else {\n          blockNumber = false;\n          // No more blocks, return\n          if (err.type === 'NotFoundError') {\n            return cb2();\n          }\n        }\n        cb2(err);\n      });\n      function getBlock(cb3) {\n        self.getBlock(blockNumber, function (err, b) {\n          block = b;\n          if (block) {\n            self._heads[name] = block.hash();\n          }\n          cb3(err);\n        });\n      }\n      function runFunc(cb3) {\n        var reorg = lastBlock ? lastBlock.hash().equals(block.header.parentHash) : false;\n        lastBlock = block;\n        func(block, reorg, cb3);\n      }\n    }\n  };\n  /**\n   * Executes multiple db operations in a single batch call\n   *\n   * @hidden\n   */\n  Blockchain.prototype._batchDbOps = function (dbOps, cb) {\n    callbackify_1.callbackify(this.dbManager.batch.bind(this.dbManager))(dbOps, cb);\n  };\n  /**\n   * Performs a block hash to block number lookup\n   *\n   * @hidden\n   */\n  Blockchain.prototype._hashToNumber = function (hash, cb) {\n    callbackify_1.callbackify(this.dbManager.hashToNumber.bind(this.dbManager))(hash, cb);\n  };\n  /**\n   * Performs a block number to block hash lookup\n   *\n   * @hidden\n   */\n  Blockchain.prototype._numberToHash = function (number, cb) {\n    callbackify_1.callbackify(this.dbManager.numberToHash.bind(this.dbManager))(number, cb);\n  };\n  /**\n   * Helper function to lookup a block by either hash only or a hash and number\n   *\n   * @hidden\n   */\n  Blockchain.prototype._lookupByHashNumber = function (hash, number, cb, next) {\n    if (typeof number === 'function') {\n      cb = number;\n      return this._hashToNumber(hash, function (err, number) {\n        if (err) {\n          return next(err, hash, null, cb);\n        }\n        next(null, hash, number, cb);\n      });\n    }\n    next(null, hash, number, cb);\n  };\n  /**\n   * Gets a header by hash and number. Header can exist outside the canonical chain\n   *\n   * @hidden\n   */\n  Blockchain.prototype._getHeader = function (hash, number, cb) {\n    var _this = this;\n    this._lookupByHashNumber(hash, number, cb, function (err, hash, number, cb) {\n      if (err) {\n        return cb(err);\n      }\n      callbackify_1.callbackify(_this.dbManager.getHeader.bind(_this.dbManager))(hash, number, cb);\n    });\n  };\n  /**\n   * Gets a header by number. Header must be in the canonical chain\n   *\n   * @hidden\n   */\n  Blockchain.prototype._getCanonicalHeader = function (number, cb) {\n    var _this = this;\n    this._numberToHash(number, function (err, hash) {\n      if (err) {\n        return cb(err);\n      }\n      _this._getHeader(hash, number, cb);\n    });\n  };\n  /**\n   * Gets total difficulty for a block specified by hash and number\n   *\n   * @hidden\n   */\n  Blockchain.prototype._getTd = function (hash, number, cb) {\n    var _this = this;\n    this._lookupByHashNumber(hash, number, cb, function (err, hash, number, cb) {\n      if (err) {\n        return cb(err);\n      }\n      callbackify_1.callbackify(_this.dbManager.getTd.bind(_this.dbManager))(hash, number, cb);\n    });\n  };\n  /**\n   * @hidden\n   */\n  Blockchain.prototype._lockUnlock = function (fn, cb) {\n    var self = this;\n    this._putSemaphore.take(function () {\n      fn(after);\n      function after() {\n        self._putSemaphore.leave();\n        cb.apply(null, arguments);\n      }\n    });\n  };\n  return Blockchain;\n}();\nexports.default = Blockchain;","map":null,"metadata":{},"sourceType":"script"}