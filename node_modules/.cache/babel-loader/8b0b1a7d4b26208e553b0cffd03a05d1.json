{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar asyncLib = require('async');\nvar Tree = require('functional-red-black-tree');\nvar ethereumjs_account_1 = require(\"ethereumjs-account\");\n/**\n * @ignore\n */\nvar Cache = /** @class */function () {\n  function Cache(trie) {\n    this._cache = Tree();\n    this._checkpoints = [];\n    this._trie = trie;\n  }\n  /**\n   * Puts account to cache under its address.\n   * @param key - Address of account\n   * @param val - Account\n   */\n  Cache.prototype.put = function (key, val, fromTrie) {\n    if (fromTrie === void 0) {\n      fromTrie = false;\n    }\n    var modified = !fromTrie;\n    this._update(key, val, modified, false);\n  };\n  /**\n   * Returns the queried account or an empty account.\n   * @param key - Address of account\n   */\n  Cache.prototype.get = function (key) {\n    var account = this.lookup(key);\n    if (!account) {\n      account = new ethereumjs_account_1.default();\n    }\n    return account;\n  };\n  /**\n   * Returns the queried account or undefined.\n   * @param key - Address of account\n   */\n  Cache.prototype.lookup = function (key) {\n    var keyStr = key.toString('hex');\n    var it = this._cache.find(keyStr);\n    if (it.node) {\n      var account = new ethereumjs_account_1.default(it.value.val);\n      return account;\n    }\n  };\n  /**\n   * Looks up address in underlying trie.\n   * @param address - Address of account\n   * @param cb - Callback with params (err, account)\n   */\n  Cache.prototype._lookupAccount = function (address, cb) {\n    this._trie.get(address, function (err, raw) {\n      if (err) return cb(err);\n      var account = new ethereumjs_account_1.default(raw);\n      cb(null, account);\n    });\n  };\n  /**\n   * Looks up address in cache, if not found, looks it up\n   * in the underlying trie.\n   * @param key - Address of account\n   * @param cb - Callback with params (err, account)\n   */\n  Cache.prototype.getOrLoad = function (key, cb) {\n    var _this = this;\n    var account = this.lookup(key);\n    if (account) {\n      asyncLib.nextTick(cb, null, account);\n    } else {\n      this._lookupAccount(key, function (err, account) {\n        if (err) return cb(err);\n        _this._update(key, account, false, false);\n        cb(null, account);\n      });\n    }\n  };\n  /**\n   * Warms cache by loading their respective account from trie\n   * and putting them in cache.\n   * @param addresses - Array of addresses\n   * @param cb - Callback\n   */\n  Cache.prototype.warm = function (addresses, cb) {\n    var _this = this;\n    // shim till async supports iterators\n    var accountArr = [];\n    addresses.forEach(function (val) {\n      if (val) accountArr.push(val);\n    });\n    asyncLib.eachSeries(accountArr, function (addressHex, done) {\n      var address = Buffer.from(addressHex, 'hex');\n      _this._lookupAccount(address, function (err, account) {\n        if (err) return done(err);\n        _this._update(address, account, false, false);\n        done();\n      });\n    }, cb);\n  };\n  /**\n   * Flushes cache by updating accounts that have been modified\n   * and removing accounts that have been deleted.\n   * @param cb - Callback\n   */\n  Cache.prototype.flush = function (cb) {\n    var _this = this;\n    var it = this._cache.begin;\n    var next = true;\n    asyncLib.whilst(function () {\n      return next;\n    }, function (done) {\n      if (it.value && it.value.modified) {\n        it.value.modified = false;\n        it.value.val = it.value.val.serialize();\n        _this._trie.put(Buffer.from(it.key, 'hex'), it.value.val, function (err) {\n          if (err) return done(err);\n          next = it.hasNext;\n          it.next();\n          done();\n        });\n      } else if (it.value && it.value.deleted) {\n        it.value.modified = false;\n        it.value.deleted = false;\n        it.value.val = new ethereumjs_account_1.default().serialize();\n        _this._trie.del(Buffer.from(it.key, 'hex'), function (err) {\n          if (err) return done(err);\n          next = it.hasNext;\n          it.next();\n          done();\n        });\n      } else {\n        next = it.hasNext;\n        it.next();\n        asyncLib.nextTick(done);\n      }\n    }, cb);\n  };\n  /**\n   * Marks current state of cache as checkpoint, which can\n   * later on be reverted or commited.\n   */\n  Cache.prototype.checkpoint = function () {\n    this._checkpoints.push(this._cache);\n  };\n  /**\n   * Revert changes to cache last checkpoint (no effect on trie).\n   */\n  Cache.prototype.revert = function () {\n    this._cache = this._checkpoints.pop();\n  };\n  /**\n   * Commits to current state of cache (no effect on trie).\n   */\n  Cache.prototype.commit = function () {\n    this._checkpoints.pop();\n  };\n  /**\n   * Clears cache.\n   */\n  Cache.prototype.clear = function () {\n    this._cache = Tree();\n  };\n  /**\n   * Marks address as deleted in cache.\n   * @param key - Address\n   */\n  Cache.prototype.del = function (key) {\n    this._update(key, new ethereumjs_account_1.default(), false, true);\n  };\n  Cache.prototype._update = function (key, val, modified, deleted) {\n    var keyHex = key.toString('hex');\n    var it = this._cache.find(keyHex);\n    if (it.node) {\n      this._cache = it.update({\n        val: val,\n        modified: modified,\n        deleted: deleted\n      });\n    } else {\n      this._cache = this._cache.insert(keyHex, {\n        val: val,\n        modified: modified,\n        deleted: deleted\n      });\n    }\n  };\n  return Cache;\n}();\nexports.default = Cache;","map":null,"metadata":{},"sourceType":"script"}