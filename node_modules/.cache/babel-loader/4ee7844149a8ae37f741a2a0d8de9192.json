{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar exceptions_1 = require(\"../exceptions\");\nvar message_1 = require(\"./message\");\nvar promisify = require('util.promisify');\n/**\n * External interface made available to EVM bytecode. Modeled after\n * the ewasm EEI [spec](https://github.com/ewasm/design/blob/master/eth_interface.md).\n * It includes methods for accessing/modifying state, calling or creating contracts, access\n * to environment data among other things.\n * The EEI instance also keeps artifacts produced by the bytecode such as logs\n * and to-be-selfdestructed addresses.\n */\nvar EEI = /** @class */function () {\n  function EEI(env, state, evm, common, gasLeft) {\n    this._env = env;\n    this._state = state;\n    this._evm = evm;\n    this._lastReturned = Buffer.alloc(0);\n    this._common = common;\n    this._gasLeft = gasLeft;\n    this._result = {\n      logs: [],\n      returnValue: undefined,\n      selfdestruct: {}\n    };\n  }\n  /**\n   * Subtracts an amount from the gas counter.\n   * @param amount - Amount of gas to consume\n   * @throws if out of gas\n   */\n  EEI.prototype.useGas = function (amount) {\n    this._gasLeft.isub(amount);\n    if (this._gasLeft.ltn(0)) {\n      this._gasLeft = new BN(0);\n      trap(exceptions_1.ERROR.OUT_OF_GAS);\n    }\n  };\n  /**\n   * Adds a positive amount to the gas counter.\n   * @param amount - Amount of gas refunded\n   */\n  EEI.prototype.refundGas = function (amount) {\n    this._evm._refund.iadd(amount);\n  };\n  /**\n   * Reduces amount of gas to be refunded by a positive value.\n   * @param amount - Amount to subtract from gas refunds\n   */\n  EEI.prototype.subRefund = function (amount) {\n    this._evm._refund.isub(amount);\n    if (this._evm._refund.ltn(0)) {\n      this._evm._refund = new BN(0);\n      trap(exceptions_1.ERROR.REFUND_EXHAUSTED);\n    }\n  };\n  /**\n   * Returns address of currently executing account.\n   */\n  EEI.prototype.getAddress = function () {\n    return this._env.address;\n  };\n  /**\n   * Returns balance of the given account.\n   * @param address - Address of account\n   */\n  EEI.prototype.getExternalBalance = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // shortcut if current account\n            if (address.toString('hex') === this._env.address.toString('hex')) {\n              return [2 /*return*/, new BN(this._env.contract.balance)];\n            }\n            return [4 /*yield*/, this._state.getAccount(address)];\n          case 1:\n            account = _a.sent();\n            return [2 /*return*/, new BN(account.balance)];\n        }\n      });\n    });\n  };\n  /**\n   * Returns balance of self.\n   */\n  EEI.prototype.getSelfBalance = function () {\n    return new BN(this._env.contract.balance);\n  };\n  /**\n   * Returns caller address. This is the address of the account\n   * that is directly responsible for this execution.\n   */\n  EEI.prototype.getCaller = function () {\n    return new BN(this._env.caller);\n  };\n  /**\n   * Returns the deposited value by the instruction/transaction\n   * responsible for this execution.\n   */\n  EEI.prototype.getCallValue = function () {\n    return new BN(this._env.callValue);\n  };\n  /**\n   * Returns input data in current environment. This pertains to the input\n   * data passed with the message call instruction or transaction.\n   */\n  EEI.prototype.getCallData = function () {\n    return this._env.callData;\n  };\n  /**\n   * Returns size of input data in current environment. This pertains to the\n   * input data passed with the message call instruction or transaction.\n   */\n  EEI.prototype.getCallDataSize = function () {\n    return new BN(this._env.callData.length);\n  };\n  /**\n   * Returns the size of code running in current environment.\n   */\n  EEI.prototype.getCodeSize = function () {\n    return new BN(this._env.code.length);\n  };\n  /**\n   * Returns the code running in current environment.\n   */\n  EEI.prototype.getCode = function () {\n    return this._env.code;\n  };\n  /**\n   * Returns true if the current call must be executed statically.\n   */\n  EEI.prototype.isStatic = function () {\n    return this._env.isStatic;\n  };\n  /**\n   * Get size of an account’s code.\n   * @param address - Address of account\n   */\n  EEI.prototype.getExternalCodeSize = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addressBuf, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            addressBuf = addressToBuffer(address);\n            return [4 /*yield*/, this._state.getContractCode(addressBuf)];\n          case 1:\n            code = _a.sent();\n            return [2 /*return*/, new BN(code.length)];\n        }\n      });\n    });\n  };\n  /**\n   * Returns code of an account.\n   * @param address - Address of account\n   */\n  EEI.prototype.getExternalCode = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!Buffer.isBuffer(address)) {\n          address = addressToBuffer(address);\n        }\n        return [2 /*return*/, this._state.getContractCode(address)];\n      });\n    });\n  };\n  /**\n   * Returns size of current return data buffer. This contains the return data\n   * from the last executed call, callCode, callDelegate, callStatic or create.\n   * Note: create only fills the return data buffer in case of a failure.\n   */\n  EEI.prototype.getReturnDataSize = function () {\n    return new BN(this._lastReturned.length);\n  };\n  /**\n   * Returns the current return data buffer. This contains the return data\n   * from last executed call, callCode, callDelegate, callStatic or create.\n   * Note: create only fills the return data buffer in case of a failure.\n   */\n  EEI.prototype.getReturnData = function () {\n    return this._lastReturned;\n  };\n  /**\n   * Returns price of gas in current environment.\n   */\n  EEI.prototype.getTxGasPrice = function () {\n    return new BN(this._env.gasPrice);\n  };\n  /**\n   * Returns the execution's origination address. This is the\n   * sender of original transaction; it is never an account with\n   * non-empty associated code.\n   */\n  EEI.prototype.getTxOrigin = function () {\n    return new BN(this._env.origin);\n  };\n  /**\n   * Returns the block’s number.\n   */\n  EEI.prototype.getBlockNumber = function () {\n    return new BN(this._env.block.header.number);\n  };\n  /**\n   * Returns the block's beneficiary address.\n   */\n  EEI.prototype.getBlockCoinbase = function () {\n    return new BN(this._env.block.header.coinbase);\n  };\n  /**\n   * Returns the block's timestamp.\n   */\n  EEI.prototype.getBlockTimestamp = function () {\n    return new BN(this._env.block.header.timestamp);\n  };\n  /**\n   * Returns the block's difficulty.\n   */\n  EEI.prototype.getBlockDifficulty = function () {\n    return new BN(this._env.block.header.difficulty);\n  };\n  /**\n   * Returns the block's gas limit.\n   */\n  EEI.prototype.getBlockGasLimit = function () {\n    return new BN(this._env.block.header.gasLimit);\n  };\n  /**\n   * Returns the chain ID for current chain. Introduced for the\n   * CHAINID opcode proposed in [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344).\n   */\n  EEI.prototype.getChainId = function () {\n    return new BN(this._common.chainId());\n  };\n  /**\n   * Returns Gets the hash of one of the 256 most recent complete blocks.\n   * @param num - Number of block\n   */\n  EEI.prototype.getBlockHash = function (num) {\n    return __awaiter(this, void 0, void 0, function () {\n      var block;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, promisify(this._env.blockchain.getBlock).bind(this._env.blockchain)(num)];\n          case 1:\n            block = _a.sent();\n            return [2 /*return*/, new BN(block.hash())];\n        }\n      });\n    });\n  };\n  /**\n   * Store 256-bit a value in memory to persistent storage.\n   */\n  EEI.prototype.storageStore = function (key, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this._state.putContractStorage(this._env.address, key, value)];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._state.getAccount(this._env.address)];\n          case 2:\n            account = _a.sent();\n            this._env.contract = account;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Loads a 256-bit value to memory from persistent storage.\n   * @param key - Storage key\n   */\n  EEI.prototype.storageLoad = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._state.getContractStorage(this._env.address, key)];\n      });\n    });\n  };\n  /**\n   * Returns the current gasCounter.\n   */\n  EEI.prototype.getGasLeft = function () {\n    return this._gasLeft.clone();\n  };\n  /**\n   * Set the returning output data for the execution.\n   * @param returnData - Output data to return\n   */\n  EEI.prototype.finish = function (returnData) {\n    this._result.returnValue = returnData;\n    trap(exceptions_1.ERROR.STOP);\n  };\n  /**\n   * Set the returning output data for the execution. This will halt the\n   * execution immediately and set the execution result to \"reverted\".\n   * @param returnData - Output data to return\n   */\n  EEI.prototype.revert = function (returnData) {\n    this._result.returnValue = returnData;\n    trap(exceptions_1.ERROR.REVERT);\n  };\n  /**\n   * Mark account for later deletion and give the remaining balance to the\n   * specified beneficiary address. This will cause a trap and the\n   * execution will be aborted immediately.\n   * @param toAddress - Beneficiary address\n   */\n  EEI.prototype.selfDestruct = function (toAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._selfDestruct(toAddress)];\n      });\n    });\n  };\n  EEI.prototype._selfDestruct = function (toAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toAccount, newBalance, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // only add to refund if this is the first selfdestruct for the address\n            if (!this._result.selfdestruct[this._env.address.toString('hex')]) {\n              this.refundGas(new BN(this._common.param('gasPrices', 'selfdestructRefund')));\n            }\n            this._result.selfdestruct[this._env.address.toString('hex')] = toAddress;\n            return [4 /*yield*/, this._state.getAccount(toAddress)];\n          case 1:\n            toAccount = _a.sent();\n            newBalance = new BN(this._env.contract.balance).add(new BN(toAccount.balance));\n            toAccount.balance = ethereumjs_util_1.toBuffer(newBalance);\n            return [4 /*yield*/, this._state.putAccount(toAddress, toAccount)\n            // Subtract from contract balance\n            ];\n\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, this._state.getAccount(this._env.address)];\n          case 3:\n            account = _a.sent();\n            account.balance = ethereumjs_util_1.toBuffer(new BN(0));\n            return [4 /*yield*/, this._state.putAccount(this._env.address, account)];\n          case 4:\n            _a.sent();\n            trap(exceptions_1.ERROR.STOP);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new log in the current environment.\n   */\n  EEI.prototype.log = function (data, numberOfTopics, topics) {\n    if (numberOfTopics < 0 || numberOfTopics > 4) {\n      trap(exceptions_1.ERROR.OUT_OF_RANGE);\n    }\n    if (topics.length !== numberOfTopics) {\n      trap(exceptions_1.ERROR.INTERNAL_ERROR);\n    }\n    // add address\n    var log = [this._env.address];\n    log.push(topics);\n    // add data\n    log.push(data);\n    this._result.logs.push(log);\n  };\n  /**\n   * Sends a message with arbitrary data to a given address path.\n   */\n  EEI.prototype.call = function (gasLimit, address, value, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msg;\n      return __generator(this, function (_a) {\n        msg = new message_1.default({\n          caller: this._env.address,\n          gasLimit: gasLimit,\n          to: address,\n          value: value,\n          data: data,\n          isStatic: this._env.isStatic,\n          depth: this._env.depth + 1\n        });\n        return [2 /*return*/, this._baseCall(msg)];\n      });\n    });\n  };\n  /**\n   * Message-call into this account with an alternative account's code.\n   */\n  EEI.prototype.callCode = function (gasLimit, address, value, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msg;\n      return __generator(this, function (_a) {\n        msg = new message_1.default({\n          caller: this._env.address,\n          gasLimit: gasLimit,\n          to: this._env.address,\n          codeAddress: address,\n          value: value,\n          data: data,\n          isStatic: this._env.isStatic,\n          depth: this._env.depth + 1\n        });\n        return [2 /*return*/, this._baseCall(msg)];\n      });\n    });\n  };\n  /**\n   * Sends a message with arbitrary data to a given address path, but disallow\n   * state modifications. This includes log, create, selfdestruct and call with\n   * a non-zero value.\n   */\n  EEI.prototype.callStatic = function (gasLimit, address, value, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msg;\n      return __generator(this, function (_a) {\n        msg = new message_1.default({\n          caller: this._env.address,\n          gasLimit: gasLimit,\n          to: address,\n          value: value,\n          data: data,\n          isStatic: true,\n          depth: this._env.depth + 1\n        });\n        return [2 /*return*/, this._baseCall(msg)];\n      });\n    });\n  };\n  /**\n   * Message-call into this account with an alternative account’s code, but\n   * persisting the current values for sender and value.\n   */\n  EEI.prototype.callDelegate = function (gasLimit, address, value, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msg;\n      return __generator(this, function (_a) {\n        msg = new message_1.default({\n          caller: this._env.caller,\n          gasLimit: gasLimit,\n          to: this._env.address,\n          codeAddress: address,\n          value: value,\n          data: data,\n          isStatic: this._env.isStatic,\n          delegatecall: true,\n          depth: this._env.depth + 1\n        });\n        return [2 /*return*/, this._baseCall(msg)];\n      });\n    });\n  };\n  EEI.prototype._baseCall = function (msg) {\n    return __awaiter(this, void 0, void 0, function () {\n      var selfdestruct, results, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            selfdestruct = __assign({}, this._result.selfdestruct);\n            msg.selfdestruct = selfdestruct;\n            // empty the return data buffer\n            this._lastReturned = Buffer.alloc(0);\n            // Check if account has enough ether and max depth not exceeded\n            if (this._env.depth >= this._common.param('vm', 'stackLimit') || msg.delegatecall !== true && new BN(this._env.contract.balance).lt(msg.value)) {\n              return [2 /*return*/, new BN(0)];\n            }\n            return [4 /*yield*/, this._evm.executeMessage(msg)];\n          case 1:\n            results = _a.sent();\n            if (results.execResult.logs) {\n              this._result.logs = this._result.logs.concat(results.execResult.logs);\n            }\n            // this should always be safe\n            this.useGas(results.gasUsed);\n            // Set return value\n            if (results.execResult.returnValue && (!results.execResult.exceptionError || results.execResult.exceptionError.error === exceptions_1.ERROR.REVERT)) {\n              this._lastReturned = results.execResult.returnValue;\n            }\n            if (!!results.execResult.exceptionError) return [3 /*break*/, 3];\n            Object.assign(this._result.selfdestruct, selfdestruct);\n            return [4 /*yield*/, this._state.getAccount(this._env.address)];\n          case 2:\n            account = _a.sent();\n            this._env.contract = account;\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, this._getReturnCode(results)];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new contract with a given value.\n   */\n  EEI.prototype.create = function (gasLimit, value, data, salt) {\n    if (salt === void 0) {\n      salt = null;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var selfdestruct, msg, results, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            selfdestruct = __assign({}, this._result.selfdestruct);\n            msg = new message_1.default({\n              caller: this._env.address,\n              gasLimit: gasLimit,\n              value: value,\n              data: data,\n              salt: salt,\n              depth: this._env.depth + 1,\n              selfdestruct: selfdestruct\n            });\n            // empty the return data buffer\n            this._lastReturned = Buffer.alloc(0);\n            // Check if account has enough ether and max depth not exceeded\n            if (this._env.depth >= this._common.param('vm', 'stackLimit') || msg.delegatecall !== true && new BN(this._env.contract.balance).lt(msg.value)) {\n              return [2 /*return*/, new BN(0)];\n            }\n            this._env.contract.nonce = ethereumjs_util_1.toBuffer(new BN(this._env.contract.nonce).addn(1));\n            return [4 /*yield*/, this._state.putAccount(this._env.address, this._env.contract)];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._evm.executeMessage(msg)];\n          case 2:\n            results = _a.sent();\n            if (results.execResult.logs) {\n              this._result.logs = this._result.logs.concat(results.execResult.logs);\n            }\n            // this should always be safe\n            this.useGas(results.gasUsed);\n            // Set return buffer in case revert happened\n            if (results.execResult.exceptionError && results.execResult.exceptionError.error === exceptions_1.ERROR.REVERT) {\n              this._lastReturned = results.execResult.returnValue;\n            }\n            if (!!results.execResult.exceptionError) return [3 /*break*/, 4];\n            Object.assign(this._result.selfdestruct, selfdestruct);\n            return [4 /*yield*/, this._state.getAccount(this._env.address)];\n          case 3:\n            account = _a.sent();\n            this._env.contract = account;\n            if (results.createdAddress) {\n              // push the created address to the stack\n              return [2 /*return*/, new BN(results.createdAddress)];\n            }\n            _a.label = 4;\n          case 4:\n            return [2 /*return*/, this._getReturnCode(results)];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new contract with a given value. Generates\n   * a deterministic address via CREATE2 rules.\n   */\n  EEI.prototype.create2 = function (gasLimit, value, data, salt) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.create(gasLimit, value, data, salt)];\n      });\n    });\n  };\n  /**\n   * Returns true if account is empty (according to EIP-161).\n   * @param address - Address of account\n   */\n  EEI.prototype.isAccountEmpty = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._state.accountIsEmpty(address)];\n      });\n    });\n  };\n  EEI.prototype._getReturnCode = function (results) {\n    // This preserves the previous logic, but seems to contradict the EEI spec\n    // https://github.com/ewasm/design/blob/38eeded28765f3e193e12881ea72a6ab807a3371/eth_interface.md\n    if (results.execResult.exceptionError) {\n      return new BN(0);\n    } else {\n      return new BN(1);\n    }\n  };\n  return EEI;\n}();\nexports.default = EEI;\nfunction trap(err) {\n  throw new exceptions_1.VmError(err);\n}\nvar MASK_160 = new BN(1).shln(160).subn(1);\nfunction addressToBuffer(address) {\n  if (Buffer.isBuffer(address)) return address;\n  return address.and(MASK_160).toArrayLike(Buffer, 'be', 20);\n}","map":null,"metadata":{},"sourceType":"script"}