{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Base = void 0;\nvar buffer_1 = require(\"buffer\");\nvar crypto_js_1 = __importDefault(require(\"crypto-js\"));\nvar Base = /*#__PURE__*/function () {\n  function Base() {\n    _classCallCheck(this, Base);\n  }\n  _createClass(Base, [{\n    key: \"print\",\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    value: function print() {\n      Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n  }, {\n    key: \"bufferIndexOf\",\n    value: function bufferIndexOf(array, element) {\n      var isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (isSorted) {\n        return this.binarySearch(array, element, buffer_1.Buffer.compare);\n      }\n      var eqChecker = function eqChecker(buffer1, buffer2) {\n        return buffer1.equals(buffer2);\n      };\n      return this.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n  }, {\n    key: \"binarySearch\",\n    /**\n     * binarySearch\n     * @desc Returns the first index of which given item is found in array using binary search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} compareFunction\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.binarySearch(array, element, Buffer.compare)\n     *```\n     */\n    value: function binarySearch(array, element, compareFunction) {\n      return Base.binarySearch(array, element, compareFunction);\n    }\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n  }, {\n    key: \"linearSearch\",\n    /**\n     * linearSearch\n     * @desc Returns the first index of which given item is found in array using linear search.\n     * @param {Buffer[]} array - Array of items.\n     * @param {Buffer} element - Item to find.\n     * @param {Function} eqChecker\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.linearSearch(array, element, (a, b) => a === b)\n     *```\n     */\n    value: function linearSearch(array, element, eqChecker) {\n      return Base.linearSearch(array, element, eqChecker);\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n  }, {\n    key: \"bigNumberify\",\n    value: function bigNumberify(value) {\n      return Base.bigNumberify(value);\n    }\n  }, {\n    key: \"bufferToHex\",\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    value: function bufferToHex(value) {\n      var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n  }, {\n    key: \"bufferify\",\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    value: function bufferify(value) {\n      return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n  }, {\n    key: \"bufferifyFn\",\n    value: function bufferifyFn(f) {\n      var _this = this;\n      return function (value) {\n        var v = f(value);\n        if (buffer_1.Buffer.isBuffer(v)) {\n          return v;\n        }\n        if (_this.isHexString(v)) {\n          return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');\n        }\n        if (typeof v === 'string') {\n          return buffer_1.Buffer.from(v);\n        }\n        if (typeof v === 'bigint') {\n          return buffer_1.Buffer.from(value.toString(16), 'hex');\n        }\n        if (ArrayBuffer.isView(v)) {\n          return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n        }\n        // crypto-js support\n        return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n      };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n  }, {\n    key: \"isHexString\",\n    value: function isHexString(value) {\n      return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n  }, {\n    key: \"log2\",\n    value: function log2(n) {\n      return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n  }, {\n    key: \"zip\",\n    value: function zip(a, b) {\n      return a.map(function (e, i) {\n        return [e, b[i]];\n      });\n    }\n  }], [{\n    key: \"binarySearch\",\n    value: function binarySearch(array, element, compareFunction) {\n      var start = 0;\n      var end = array.length - 1;\n      // Iterate while start not meets end\n      while (start <= end) {\n        // Find the mid index\n        var mid = Math.floor((start + end) / 2);\n        // Check if the mid value is greater than, equal to, or less than search element.\n        var ordering = compareFunction(array[mid], element);\n        // If element is present at mid, start iterating for searching first appearance.\n        if (ordering === 0) {\n          // Linear reverse iteration until the first matching item index is found.\n          for (var i = mid - 1; i >= 0; i--) {\n            if (compareFunction(array[i], element) === 0) continue;\n            return i + 1;\n          }\n          return 0;\n        } /* Else look in left or right half accordingly */else if (ordering < 0) {\n          start = mid + 1;\n        } else {\n          end = mid - 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"linearSearch\",\n    value: function linearSearch(array, element, eqChecker) {\n      for (var i = 0; i < array.length; i++) {\n        if (eqChecker(array[i], element)) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"bufferify\",\n    value: function bufferify(value) {\n      if (!buffer_1.Buffer.isBuffer(value)) {\n        // crypto-js support\n        if (typeof value === 'object' && value.words) {\n          return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n        } else if (Base.isHexString(value)) {\n          return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');\n        } else if (typeof value === 'string') {\n          return buffer_1.Buffer.from(value);\n        } else if (typeof value === 'bigint') {\n          return buffer_1.Buffer.from(value.toString(16), 'hex');\n        } else if (value instanceof Uint8Array) {\n          return buffer_1.Buffer.from(value.buffer);\n        } else if (typeof value === 'number') {\n          var s = value.toString();\n          if (s.length % 2) {\n            s = \"0\".concat(s);\n          }\n          return buffer_1.Buffer.from(s, 'hex');\n        } else if (ArrayBuffer.isView(value)) {\n          return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n        }\n      }\n      return value;\n    }\n  }, {\n    key: \"bigNumberify\",\n    value: function bigNumberify(value) {\n      if (typeof value === 'bigint') {\n        return value;\n      }\n      if (typeof value === 'string') {\n        if (value.startsWith('0x') && Base.isHexString(value)) {\n          return BigInt('0x' + value.replace('0x', '').toString());\n        }\n        return BigInt(value);\n      }\n      if (buffer_1.Buffer.isBuffer(value)) {\n        return BigInt('0x' + value.toString('hex'));\n      }\n      if (value instanceof Uint8Array) {\n        return BigInt(value);\n      }\n      if (typeof value === 'number') {\n        return BigInt(value);\n      }\n      throw new Error('cannot bigNumberify');\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n  }, {\n    key: \"isHexString\",\n    value: function isHexString(v) {\n      return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n  }, {\n    key: \"print\",\n    value: function print(tree) {\n      console.log(tree.toString());\n    }\n  }, {\n    key: \"bufferToHex\",\n    value: function bufferToHex(value) {\n      var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return \"\".concat(withPrefix ? '0x' : '').concat((value || buffer_1.Buffer.alloc(0)).toString('hex'));\n    }\n  }, {\n    key: \"hexZeroPad\",\n    value: function hexZeroPad(hexStr, length) {\n      return '0x' + hexStr.replace('0x', '').padStart(length, '0');\n    }\n  }]);\n  return Base;\n}();\nexports.Base = Base;\nexports.default = Base;","map":null,"metadata":{},"sourceType":"script"}