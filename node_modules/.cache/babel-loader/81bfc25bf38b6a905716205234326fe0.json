{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signTypedDataUtils = void 0;\nvar ethUtil = require(\"ethereumjs-util\");\nvar ethers = require(\"ethers\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nexports.signTypedDataUtils = {\n  /**\n   * Generates the EIP712 Typed Data hash for signing\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHash: function generateTypedDataHash(typedData) {\n    return ethUtil.keccak256(Buffer.concat([Buffer.from('1901', 'hex'), exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types), exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types)]));\n  },\n  /**\n   * Generates the EIP712 Typed Data hash for a typed data object without using the domain field. This\n   * makes hashing easier for non-EIP712 data.\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHashWithoutDomain: function generateTypedDataHashWithoutDomain(typedData) {\n    return exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types);\n  },\n  /**\n   * Generates the hash of a EIP712 Domain with the default schema\n   * @param  domain An EIP712 domain with the default schema containing a name, version, chain id,\n   *                and verifying address.\n   * @return A buffer that contains the hash of the domain.\n   */\n  generateDomainHash: function generateDomainHash(domain) {\n    return exports.signTypedDataUtils._structHash('EIP712Domain', domain,\n    // HACK(jalextowle): When we consolidate our testing packages into test-utils, we can use a constant\n    // to eliminate code duplication. At the moment, there isn't a good way to do that because of cyclic-dependencies.\n    {\n      EIP712Domain: [{\n        name: 'name',\n        type: 'string'\n      }, {\n        name: 'version',\n        type: 'string'\n      }, {\n        name: 'chainId',\n        type: 'uint256'\n      }, {\n        name: 'verifyingContract',\n        type: 'address'\n      }]\n    });\n  },\n  _findDependencies: function _findDependencies(primaryType, types) {\n    var found = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (found.includes(primaryType) || types[primaryType] === undefined) {\n      return found;\n    }\n    found.push(primaryType);\n    var _iterator = _createForOfIteratorHelper(types[primaryType]),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var field = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(exports.signTypedDataUtils._findDependencies(field.type, types, found)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var dep = _step2.value;\n            if (!found.includes(dep)) {\n              found.push(dep);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return found;\n  },\n  _encodeType: function _encodeType(primaryType, types) {\n    var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n    deps = deps.filter(function (d) {\n      return d !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n    var _iterator3 = _createForOfIteratorHelper(deps),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var dep = _step3.value;\n        result += \"\".concat(dep, \"(\").concat(types[dep].map(function (_ref) {\n          var name = _ref.name,\n            type = _ref.type;\n          return \"\".concat(type, \" \").concat(name);\n        }).join(','), \")\");\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return result;\n  },\n  _encodeData: function _encodeData(primaryType, data, types) {\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n    var _iterator4 = _createForOfIteratorHelper(types[primaryType]),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var field = _step4.value;\n        var value = data[field.name];\n        if (field.type === 'string') {\n          var hashValue = ethUtil.keccak256(Buffer.from(value));\n          encodedTypes.push('bytes32');\n          encodedValues.push(hashValue);\n        } else if (field.type === 'bytes') {\n          var _hashValue = ethUtil.keccak256(ethUtil.toBuffer(value));\n          encodedTypes.push('bytes32');\n          encodedValues.push(_hashValue);\n        } else if (types[field.type] !== undefined) {\n          encodedTypes.push('bytes32');\n          var _hashValue2 = ethUtil.keccak256(\n          // tslint:disable-next-line:no-unnecessary-type-assertion\n          ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(field.type, value, types)));\n          encodedValues.push(_hashValue2);\n        } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n          throw new Error('Arrays currently unimplemented in encodeData');\n        } else {\n          encodedTypes.push(field.type);\n          var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n          encodedValues.push(normalizedValue);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n  },\n  _normalizeValue: function _normalizeValue(type, value) {\n    var STRING_BASE = 10;\n    if (type === 'uint256') {\n      if (configured_bignumber_1.BigNumber.isBigNumber(value)) {\n        return value.toString(STRING_BASE);\n      }\n      return new configured_bignumber_1.BigNumber(value).toString(STRING_BASE);\n    }\n    return value;\n  },\n  _typeHash: function _typeHash(primaryType, types) {\n    return ethUtil.keccak256(Buffer.from(exports.signTypedDataUtils._encodeType(primaryType, types)));\n  },\n  _structHash: function _structHash(primaryType, data, types) {\n    return ethUtil.keccak256(ethUtil.toBuffer(exports.signTypedDataUtils._encodeData(primaryType, data, types)));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}