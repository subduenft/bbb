{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawCalldata = void 0;\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar queue_1 = require(\"../utils/queue\");\nvar RawCalldata = /*#__PURE__*/function () {\n  function RawCalldata(value) {\n    var hasSelector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, RawCalldata);\n    // Sanity check\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    }\n    // Construct initial values\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n    this._offset = RawCalldata._INITIAL_OFFSET;\n    // If there's a selector then slice it\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n  _createClass(RawCalldata, [{\n    key: \"popBytes\",\n    value: function popBytes(lengthInBytes) {\n      var popBegin = this._offset;\n      var popEnd = popBegin + lengthInBytes;\n      if (popEnd > this._value.byteLength) {\n        throw new Error(\"Tried to decode beyond the end of calldata\");\n      }\n      var value = this._value.slice(popBegin, popEnd);\n      this.setOffset(popEnd);\n      return value;\n    }\n  }, {\n    key: \"popWord\",\n    value: function popWord() {\n      var wordInBytes = 32;\n      return this.popBytes(wordInBytes);\n    }\n  }, {\n    key: \"popWords\",\n    value: function popWords(length) {\n      var wordInBytes = 32;\n      return this.popBytes(length * wordInBytes);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(from, to) {\n      var value = this._value.slice(from, to);\n      return value;\n    }\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(offsetInBytes) {\n      this._offset = offsetInBytes;\n    }\n  }, {\n    key: \"startScope\",\n    value: function startScope() {\n      this._scopes.pushFront(this._offset);\n    }\n  }, {\n    key: \"endScope\",\n    value: function endScope() {\n      this._scopes.popFront();\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset() {\n      return this._offset;\n    }\n  }, {\n    key: \"toAbsoluteOffset\",\n    value: function toAbsoluteOffset(relativeOffset) {\n      var scopeOffset = this._scopes.peekFront();\n      if (scopeOffset === undefined) {\n        throw new Error(\"Tried to access undefined scope.\");\n      }\n      var absoluteOffset = relativeOffset + scopeOffset;\n      return absoluteOffset;\n    }\n  }, {\n    key: \"getSelector\",\n    value: function getSelector() {\n      return this._selector;\n    }\n  }, {\n    key: \"getSizeInBytes\",\n    value: function getSizeInBytes() {\n      var sizeInBytes = this._value.byteLength;\n      return sizeInBytes;\n    }\n  }]);\n  return RawCalldata;\n}();\nexports.RawCalldata = RawCalldata;\nRawCalldata._INITIAL_OFFSET = 0;","map":null,"metadata":{},"sourceType":"script"}