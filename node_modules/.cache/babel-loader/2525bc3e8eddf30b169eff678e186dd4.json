{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IncrementalMerkleTree = void 0;\nvar Base_1 = __importDefault(require(\"./Base\"));\nvar treeify_1 = __importDefault(require(\"treeify\"));\nvar IncrementalMerkleTree = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(IncrementalMerkleTree, _Base_1$default);\n  function IncrementalMerkleTree(hashFn, options) {\n    var _this;\n    _classCallCheck(this, IncrementalMerkleTree);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IncrementalMerkleTree).call(this));\n    _this.hashFn = hashFn;\n    if (options.depth) {\n      _this.depth = options.depth;\n    }\n    if (options.arity) {\n      _this.arity = options.arity;\n    }\n    if (_this.depth < 1) {\n      throw new Error('depth must be greater than 0');\n    }\n    if (_this.arity < 1) {\n      throw new Error('arity must be greater than 0');\n    }\n    var nodes = [];\n    var zeroValue = options.zeroValue;\n    _this.zeroValue = zeroValue;\n    _this.zeroes = [];\n    if (_this.depth) {\n      for (var i = 0; i < _this.depth; i++) {\n        _this.zeroes.push(zeroValue);\n        nodes[i] = [];\n        zeroValue = _this.hashFn(Array(_this.arity).fill(zeroValue));\n      }\n    }\n    _this.nodes = nodes;\n    _this.root = zeroValue;\n    return _this;\n  }\n  _createClass(IncrementalMerkleTree, [{\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.bufferify(this.getRoot()));\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(leaf) {\n      if (this.depth && this.arity) {\n        if (this.nodes[0].length >= this.getMaxLeaves()) {\n          throw new Error('tree is full');\n        }\n      }\n      var node = leaf;\n      var index = this.nodes[0].length;\n      for (var level = 0; level < this.depth; level += 1) {\n        var position = index % this.arity;\n        var levelStartIndex = index - position;\n        var levelEndIndex = levelStartIndex + this.arity;\n        var children = [];\n        this.nodes[level][index] = node;\n        for (var i = levelStartIndex; i < levelEndIndex; i += 1) {\n          if (i < this.nodes[level].length) {\n            children.push(this.nodes[level][i]);\n          } else {\n            children.push(this.zeroes[level]);\n          }\n        }\n        node = this.hashFn(children);\n        index = Math.floor(index / this.arity);\n      }\n      this.root = node;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(index) {\n      this.update(index, this.zeroValue);\n    }\n  }, {\n    key: \"update\",\n    value: function update(index, newLeaf) {\n      if (index < 0 || index >= this.nodes[0].length) {\n        throw new Error('out of bounds');\n      }\n      var node = newLeaf;\n      for (var level = 0; level < this.depth; level += 1) {\n        var position = index % this.arity;\n        var levelStartIndex = index - position;\n        var levelEndIndex = levelStartIndex + this.arity;\n        var children = [];\n        this.nodes[level][index] = node;\n        for (var i = levelStartIndex; i < levelEndIndex; i += 1) {\n          if (i < this.nodes[level].length) {\n            children.push(this.nodes[level][i]);\n          } else {\n            children.push(this.zeroes[level]);\n          }\n        }\n        node = this.hashFn(children);\n        index = Math.floor(index / this.arity);\n      }\n      this.root = node;\n    }\n  }, {\n    key: \"getDepth\",\n    value: function getDepth() {\n      return this.depth;\n    }\n  }, {\n    key: \"getArity\",\n    value: function getArity() {\n      return this.arity;\n    }\n  }, {\n    key: \"getMaxLeaves\",\n    value: function getMaxLeaves() {\n      return Math.pow(this.depth, this.arity);\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(leaf) {\n      return this.nodes[0].indexOf(leaf);\n    }\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves() {\n      var leaves = this.copyList(this.nodes[0]);\n      var index = this.nodes[0].length;\n      for (var i = index; i < this.getMaxLeaves(); i++) {\n        leaves[i] = this.zeroValue;\n      }\n      return leaves;\n    }\n  }, {\n    key: \"copyList\",\n    value: function copyList(list) {\n      return list.map(function (x) {\n        return BigInt(x);\n      });\n    }\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var layers = [];\n      var _iterator = _createForOfIteratorHelper(this.nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var list = _step.value;\n          layers.push(this.copyList(list));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (layers[0].length < this.getMaxLeaves()) {\n        var index = layers[0].length;\n        for (var i = index; i < this.getMaxLeaves(); i++) {\n          layers[0][i] = this.zeroValue;\n        }\n        for (var level = 0; level < this.depth; level++) {\n          var position = index % this.arity;\n          var levelStartIndex = index - position;\n          var levelEndIndex = levelStartIndex + this.arity;\n          for (var _i = levelStartIndex; _i < levelEndIndex; _i++) {\n            if (_i >= layers[level].length) {\n              layers[level][_i] = this.zeroes[level];\n            }\n          }\n          index = Math.floor(index / this.arity);\n        }\n      }\n      layers.push([this.root]);\n      return layers;\n    }\n  }, {\n    key: \"getHexLayers\",\n    value: function getHexLayers() {\n      var _this2 = this;\n      return this.getLayers().reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.push(item.map(function (layer) {\n            return _this2.bufferToHex(_this2.bufferify(layer));\n          }));\n        } else {\n          acc.push(item);\n        }\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"getLayersAsObject\",\n    value: function getLayersAsObject() {\n      var _this3 = this;\n      var layers = this.getLayers().map(function (layer) {\n        return layer.map(function (value) {\n          return _this3.bufferToHex(_this3.bufferify(value), false);\n        });\n      });\n      var objs = [];\n      for (var i = 0; i < layers.length; i++) {\n        var arr = [];\n        for (var j = 0; j < layers[i].length; j++) {\n          var obj = _defineProperty({}, layers[i][j], null);\n          if (objs.length) {\n            obj[layers[i][j]] = {};\n            var a = objs.shift();\n            var akey = Object.keys(a)[0];\n            obj[layers[i][j]][akey] = a[akey];\n            if (objs.length) {\n              var b = objs.shift();\n              var bkey = Object.keys(b)[0];\n              obj[layers[i][j]][bkey] = b[bkey];\n            }\n          }\n          arr.push(obj);\n        }\n        objs.push.apply(objs, arr);\n      }\n      return objs[0];\n    }\n  }, {\n    key: \"computeRoot\",\n    value: function computeRoot() {\n      var node;\n      var index = this.nodes[0].length;\n      for (var level = 0; level < this.depth; level += 1) {\n        var position = index % this.arity;\n        var levelStartIndex = index - position;\n        var levelEndIndex = levelStartIndex + this.arity;\n        var children = [];\n        for (var i = levelStartIndex; i < levelEndIndex; i += 1) {\n          if (i < this.nodes[level].length) {\n            children.push(this.nodes[level][i]);\n          } else {\n            children.push(this.zeroes[level]);\n          }\n        }\n        node = this.hashFn(children);\n        index = Math.floor(index / this.arity);\n      }\n      return node;\n    }\n  }, {\n    key: \"getProof\",\n    value: function getProof(index) {\n      if (index < 0 || index >= this.nodes[0].length) {\n        throw new Error('The leaf does not exist in this tree');\n      }\n      var siblings = [];\n      var pathIndices = [];\n      var leafIndex = index;\n      for (var level = 0; level < this.depth; level += 1) {\n        var position = index % this.arity;\n        var levelStartIndex = index - position;\n        var levelEndIndex = levelStartIndex + this.arity;\n        pathIndices[level] = position;\n        siblings[level] = [];\n        for (var i = levelStartIndex; i < levelEndIndex; i += 1) {\n          if (i !== index) {\n            if (i < this.nodes[level].length) {\n              siblings[level].push(this.nodes[level][i]);\n            } else {\n              siblings[level].push(this.zeroes[level]);\n            }\n          }\n        }\n        index = Math.floor(index / this.arity);\n      }\n      return {\n        root: this.root,\n        leaf: this.nodes[0][leafIndex],\n        pathIndices: pathIndices,\n        siblings: siblings\n      };\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(proof) {\n      var node = proof.leaf;\n      for (var i = 0; i < proof.siblings.length; i += 1) {\n        var children = proof.siblings[i].slice();\n        children.splice(proof.pathIndices[i], 0, node);\n        node = this.hashFn(children);\n      }\n      return proof.root === node;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toTreeString();\n    }\n  }, {\n    key: \"toTreeString\",\n    value: function toTreeString() {\n      var obj = this.getLayersAsObject();\n      return treeify_1.default.asTree(obj, true);\n    }\n  }]);\n  return IncrementalMerkleTree;\n}(Base_1.default);\nexports.IncrementalMerkleTree = IncrementalMerkleTree;\nif (typeof window !== 'undefined') {\n  ;\n  window.IncrementalMerkleTree = IncrementalMerkleTree;\n}\nexports.default = IncrementalMerkleTree;","map":null,"metadata":{},"sourceType":"script"}