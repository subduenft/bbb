{"ast":null,"code":"/* Copyright (c) 2012-2016 LevelUP contributors\n * See list at <https://github.com/level/levelup#contributing>\n * MIT License\n * <https://github.com/level/levelup/blob/master/LICENSE.md>\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar deprecate = require('util').deprecate;\nvar extend = require('xtend');\nvar prr = require('prr');\nvar DeferredLevelDOWN = require('deferred-leveldown');\nvar IteratorStream = require('level-iterator-stream');\nvar Batch = require('./batch');\nvar Codec = require('level-codec');\nvar getLevelDOWN = require('./leveldown');\nvar errors = require('level-errors');\nvar util = require('./util');\nvar WriteError = errors.WriteError;\nvar ReadError = errors.ReadError;\nvar NotFoundError = errors.NotFoundError;\nvar OpenError = errors.OpenError;\nvar EncodingError = errors.EncodingError;\nvar InitializationError = errors.InitializationError;\nvar LevelUPError = errors.LevelUPError;\nvar getOptions = util.getOptions;\nvar defaultOptions = util.defaultOptions;\nvar dispatchError = util.dispatchError;\nfunction getCallback(options, callback) {\n  return typeof options === 'function' ? options : callback;\n}\n\n// Possible LevelUP#_status values:\n//  - 'new'     - newly created, not opened or closed\n//  - 'opening' - waiting for the database to be opened, post open()\n//  - 'open'    - successfully opened the database, available for use\n//  - 'closing' - waiting for the database to be closed, post close()\n//  - 'closed'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\nfunction LevelUP(location, options, callback) {\n  if (!(this instanceof LevelUP)) {\n    return new LevelUP(location, options, callback);\n  }\n  var error;\n  EventEmitter.call(this);\n  this.setMaxListeners(Infinity);\n  if (typeof location === 'function') {\n    options = typeof options === 'object' ? options : {};\n    options.db = location;\n    location = null;\n  } else if (typeof location === 'object' && typeof location.db === 'function') {\n    options = location;\n    location = null;\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if ((!options || typeof options.db !== 'function') && typeof location !== 'string') {\n    error = new InitializationError('Must provide a location for the database');\n    if (callback) {\n      return process.nextTick(function () {\n        callback(error);\n      });\n    }\n    throw error;\n  }\n  options = getOptions(options);\n  this.options = extend(defaultOptions, options);\n  this._codec = new Codec(this.options);\n  this._status = 'new';\n  // set this.location as enumerable but not configurable or writable\n  prr(this, 'location', location, 'e');\n  this.open(callback);\n}\ninherits(LevelUP, EventEmitter);\nLevelUP.prototype.open = function (callback) {\n  var self = this;\n  var dbFactory;\n  var db;\n  if (this.isOpen()) {\n    if (callback) {\n      process.nextTick(function () {\n        callback(null, self);\n      });\n    }\n    return this;\n  }\n  if (this._isOpening()) {\n    return callback && this.once('open', function () {\n      callback(null, self);\n    });\n  }\n  this.emit('opening');\n  this._status = 'opening';\n  this.db = new DeferredLevelDOWN(this.location);\n  if (typeof this.options.db !== 'function' && typeof getLevelDOWN !== 'function') {\n    throw new LevelUPError('missing db factory, you need to set options.db');\n  }\n  dbFactory = this.options.db || getLevelDOWN();\n  db = dbFactory(this.location);\n  db.open(this.options, function (err) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback);\n    }\n    self.db.setDb(db);\n    self.db = db;\n    self._status = 'open';\n    if (callback) {\n      callback(null, self);\n    }\n    self.emit('open');\n    self.emit('ready');\n  });\n};\nLevelUP.prototype.close = function (callback) {\n  var self = this;\n  if (this.isOpen()) {\n    this._status = 'closing';\n    this.db.close(function () {\n      self._status = 'closed';\n      self.emit('closed');\n      if (callback) {\n        callback.apply(null, arguments);\n      }\n    });\n    this.emit('closing');\n    this.db = new DeferredLevelDOWN(this.location);\n  } else if (this._status === 'closed' && callback) {\n    return process.nextTick(callback);\n  } else if (this._status === 'closing' && callback) {\n    this.once('closed', callback);\n  } else if (this._isOpening()) {\n    this.once('open', function () {\n      self.close(callback);\n    });\n  }\n};\nLevelUP.prototype.isOpen = function () {\n  return this._status === 'open';\n};\nLevelUP.prototype._isOpening = function () {\n  return this._status === 'opening';\n};\nLevelUP.prototype.isClosed = function () {\n  return /^clos/.test(this._status);\n};\nfunction maybeError(db, options, callback) {\n  if (!db._isOpening() && !db.isOpen()) {\n    dispatchError(db, new ReadError('Database is not open'), callback);\n    return true;\n  }\n}\nfunction writeError(db, message, callback) {\n  dispatchError(db, new WriteError(message), callback);\n}\nfunction readError(db, message, callback) {\n  dispatchError(db, new ReadError(message), callback);\n}\nLevelUP.prototype.get = function (key_, options, callback) {\n  var self = this;\n  var key;\n  callback = getCallback(options, callback);\n  if (maybeError(this, options, callback)) {\n    return;\n  }\n  if (key_ === null || key_ === undefined || typeof callback !== 'function') {\n    return readError(this, 'get() requires key and callback arguments', callback);\n  }\n  options = util.getOptions(options);\n  key = this._codec.encodeKey(key_, options);\n  options.asBuffer = this._codec.valueAsBuffer(options);\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if (/notfound/i.test(err) || err.notFound) {\n        err = new NotFoundError('Key not found in database [' + key_ + ']', err);\n      } else {\n        err = new ReadError(err);\n      }\n      return dispatchError(self, err, callback);\n    }\n    if (callback) {\n      try {\n        value = self._codec.decodeValue(value, options);\n      } catch (e) {\n        return callback(new EncodingError(e));\n      }\n      callback(null, value);\n    }\n  });\n};\nLevelUP.prototype.put = function (key_, value_, options, callback) {\n  var self = this;\n  var key;\n  var value;\n  callback = getCallback(options, callback);\n  if (key_ === null || key_ === undefined) {\n    return writeError(this, 'put() requires a key argument', callback);\n  }\n  if (maybeError(this, options, callback)) {\n    return;\n  }\n  options = getOptions(options);\n  key = this._codec.encodeKey(key_, options);\n  value = this._codec.encodeValue(value_, options);\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    }\n    self.emit('put', key_, value_);\n    if (callback) {\n      callback();\n    }\n  });\n};\nLevelUP.prototype.del = function (key_, options, callback) {\n  var self = this;\n  var key;\n  callback = getCallback(options, callback);\n  if (key_ === null || key_ === undefined) {\n    return writeError(this, 'del() requires a key argument', callback);\n  }\n  if (maybeError(this, options, callback)) {\n    return;\n  }\n  options = getOptions(options);\n  key = this._codec.encodeKey(key_, options);\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    }\n    self.emit('del', key_);\n    if (callback) {\n      callback();\n    }\n  });\n};\nLevelUP.prototype.batch = function (arr_, options, callback) {\n  var self = this;\n  var arr;\n  if (!arguments.length) {\n    return new Batch(this, this._codec);\n  }\n  callback = getCallback(options, callback);\n  if (!Array.isArray(arr_)) {\n    return writeError(this, 'batch() requires an array argument', callback);\n  }\n  if (maybeError(this, options, callback)) {\n    return;\n  }\n  options = getOptions(options);\n  arr = self._codec.encodeBatch(arr_, options);\n  arr = arr.map(function (op) {\n    if (!op.type && op.key !== undefined && op.value !== undefined) {\n      op.type = 'put';\n    }\n    return op;\n  });\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return dispatchError(self, new WriteError(err), callback);\n    }\n    self.emit('batch', arr_);\n    if (callback) {\n      callback();\n    }\n  });\n};\nLevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {\n  var self = this;\n  var start;\n  var end;\n  callback = getCallback(options, callback);\n  options = getOptions(options);\n  if (start_ === null || start_ === undefined || end_ === null || end_ === undefined || typeof callback !== 'function') {\n    return readError(this, 'approximateSize() requires start, end and callback arguments', callback);\n  }\n  start = this._codec.encodeKey(start_, options);\n  end = this._codec.encodeKey(end_, options);\n  this.db.approximateSize(start, end, function (err, size) {\n    if (err) {\n      return dispatchError(self, new OpenError(err), callback);\n    } else if (callback) {\n      callback(null, size);\n    }\n  });\n}, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead');\nLevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function (options) {\n  options = extend({\n    keys: true,\n    values: true\n  }, this.options, options);\n  options.keyEncoding = options.keyEncoding;\n  options.valueEncoding = options.valueEncoding;\n  options = this._codec.encodeLtgt(options);\n  options.keyAsBuffer = this._codec.keyAsBuffer(options);\n  options.valueAsBuffer = this._codec.valueAsBuffer(options);\n  if (typeof options.limit !== 'number') {\n    options.limit = -1;\n  }\n  return new IteratorStream(this.db.iterator(options), extend(options, {\n    decoder: this._codec.createStreamDecoder(options)\n  }));\n};\nLevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(extend(options, {\n    keys: true,\n    values: false\n  }));\n};\nLevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(extend(options, {\n    keys: false,\n    values: true\n  }));\n};\nLevelUP.prototype.toString = function () {\n  return 'LevelUP';\n};\nfunction utilStatic(name) {\n  return function (location, callback) {\n    getLevelDOWN()[name](location, callback || function () {});\n  };\n}\nmodule.exports = LevelUP;\nmodule.exports.errors = require('level-errors');\nmodule.exports.destroy = deprecate(utilStatic('destroy'), 'levelup.destroy() is deprecated. Use leveldown.destroy() instead');\nmodule.exports.repair = deprecate(utilStatic('repair'), 'levelup.repair() is deprecated. Use leveldown.repair() instead');","map":null,"metadata":{},"sourceType":"script"}