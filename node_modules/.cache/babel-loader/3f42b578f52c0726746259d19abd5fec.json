{"ast":null,"code":"var rlp = require('rlp');\nvar ethUtil = require('ethereumjs-util');\nmodule.exports = TrieNode;\nfunction TrieNode(type, key, value) {\n  if (Array.isArray(type)) {\n    // parse raw node\n    this.parseNode(type);\n  } else {\n    this.type = type;\n    if (type === 'branch') {\n      var values = key;\n      this.raw = Array.apply(null, Array(17));\n      if (values) {\n        values.forEach(function (keyVal) {\n          this.set.apply(this, keyVal);\n        });\n      }\n    } else {\n      this.raw = Array(2);\n      this.setValue(value);\n      this.setKey(key);\n    }\n  }\n}\nTrieNode.isRawNode = isRawNode;\nTrieNode.addHexPrefix = addHexPrefix;\nTrieNode.removeHexPrefix = removeHexPrefix;\nTrieNode.isTerminator = isTerminator;\nTrieNode.stringToNibbles = stringToNibbles;\nTrieNode.nibblesToBuffer = nibblesToBuffer;\nTrieNode.getNodeType = getNodeType;\nObject.defineProperty(TrieNode.prototype, 'value', {\n  get: function get() {\n    return this.getValue();\n  },\n  set: function set(v) {\n    this.setValue(v);\n  }\n});\nObject.defineProperty(TrieNode.prototype, 'key', {\n  get: function get() {\n    return this.getKey();\n  },\n  set: function set(k) {\n    this.setKey(k);\n  }\n});\n\n// parses a raw node\nTrieNode.prototype.parseNode = function (rawNode) {\n  this.raw = rawNode;\n  this.type = getNodeType(rawNode);\n};\n\n// sets the value of the node\nTrieNode.prototype.setValue = function (key, value) {\n  if (this.type !== 'branch') {\n    this.raw[1] = key;\n  } else {\n    if (arguments.length === 1) {\n      value = key;\n      key = 16;\n    }\n    this.raw[key] = value;\n  }\n};\nTrieNode.prototype.getValue = function (key) {\n  if (this.type === 'branch') {\n    if (arguments.length === 0) {\n      key = 16;\n    }\n    var val = this.raw[key];\n    if (val !== null && val !== undefined && val.length !== 0) {\n      return val;\n    }\n  } else {\n    return this.raw[1];\n  }\n};\nTrieNode.prototype.setKey = function (key) {\n  if (this.type !== 'branch') {\n    if (Buffer.isBuffer(key)) {\n      key = stringToNibbles(key);\n    } else {\n      key = key.slice(0); // copy the key\n    }\n\n    key = addHexPrefix(key, this.type === 'leaf');\n    this.raw[0] = nibblesToBuffer(key);\n  }\n};\n\n// returns the key as a nibble\nTrieNode.prototype.getKey = function () {\n  if (this.type !== 'branch') {\n    var key = this.raw[0];\n    key = removeHexPrefix(stringToNibbles(key));\n    return key;\n  }\n};\nTrieNode.prototype.serialize = function () {\n  return rlp.encode(this.raw);\n};\nTrieNode.prototype.hash = function () {\n  return ethUtil.sha3(this.serialize());\n};\nTrieNode.prototype.toString = function () {\n  var out = this.type;\n  out += ': [';\n  this.raw.forEach(function (el) {\n    if (Buffer.isBuffer(el)) {\n      out += el.toString('hex') + ', ';\n    } else if (el) {\n      out += 'object, ';\n    } else {\n      out += 'empty, ';\n    }\n  });\n  out = out.slice(0, -2);\n  out += ']';\n  return out;\n};\nTrieNode.prototype.getChildren = function () {\n  var children = [];\n  switch (this.type) {\n    case 'leaf':\n      // no children\n      break;\n    case 'extention':\n      // one child\n      children.push([this.key, this.getValue()]);\n      break;\n    case 'branch':\n      for (var index = 0, end = 16; index < end; index++) {\n        var value = this.getValue(index);\n        if (value) {\n          children.push([[index], value]);\n        }\n      }\n      break;\n  }\n  return children;\n};\n\n/**\n * @param {Array} dataArr\n * @returns {Buffer} - returns buffer of encoded data\n * hexPrefix\n **/\nfunction addHexPrefix(key, terminator) {\n  // odd\n  if (key.length % 2) {\n    key.unshift(1);\n  } else {\n    // even\n    key.unshift(0);\n    key.unshift(0);\n  }\n  if (terminator) {\n    key[0] += 2;\n  }\n  return key;\n}\nfunction removeHexPrefix(val) {\n  if (val[0] % 2) {\n    val = val.slice(1);\n  } else {\n    val = val.slice(2);\n  }\n  return val;\n}\n\n/**\n * Determines if a key has Arnold Schwarzenegger in it.\n * @method isTerminator\n * @param {Array} key - an hexprefixed array of nibbles\n */\nfunction isTerminator(key) {\n  return key[0] > 1;\n}\n\n/**\n * Converts a string OR a buffer to a nibble array.\n * @method stringToNibbles\n * @param {Buffer| String} key\n */\nfunction stringToNibbles(key) {\n  var bkey = new Buffer(key);\n  var nibbles = [];\n  for (var i = 0; i < bkey.length; i++) {\n    var q = i * 2;\n    nibbles[q] = bkey[i] >> 4;\n    ++q;\n    nibbles[q] = bkey[i] % 16;\n  }\n  return nibbles;\n}\n\n/**\n * Converts a nibble array into a buffer.\n * @method nibblesToBuffer\n * @param arr\n */\nfunction nibblesToBuffer(arr) {\n  var buf = new Buffer(arr.length / 2);\n  for (var i = 0; i < buf.length; i++) {\n    var q = i * 2;\n    buf[i] = (arr[q] << 4) + arr[++q];\n  }\n  return buf;\n}\n\n/**\n * Determines the node type.\n * @returns {String} - the node type\n *   - leaf - if the node is a leaf\n *   - branch - if the node is a branch\n *   - extention - if the node is an extention\n *   - unknown - if something else got borked\n */\nfunction getNodeType(node) {\n  if (node.length === 17) {\n    return 'branch';\n  } else if (node.length === 2) {\n    var key = stringToNibbles(node[0]);\n    if (isTerminator(key)) {\n      return 'leaf';\n    }\n    return 'extention';\n  }\n}\nfunction isRawNode(node) {\n  return Array.isArray(node) && !Buffer.isBuffer(node);\n}","map":null,"metadata":{},"sourceType":"script"}