{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3Wrapper = void 0;\nvar assert_1 = require(\"@0x/assert\");\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar marshaller_1 = require(\"./marshaller\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nvar Web3Wrapper = /*#__PURE__*/function () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider) {\n    var callAndTxnDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Web3Wrapper);\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n  _createClass(Web3Wrapper, [{\n    key: \"getContractDefaults\",\n    /**\n     * Get the contract defaults set to the Web3Wrapper instance\n     * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n     */\n    value: function getContractDefaults() {\n      return this._callAndTxnDefaults;\n    }\n    /**\n     * Retrieve the Web3 provider\n     * @return  Web3 provider instance\n     */\n  }, {\n    key: \"getProvider\",\n    value: function getProvider() {\n      return this._supportedProvider;\n    }\n    /**\n     * Update the used Web3 provider\n     * @param provider The new Web3 provider to be set\n     */\n  }, {\n    key: \"setProvider\",\n    value: function setProvider(supportedProvider) {\n      var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n      this._provider = provider;\n    }\n    /**\n     * Check whether an address is available through the backing provider. This can be\n     * useful if you want to know whether a user can sign messages or transactions from\n     * a given Ethereum address.\n     * @param senderAddress Address to check availability for\n     * @returns Whether the address is available through the provider.\n     */\n  }, {\n    key: \"isSenderAddressAvailableAsync\",\n    value: function isSenderAddressAvailableAsync(senderAddress) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var addresses, normalizedAddress;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n              _context.next = 3;\n              return this.getAvailableAddressesAsync();\n            case 3:\n              addresses = _context.sent;\n              normalizedAddress = senderAddress.toLowerCase();\n              return _context.abrupt(\"return\", _.includes(addresses, normalizedAddress));\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n     * @returns Ethereum node's version string\n     */\n  }, {\n    key: \"getNodeVersionAsync\",\n    value: function getNodeVersionAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var nodeVersion;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'web3_clientVersion'\n              });\n            case 2:\n              nodeVersion = _context2.sent;\n              return _context2.abrupt(\"return\", nodeVersion);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Fetches the networkId of the backing Ethereum node\n     * @returns The network id\n     */\n  }, {\n    key: \"getNetworkIdAsync\",\n    value: function getNetworkIdAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var networkIdStr, networkId;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'net_version'\n              });\n            case 2:\n              networkIdStr = _context3.sent;\n              networkId = _.parseInt(networkIdStr);\n              return _context3.abrupt(\"return\", networkId);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Fetches the chainId of the backing Ethereum node\n     * @returns The chain id\n     */\n  }, {\n    key: \"getChainIdAsync\",\n    value: function getChainIdAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var chainIdStr, chainId;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_chainId'\n              });\n            case 2:\n              chainIdStr = _context4.sent;\n              chainId = _.parseInt(chainIdStr);\n              return _context4.abrupt(\"return\", chainId);\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Fetch the current gas price.\n     * For post-London hardfork chains, this will be baseFeePerGas + maxPriorityFeePerGas\n     */\n  }, {\n    key: \"getGasPriceAsync\",\n    value: function getGasPriceAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var gasPriceStr;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_gasPrice'\n              });\n            case 2:\n              gasPriceStr = _context5.sent;\n              return _context5.abrupt(\"return\", new utils_1.BigNumber(gasPriceStr));\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Fetch the base fee per gas for the pending block.\n     */\n  }, {\n    key: \"getBaseFeePerGasAsync\",\n    value: function getBaseFeePerGasAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var rawBlock, baseFeePerGas;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getBlockByNumber',\n                params: ['pending', false]\n              });\n            case 2:\n              rawBlock = _context6.sent;\n              baseFeePerGas = rawBlock.baseFeePerGas;\n              return _context6.abrupt(\"return\", new utils_1.BigNumber(baseFeePerGas || 0));\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Fetch the current max piority fee per gas. This is the suggested miner tip\n     * to get mined in the current block.\n     */\n  }, {\n    key: \"getMaxPriorityFeePerGasAsync\",\n    value: function getMaxPriorityFeePerGasAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var feeStr;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_maxPriorityFeePerGas'\n              });\n            case 2:\n              feeStr = _context7.sent;\n              return _context7.abrupt(\"return\", new utils_1.BigNumber(feeStr));\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Retrieves the transaction receipt for a given transaction hash if found\n     * @param txHash Transaction hash\n     * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n     */\n  }, {\n    key: \"getTransactionReceiptIfExistsAsync\",\n    value: function getTransactionReceiptIfExistsAsync(txHash) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var transactionReceiptRpc, transactionReceipt;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              assert_1.assert.isHexString('txHash', txHash);\n              _context8.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getTransactionReceipt',\n                params: [txHash]\n              });\n            case 3:\n              transactionReceiptRpc = _context8.sent;\n              if (!(transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null)) {\n                _context8.next = 10;\n                break;\n              }\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return _context8.abrupt(\"return\", transactionReceipt);\n            case 10:\n              return _context8.abrupt(\"return\", undefined);\n            case 11:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Retrieves the transaction data for a given transaction\n     * @param txHash Transaction hash\n     * @returns The raw transaction data\n     */\n  }, {\n    key: \"getTransactionByHashAsync\",\n    value: function getTransactionByHashAsync(txHash) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var transactionRpc, transaction;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              assert_1.assert.isHexString('txHash', txHash);\n              _context9.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getTransactionByHash',\n                params: [txHash]\n              });\n            case 3:\n              transactionRpc = _context9.sent;\n              transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n              return _context9.abrupt(\"return\", transaction);\n            case 6:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Retrieves an accounts Ether balance in wei\n     * @param owner Account whose balance you wish to check\n     * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n     * @returns Balance in wei\n     */\n  }, {\n    key: \"getBalanceInWeiAsync\",\n    value: function getBalanceInWeiAsync(owner, defaultBlock) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var marshalledDefaultBlock, encodedOwner, balanceInWei;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('owner', owner);\n              if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n              }\n              marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n              encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n              _context10.next = 6;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getBalance',\n                params: [encodedOwner, marshalledDefaultBlock]\n              });\n            case 6:\n              balanceInWei = _context10.sent;\n              return _context10.abrupt(\"return\", new utils_1.BigNumber(balanceInWei));\n            case 8:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Check if a contract exists at a given address\n     * @param address Address to which to check\n     * @returns Whether or not contract code was found at the supplied address\n     */\n  }, {\n    key: \"doesContractExistAtAddressAsync\",\n    value: function doesContractExistAtAddressAsync(address) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var code, isCodeEmpty;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('address', address);\n              _context11.next = 3;\n              return this.getContractCodeAsync(address);\n            case 3:\n              code = _context11.sent;\n              // Regex matches 0x0, 0x00, 0x in order to accommodate poorly implemented clients\n              isCodeEmpty = /^0x0{0,40}$/i.test(code);\n              return _context11.abrupt(\"return\", !isCodeEmpty);\n            case 6:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\n     * Gets the contract code by address\n     * @param  address Address of the contract\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @return Code of the contract\n     */\n  }, {\n    key: \"getContractCodeAsync\",\n    value: function getContractCodeAsync(address, defaultBlock) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var marshalledDefaultBlock, encodedAddress, code;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('address', address);\n              if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n              }\n              marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n              encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n              _context12.next = 6;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getCode',\n                params: [encodedAddress, marshalledDefaultBlock]\n              });\n            case 6:\n              code = _context12.sent;\n              return _context12.abrupt(\"return\", code);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n    }\n    /**\n     * Gets the debug trace of a transaction\n     * @param  txHash Hash of the transactuon to get a trace for\n     * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n     * @return Transaction trace\n     */\n  }, {\n    key: \"getTransactionTraceAsync\",\n    value: function getTransactionTraceAsync(txHash, traceParams) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var trace;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              assert_1.assert.isHexString('txHash', txHash);\n              _context13.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'debug_traceTransaction',\n                params: [txHash, traceParams]\n              });\n            case 3:\n              trace = _context13.sent;\n              return _context13.abrupt(\"return\", trace);\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n    }\n    /**\n     * Sign a message with a specific address's private key (`eth_sign`)\n     * @param address Address of signer\n     * @param message Message to sign\n     * @returns Signature string (might be VRS or RSV depending on the Signer)\n     */\n  }, {\n    key: \"signMessageAsync\",\n    value: function signMessageAsync(address, message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var signData;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('address', address);\n              assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n              _context14.next = 4;\n              return this.sendRawPayloadAsync({\n                method: 'eth_sign',\n                params: [address, message]\n              });\n            case 4:\n              signData = _context14.sent;\n              return _context14.abrupt(\"return\", signData);\n            case 6:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n     * @param address Address of signer\n     * @param typedData Typed data message to sign\n     * @returns Signature string (as RSV)\n     */\n  }, {\n    key: \"signTypedDataAsync\",\n    value: function signTypedDataAsync(address, typedData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var methodsToTry, lastErr, _i, _methodsToTry, method;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('address', address);\n              assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n              // Try decreasing versions of `eth_signTypedData` until it works.\n              methodsToTry = ['eth_signTypedData_v4', 'eth_signTypedData_v3', 'eth_signTypedData'];\n              _i = 0, _methodsToTry = methodsToTry;\n            case 4:\n              if (!(_i < _methodsToTry.length)) {\n                _context15.next = 20;\n                break;\n              }\n              method = _methodsToTry[_i];\n              _context15.prev = 6;\n              _context15.next = 9;\n              return this.sendRawPayloadAsync({\n                method: method,\n                // `eth_signTypedData` expects an object, whereas the others expect\n                // a JSON string.\n                params: [address, method === 'eth_signTypedData' ? typedData : JSON.stringify(typedData)]\n              });\n            case 9:\n              return _context15.abrupt(\"return\", _context15.sent);\n            case 12:\n              _context15.prev = 12;\n              _context15.t0 = _context15[\"catch\"](6);\n              lastErr = _context15.t0;\n              // If there are no more methods to try or the error says something other\n              // than the method not existing, throw.\n              if (/(not handled|does not exist|not supported)/.test(_context15.t0.message)) {\n                _context15.next = 17;\n                break;\n              }\n              throw _context15.t0;\n            case 17:\n              _i++;\n              _context15.next = 4;\n              break;\n            case 20:\n              throw lastErr;\n            case 21:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this, [[6, 12]]);\n      }));\n    }\n    /**\n     * Fetches the latest block number\n     * @returns Block number\n     */\n  }, {\n    key: \"getBlockNumberAsync\",\n    value: function getBlockNumberAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var blockNumberHex, blockNumber;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_blockNumber',\n                params: []\n              });\n            case 2:\n              blockNumberHex = _context16.sent;\n              blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n              return _context16.abrupt(\"return\", blockNumber);\n            case 5:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Fetches the nonce for an account (transaction count for EOAs).\n     * @param address Address of account.\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns Account nonce.\n     */\n  }, {\n    key: \"getAccountNonceAsync\",\n    value: function getAccountNonceAsync(address, defaultBlock) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var marshalledDefaultBlock, encodedAddress, nonceHex;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              assert_1.assert.isETHAddressHex('address', address);\n              if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n              }\n              marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n              encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n              _context17.next = 6;\n              return this.sendRawPayloadAsync({\n                method: 'eth_getTransactionCount',\n                params: [encodedAddress, marshalledDefaultBlock]\n              });\n            case 6:\n              nonceHex = _context17.sent;\n              assert_1.assert.isHexString('nonce', nonceHex);\n              // tslint:disable-next-line:custom-no-magic-numbers\n              return _context17.abrupt(\"return\", parseInt(nonceHex.substr(2), 16));\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\n     * Fetch a specific Ethereum block without transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block without transaction data, or undefined if block was not found\n     * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n     */\n  }, {\n    key: \"getBlockIfExistsAsync\",\n    value: function getBlockIfExistsAsync(blockParam) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              Web3Wrapper._assertBlockParamOrString(blockParam);\n              encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n              method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n              shouldIncludeTransactionData = false;\n              _context18.next = 6;\n              return this.sendRawPayloadAsync({\n                method: method,\n                params: [encodedBlockParam, shouldIncludeTransactionData]\n              });\n            case 6:\n              blockWithoutTransactionDataWithHexValuesOrNull = _context18.sent;\n              if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n                blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n              }\n              return _context18.abrupt(\"return\", blockWithoutTransactionDataIfExists);\n            case 9:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n    }\n    /**\n     * Fetch a specific Ethereum block with transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block with transaction data\n     */\n  }, {\n    key: \"getBlockWithTransactionDataAsync\",\n    value: function getBlockWithTransactionDataAsync(blockParam) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              Web3Wrapper._assertBlockParamOrString(blockParam);\n              encodedBlockParam = blockParam;\n              if (_.isNumber(blockParam)) {\n                encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n              }\n              method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n              shouldIncludeTransactionData = true;\n              _context19.next = 7;\n              return this.sendRawPayloadAsync({\n                method: method,\n                params: [encodedBlockParam, shouldIncludeTransactionData]\n              });\n            case 7:\n              blockWithTransactionDataWithHexValues = _context19.sent;\n              blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n              return _context19.abrupt(\"return\", blockWithoutTransactionData);\n            case 10:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n    }\n    /**\n     * Fetch a block's timestamp\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The block's timestamp\n     */\n  }, {\n    key: \"getBlockTimestampAsync\",\n    value: function getBlockTimestampAsync(blockParam) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var blockIfExists;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              Web3Wrapper._assertBlockParamOrString(blockParam);\n              _context20.next = 3;\n              return this.getBlockIfExistsAsync(blockParam);\n            case 3:\n              blockIfExists = _context20.sent;\n              if (!(blockIfExists === undefined)) {\n                _context20.next = 6;\n                break;\n              }\n              throw new Error(\"Failed to fetch block with blockParam: \".concat(JSON.stringify(blockParam)));\n            case 6:\n              return _context20.abrupt(\"return\", blockIfExists.timestamp);\n            case 7:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\n     * Retrieve the user addresses available through the backing provider\n     * @returns Available user addresses\n     */\n  }, {\n    key: \"getAvailableAddressesAsync\",\n    value: function getAvailableAddressesAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var addresses, normalizedAddresses;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'eth_accounts',\n                params: []\n              });\n            case 2:\n              addresses = _context21.sent;\n              normalizedAddresses = _.map(addresses, function (address) {\n                return address.toLowerCase();\n              });\n              return _context21.abrupt(\"return\", normalizedAddresses);\n            case 5:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n    }\n    /**\n     * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n     * @returns The snapshot id. This can be used to revert to this snapshot\n     */\n  }, {\n    key: \"takeSnapshotAsync\",\n    value: function takeSnapshotAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var snapshotId;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.t0 = Number;\n              _context22.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'evm_snapshot',\n                params: []\n              });\n            case 3:\n              _context22.t1 = _context22.sent;\n              snapshotId = (0, _context22.t0)(_context22.t1);\n              return _context22.abrupt(\"return\", snapshotId);\n            case 6:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n    }\n    /**\n     * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n     * @param snapshotId snapshot id to revert to\n     * @returns Whether the revert was successful\n     */\n  }, {\n    key: \"revertSnapshotAsync\",\n    value: function revertSnapshotAsync(snapshotId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var didRevert;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              assert_1.assert.isNumber('snapshotId', snapshotId);\n              _context23.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'evm_revert',\n                params: [snapshotId]\n              });\n            case 3:\n              didRevert = _context23.sent;\n              return _context23.abrupt(\"return\", didRevert);\n            case 5:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n    }\n    /**\n     * Mine a block on a TestRPC/Ganache local node\n     */\n  }, {\n    key: \"mineBlockAsync\",\n    value: function mineBlockAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.sendRawPayloadAsync({\n                method: 'evm_mine',\n                params: []\n              });\n            case 2:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n    }\n    /**\n     * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n     * Will throw if provider is neither TestRPC/Ganache or Geth.\n     * @param timeDelta Amount of time to add in seconds\n     */\n  }, {\n    key: \"increaseTimeAsync\",\n    value: function increaseTimeAsync(timeDelta) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var version;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              assert_1.assert.isNumber('timeDelta', timeDelta);\n              // Detect Geth vs. Ganache and use appropriate endpoint.\n              _context25.next = 3;\n              return this.getNodeVersionAsync();\n            case 3:\n              version = _context25.sent;\n              if (!_.includes(version, uniqueVersionIds.geth)) {\n                _context25.next = 8;\n                break;\n              }\n              return _context25.abrupt(\"return\", this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              }));\n            case 8:\n              if (!_.includes(version, uniqueVersionIds.ganache)) {\n                _context25.next = 12;\n                break;\n              }\n              return _context25.abrupt(\"return\", this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              }));\n            case 12:\n              throw new Error(\"Unknown client version: \".concat(version));\n            case 13:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n    }\n    /**\n     * Retrieve smart contract logs for a given filter\n     * @param filter Parameters by which to filter which logs to retrieve\n     * @returns The corresponding log entries\n     */\n  }, {\n    key: \"getLogsAsync\",\n    value: function getLogsAsync(filter) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!(filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined))) {\n                _context26.next = 2;\n                break;\n              }\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            case 2:\n              fromBlock = filter.fromBlock;\n              if (_.isNumber(fromBlock)) {\n                fromBlock = utils_2.utils.numberToHex(fromBlock);\n              }\n              toBlock = filter.toBlock;\n              if (_.isNumber(toBlock)) {\n                toBlock = utils_2.utils.numberToHex(toBlock);\n              }\n              serializedFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: fromBlock,\n                toBlock: toBlock\n              });\n              payload = {\n                method: 'eth_getLogs',\n                params: [serializedFilter]\n              };\n              _context26.next = 10;\n              return this.sendRawPayloadAsync(payload);\n            case 10:\n              rawLogs = _context26.sent;\n              formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n              return _context26.abrupt(\"return\", formattedLogs);\n            case 13:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\n     * Calculate the estimated gas cost for a given transaction\n     * @param txData Transaction data\n     * @returns Estimated gas cost\n     */\n  }, {\n    key: \"estimateGasAsync\",\n    value: function estimateGasAsync(txData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var txDataHex, gasHex, gas;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n              txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n              _context27.next = 4;\n              return this.sendRawPayloadAsync({\n                method: 'eth_estimateGas',\n                params: [txDataHex]\n              });\n            case 4:\n              gasHex = _context27.sent;\n              gas = utils_2.utils.convertHexToNumber(gasHex);\n              return _context27.abrupt(\"return\", gas);\n            case 7:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n    }\n    /**\n     * Generate an access list for an ethereum call and also compute the gas used.\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to 'latest'.\n     * @returns The access list and gas used.\n     */\n  }, {\n    key: \"createAccessListAsync\",\n    value: function createAccessListAsync(callData, defaultBlock) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var rawResult;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n              _context28.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'eth_createAccessList',\n                params: [marshaller_1.marshaller.marshalCallData(callData), marshaller_1.marshaller.marshalBlockParam(defaultBlock)]\n              });\n            case 3:\n              rawResult = _context28.sent;\n              if (!rawResult.error) {\n                _context28.next = 6;\n                break;\n              }\n              throw new Error(rawResult.error);\n            case 6:\n              return _context28.abrupt(\"return\", {\n                accessList: rawResult.accessList.reduce(function (o, v) {\n                  var _o$v$address;\n                  o[v.address] = o[v.address] || [];\n                  (_o$v$address = o[v.address]).push.apply(_o$v$address, _toConsumableArray(v.storageKeys || []));\n                  return o;\n                },\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                {}),\n                // tslint:disable-next-line: custom-no-magic-numbers\n                gasUsed: parseInt(rawResult.gasUsed.slice(2), 16)\n              });\n            case 7:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n    }\n    /**\n     * Call a smart contract method at a given block height\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns The raw call result\n     */\n  }, {\n    key: \"callAsync\",\n    value: function callAsync(callData, defaultBlock) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var marshalledDefaultBlock, callDataHex, overrides, rawCallResult;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema);\n              if (defaultBlock !== undefined) {\n                Web3Wrapper._assertBlockParam(defaultBlock);\n              }\n              marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n              callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n              overrides = marshaller_1.marshaller.marshalCallOverrides(callData.overrides || {});\n              _context29.next = 7;\n              return this.sendRawPayloadAsync({\n                method: 'eth_call',\n                params: [callDataHex, marshalledDefaultBlock].concat(_toConsumableArray(Object.keys(overrides).length === 0 ? [] : [overrides]))\n              });\n            case 7:\n              rawCallResult = _context29.sent;\n              return _context29.abrupt(\"return\", rawCallResult);\n            case 9:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n    }\n    /**\n     * Send a transaction\n     * @param txData Transaction data\n     * @returns Transaction hash\n     */\n  }, {\n    key: \"sendTransactionAsync\",\n    value: function sendTransactionAsync(txData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var txDataHex, txHash;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema);\n              txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n              _context30.next = 4;\n              return this.sendRawPayloadAsync({\n                method: 'eth_sendTransaction',\n                params: [txDataHex]\n              });\n            case 4:\n              txHash = _context30.sent;\n              return _context30.abrupt(\"return\", txHash);\n            case 6:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Note that just because a transaction was mined does not mean it was\n     * successful. You need to check the status code of the transaction receipt\n     * to find out if it was successful, or use the helper method\n     * awaitTransactionSuccessAsync.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n  }, {\n    key: \"awaitTransactionMinedAsync\",\n    value: function awaitTransactionMinedAsync(txHash) {\n      var pollingIntervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var timeoutMs = arguments.length > 2 ? arguments[2] : undefined;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n        var _this = this;\n        var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              assert_1.assert.isHexString('txHash', txHash);\n              assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n              if (timeoutMs !== undefined) {\n                assert_1.assert.isNumber('timeoutMs', timeoutMs);\n              }\n              // Immediately check if the transaction has already been mined.\n              _context32.next = 5;\n              return this.getTransactionReceiptIfExistsAsync(txHash);\n            case 5:\n              transactionReceipt = _context32.sent;\n              if (!(transactionReceipt !== undefined)) {\n                _context32.next = 10;\n                break;\n              }\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), {\n                logs: logsWithDecodedArgs\n              });\n              return _context32.abrupt(\"return\", transactionReceiptWithDecodedLogArgs);\n            case 10:\n              // Otherwise, check again every pollingIntervalMs.\n              wasTimeoutExceeded = false;\n              if (timeoutMs) {\n                setTimeout(function () {\n                  return wasTimeoutExceeded = true;\n                }, timeoutMs);\n              }\n              txReceiptPromise = new Promise(function (resolve, reject) {\n                var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n                    var _logsWithDecodedArgs, _transactionReceiptWithDecodedLogArgs;\n                    return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n                      while (1) switch (_context31.prev = _context31.next) {\n                        case 0:\n                          if (!wasTimeoutExceeded) {\n                            _context31.next = 3;\n                            break;\n                          }\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return _context31.abrupt(\"return\", reject(types_1.Web3WrapperErrors.TransactionMiningTimeout));\n                        case 3:\n                          _context31.next = 5;\n                          return this.getTransactionReceiptIfExistsAsync(txHash);\n                        case 5:\n                          transactionReceipt = _context31.sent;\n                          if (transactionReceipt !== undefined) {\n                            utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                            _logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                            _transactionReceiptWithDecodedLogArgs = Object.assign(Object.assign({}, transactionReceipt), {\n                              logs: _logsWithDecodedArgs\n                            });\n                            resolve(_transactionReceiptWithDecodedLogArgs);\n                          }\n                        case 7:\n                        case \"end\":\n                          return _context31.stop();\n                      }\n                    }, _callee31, this);\n                  }));\n                }, pollingIntervalMs, function (err) {\n                  utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                  reject(err);\n                });\n              });\n              _context32.next = 15;\n              return txReceiptPromise;\n            case 15:\n              txReceipt = _context32.sent;\n              return _context32.abrupt(\"return\", txReceipt);\n            case 17:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n    }\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n     * status that is not equal to 1. A status of 0 or null indicates that the\n     * transaction was mined, but failed. See:\n     * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n  }, {\n    key: \"awaitTransactionSuccessAsync\",\n    value: function awaitTransactionSuccessAsync(txHash) {\n      var pollingIntervalMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var timeoutMs = arguments.length > 2 ? arguments[2] : undefined;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        var receipt;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              _context33.next = 2;\n              return this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs);\n            case 2:\n              receipt = _context33.sent;\n              if (!(receipt.status !== 1)) {\n                _context33.next = 5;\n                break;\n              }\n              throw new Error(\"Transaction failed: \".concat(txHash));\n            case 5:\n              return _context33.abrupt(\"return\", receipt);\n            case 6:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n    }\n    /**\n     * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n     * the local chain by block number. Note, this is a destructive action and\n     * may severely damage your chain. Use with extreme caution. As of now, this\n     * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n     * not supported.\n     * @param  blockNumber The block number to reset to.\n     */\n  }, {\n    key: \"setHeadAsync\",\n    value: function setHeadAsync(blockNumber) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              assert_1.assert.isNumber('blockNumber', blockNumber);\n              _context34.next = 3;\n              return this.sendRawPayloadAsync({\n                method: 'debug_setHead',\n                params: [utils_2.utils.numberToHex(blockNumber)]\n              });\n            case 3:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\n     * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n     * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n     * @return The contents nested under the result key of the response body\n     */\n  }, {\n    key: \"sendRawPayloadAsync\",\n    value: function sendRawPayloadAsync(payload) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        var payloadWithDefaults, sendAsync, response, errorMessage;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              if (payload.method) {\n                _context35.next = 2;\n                break;\n              }\n              throw new Error(\"Must supply method in JSONRPCRequestPayload, tried: [\".concat(payload, \"]\"));\n            case 2:\n              // tslint:disable:no-object-literal-type-assertion\n              payloadWithDefaults = Object.assign({\n                id: this._jsonRpcRequestId++,\n                params: [],\n                jsonrpc: '2.0'\n              }, payload); // tslint:enable:no-object-literal-type-assertion\n              sendAsync = utils_1.promisify(this._provider.sendAsync.bind(this._provider));\n              _context35.next = 6;\n              return sendAsync(payloadWithDefaults);\n            case 6:\n              response = _context35.sent;\n              if (response) {\n                _context35.next = 9;\n                break;\n              }\n              throw new Error(\"No response\");\n            case 9:\n              errorMessage = response.error ? response.error.message || response.error : undefined;\n              if (!errorMessage) {\n                _context35.next = 12;\n                break;\n              }\n              throw new Error(errorMessage);\n            case 12:\n              if (!(response.result === undefined)) {\n                _context35.next = 14;\n                break;\n              }\n              throw new Error(\"JSON RPC response has no result\");\n            case 14:\n              return _context35.abrupt(\"return\", response.result);\n            case 15:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n    }\n    /**\n     * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n     * the backing Ethereum node. Throws for any other type of node.\n     */\n  }, {\n    key: \"getNodeTypeAsync\",\n    value: function getNodeTypeAsync() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        var version;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.next = 2;\n              return this.getNodeVersionAsync();\n            case 2:\n              version = _context36.sent;\n              if (!_.includes(version, uniqueVersionIds.geth)) {\n                _context36.next = 7;\n                break;\n              }\n              return _context36.abrupt(\"return\", types_1.NodeType.Geth);\n            case 7:\n              if (!_.includes(version, uniqueVersionIds.ganache)) {\n                _context36.next = 11;\n                break;\n              }\n              return _context36.abrupt(\"return\", types_1.NodeType.Ganache);\n            case 11:\n              throw new Error(\"Unknown client version: \".concat(version));\n            case 12:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this);\n      }));\n    }\n  }], [{\n    key: \"isAddress\",\n    value: function isAddress(address) {\n      return utils_1.addressUtils.isAddress(address);\n    }\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n  }, {\n    key: \"toUnitAmount\",\n    value: function toUnitAmount(amount, decimals) {\n      assert_1.assert.isValidBaseUnitAmount('amount', amount);\n      assert_1.assert.isNumber('decimals', decimals);\n      var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n      var unit = amount.div(aUnit);\n      return unit;\n    }\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n  }, {\n    key: \"toBaseUnitAmount\",\n    value: function toBaseUnitAmount(amount, decimals) {\n      assert_1.assert.isNumber('decimals', decimals);\n      var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n      var baseUnitAmount = unit.times(amount);\n      var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n      if (hasDecimals) {\n        throw new Error(\"Invalid unit amount: \".concat(amount.toString(BASE_TEN), \" - Too many decimal places\"));\n      }\n      return baseUnitAmount;\n    }\n    /**\n     * Convert an Ether amount from ETH to Wei\n     * @param ethAmount Amount of Ether to convert to wei\n     * @returns Amount in wei\n     */\n  }, {\n    key: \"toWei\",\n    value: function toWei(ethAmount) {\n      assert_1.assert.isBigNumber('ethAmount', ethAmount);\n      var ETH_DECIMALS = 18;\n      var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n      return balanceWei;\n    }\n  }, {\n    key: \"_assertBlockParam\",\n    value: function _assertBlockParam(blockParam) {\n      if (_.isNumber(blockParam)) {\n        return;\n      } else if (_.isString(blockParam)) {\n        assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n      }\n    }\n  }, {\n    key: \"_assertBlockParamOrString\",\n    value: function _assertBlockParamOrString(blockParam) {\n      try {\n        Web3Wrapper._assertBlockParam(blockParam);\n      } catch (err) {\n        try {\n          assert_1.assert.isHexString('blockParam', blockParam);\n          return;\n        } catch (err) {\n          throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \".concat(blockParam));\n        }\n      }\n    }\n  }, {\n    key: \"_normalizeTxReceiptStatus\",\n    value: function _normalizeTxReceiptStatus(status) {\n      // Transaction status might have four values\n      // undefined - Testrpc and other old clients\n      // null - New clients on old transactions\n      // number - Parity\n      // hex - Geth\n      if (_.isString(status)) {\n        return utils_2.utils.convertHexToNumber(status);\n      } else if (status === undefined) {\n        return null;\n      } else {\n        return status;\n      }\n    }\n  }]);\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;","map":null,"metadata":{},"sourceType":"script"}