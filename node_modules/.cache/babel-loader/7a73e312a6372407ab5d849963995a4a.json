{"ast":null,"code":"var inherits = require('inherits');\nvar AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\nvar ltgt = require('ltgt');\nvar createRBT = require('functional-red-black-tree');\nvar Buffer = require('safe-buffer').Buffer;\n\n// In Node, use global.setImmediate. In the browser, use a consistent\n// microtask library to give consistent microtask experience to all browsers\nvar setImmediate = require('./immediate');\nfunction gt(value) {\n  return ltgt.compare(value, this._upperBound) > 0;\n}\nfunction gte(value) {\n  return ltgt.compare(value, this._upperBound) >= 0;\n}\nfunction lt(value) {\n  return ltgt.compare(value, this._upperBound) < 0;\n}\nfunction lte(value) {\n  return ltgt.compare(value, this._upperBound) <= 0;\n}\nfunction MemIterator(db, options) {\n  AbstractIterator.call(this, db);\n  this._limit = options.limit;\n  if (this._limit === -1) this._limit = Infinity;\n  var tree = db._store;\n  this.keyAsBuffer = options.keyAsBuffer !== false;\n  this.valueAsBuffer = options.valueAsBuffer !== false;\n  this._reverse = options.reverse;\n  this._options = options;\n  this._done = 0;\n  if (!this._reverse) {\n    this._incr = 'next';\n    this._lowerBound = ltgt.lowerBound(options);\n    this._upperBound = ltgt.upperBound(options);\n    if (typeof this._lowerBound === 'undefined') {\n      this._tree = tree.begin;\n    } else if (ltgt.lowerBoundInclusive(options)) {\n      this._tree = tree.ge(this._lowerBound);\n    } else {\n      this._tree = tree.gt(this._lowerBound);\n    }\n    if (this._upperBound) {\n      if (ltgt.upperBoundInclusive(options)) {\n        this._test = lte;\n      } else {\n        this._test = lt;\n      }\n    }\n  } else {\n    this._incr = 'prev';\n    this._lowerBound = ltgt.upperBound(options);\n    this._upperBound = ltgt.lowerBound(options);\n    if (typeof this._lowerBound === 'undefined') {\n      this._tree = tree.end;\n    } else if (ltgt.upperBoundInclusive(options)) {\n      this._tree = tree.le(this._lowerBound);\n    } else {\n      this._tree = tree.lt(this._lowerBound);\n    }\n    if (this._upperBound) {\n      if (ltgt.lowerBoundInclusive(options)) {\n        this._test = gte;\n      } else {\n        this._test = gt;\n      }\n    }\n  }\n}\ninherits(MemIterator, AbstractIterator);\nMemIterator.prototype._next = function (callback) {\n  var key;\n  var value;\n  if (this._done++ >= this._limit) return setImmediate(callback);\n  if (!this._tree.valid) return setImmediate(callback);\n  key = this._tree.key;\n  value = this._tree.value;\n  if (!this._test(key)) return setImmediate(callback);\n  if (this.keyAsBuffer && !Buffer.isBuffer(key)) {\n    key = Buffer.from(String(key));\n  }\n  if (this.valueAsBuffer && !Buffer.isBuffer(value)) {\n    value = Buffer.from(String(value));\n  }\n  this._tree[this._incr]();\n  setImmediate(function callNext() {\n    callback(null, key, value);\n  });\n};\nMemIterator.prototype._test = function () {\n  return true;\n};\nfunction MemDOWN() {\n  if (!(this instanceof MemDOWN)) return new MemDOWN();\n  AbstractLevelDOWN.call(this, '');\n  this._store = createRBT(ltgt.compare);\n}\ninherits(MemDOWN, AbstractLevelDOWN);\nMemDOWN.prototype._open = function (options, callback) {\n  var self = this;\n  setImmediate(function callNext() {\n    callback(null, self);\n  });\n};\nMemDOWN.prototype._serializeKey = function (key) {\n  return key;\n};\nMemDOWN.prototype._serializeValue = function (value) {\n  return value == null ? '' : value;\n};\nMemDOWN.prototype._put = function (key, value, options, callback) {\n  var iter = this._store.find(key);\n  if (iter.valid) {\n    this._store = iter.update(value);\n  } else {\n    this._store = this._store.insert(key, value);\n  }\n  setImmediate(callback);\n};\nMemDOWN.prototype._get = function (key, options, callback) {\n  var value = this._store.get(key);\n  if (typeof value === 'undefined') {\n    // 'NotFound' error, consistent with LevelDOWN API\n    return setImmediate(function callNext() {\n      callback(new Error('NotFound'));\n    });\n  }\n  if (options.asBuffer !== false && !Buffer.isBuffer(value)) {\n    value = Buffer.from(String(value));\n  }\n  setImmediate(function callNext() {\n    callback(null, value);\n  });\n};\nMemDOWN.prototype._del = function (key, options, callback) {\n  this._store = this._store.remove(key);\n  setImmediate(callback);\n};\nMemDOWN.prototype._batch = function (array, options, callback) {\n  var i = -1;\n  var key;\n  var value;\n  var iter;\n  var len = array.length;\n  var tree = this._store;\n  while (++i < len) {\n    key = array[i].key;\n    iter = tree.find(key);\n    if (array[i].type === 'put') {\n      value = array[i].value;\n      tree = iter.valid ? iter.update(value) : tree.insert(key, value);\n    } else {\n      tree = iter.remove();\n    }\n  }\n  this._store = tree;\n  setImmediate(callback);\n};\nMemDOWN.prototype._iterator = function (options) {\n  return new MemIterator(this, options);\n};\nmodule.exports = MemDOWN.default = MemDOWN;","map":null,"metadata":{},"sourceType":"script"}