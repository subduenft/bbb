{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\nvar buffer_1 = require(\"buffer\");\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nvar MerkleMountainRange = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleMountainRange, _Base_1$default);\n  function MerkleMountainRange() {\n    var _this;\n    var hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    var peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    var hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, MerkleMountainRange);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MerkleMountainRange).call(this));\n    _this.root = buffer_1.Buffer.alloc(0);\n    _this.size = 0;\n    _this.width = 0;\n    _this.hashes = {};\n    _this.data = {};\n    leaves = leaves.map(_this.bufferify);\n    _this.hashFn = _this.bufferifyFn(hashFn);\n    _this.hashLeafFn = hashLeafFn;\n    _this.peakBaggingFn = peakBaggingFn;\n    _this.hashBranchFn = hashBranchFn;\n    var _iterator = _createForOfIteratorHelper(leaves),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var leaf = _step.value;\n        _this.append(leaf);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return _this;\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n  _createClass(MerkleMountainRange, [{\n    key: \"append\",\n    value: function append(data) {\n      data = this.bufferify(data);\n      var dataHash = this.hashFn(data);\n      var dataHashHex = this.bufferToHex(dataHash);\n      if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n        this.data[dataHashHex] = data;\n      }\n      var leaf = this.hashLeaf(this.size + 1, dataHash);\n      this.hashes[this.size + 1] = leaf;\n      this.width += 1;\n      // find peaks for enlarged tree\n      var peakIndexes = this.getPeakIndexes(this.width);\n      // the right most peak's value is the new size of the updated tree\n      this.size = this.getSize(this.width);\n      // starting from the left-most peak, get all peak hashes\n      var peaks = [];\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n      }\n      // update the tree root hash\n      this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n  }, {\n    key: \"hashLeaf\",\n    value: function hashLeaf(index, dataHash) {\n      dataHash = this.bufferify(dataHash);\n      if (this.hashLeafFn) {\n        return this.bufferify(this.hashLeafFn(index, dataHash));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n  }, {\n    key: \"hashBranch\",\n    value: function hashBranch(index, left, right) {\n      if (this.hashBranchFn) {\n        return this.bufferify(this.hashBranchFn(index, left, right));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n  }, {\n    key: \"getPeaks\",\n    value: function getPeaks() {\n      var peakIndexes = this.getPeakIndexes(this.width);\n      var peaks = [];\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this.hashes[peakIndexes[i]];\n      }\n      return peaks;\n    }\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(width) {\n      if (width % 2 === 1) {\n        return this.getSize(width);\n      }\n      return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n  }, {\n    key: \"getPeakIndexes\",\n    value: function getPeakIndexes(width) {\n      var numPeaks = this.numOfPeaks(width);\n      var peakIndexes = [];\n      var count = 0;\n      var size = 0;\n      for (var i = 255; i > 0; i--) {\n        if ((width & 1 << i - 1) !== 0) {\n          // peak exists\n          size = size + (1 << i) - 1;\n          peakIndexes[count++] = size;\n          if (peakIndexes.length >= numPeaks) {\n            break;\n          }\n        }\n      }\n      if (count !== peakIndexes.length) {\n        throw new Error('invalid bit calculation');\n      }\n      return peakIndexes;\n    }\n  }, {\n    key: \"numOfPeaks\",\n    value: function numOfPeaks(width) {\n      var bits = width;\n      var num = 0;\n      while (bits > 0) {\n        if (bits % 2 === 1) {\n          num++;\n        }\n        bits = bits >> 1;\n      }\n      return num;\n    }\n  }, {\n    key: \"peakBagging\",\n    value: function peakBagging(width, peaks) {\n      var size = this.getSize(width);\n      if (this.numOfPeaks(width) !== peaks.length) {\n        throw new Error('received invalid number of peaks');\n      }\n      if (width === 0 && !peaks.length) {\n        return buffer_1.Buffer.alloc(0);\n      }\n      if (this.peakBaggingFn) {\n        return this.bufferify(this.peakBaggingFn(size, peaks));\n      }\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size)].concat(_toConsumableArray(peaks.map(this.bufferify)))));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize(width) {\n      return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n  }, {\n    key: \"mountainHeight\",\n    value: function mountainHeight(size) {\n      var height = 1;\n      while (1 << height <= size + height) {\n        height++;\n      }\n      return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n  }, {\n    key: \"heightAt\",\n    value: function heightAt(index) {\n      var reducedIndex = index;\n      var peakIndex = 0;\n      var height = 0;\n      // if an index has a left mountain then subtract the mountain\n      while (reducedIndex > peakIndex) {\n        reducedIndex -= (1 << height) - 1;\n        height = this.mountainHeight(reducedIndex);\n        peakIndex = (1 << height) - 1;\n      }\n      // index is on the right slope\n      return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(index) {\n      return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(index) {\n      var left = index - (1 << this.heightAt(index) - 1);\n      var right = index - 1;\n      if (left === right) {\n        throw new Error('not a parent');\n      }\n      return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n  }, {\n    key: \"getMerkleProof\",\n    value: function getMerkleProof(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n      if (!this.isLeaf(index)) {\n        throw new Error('not a leaf');\n      }\n      var root = this.root;\n      var width = this.width;\n      // find all peaks for bagging\n      var peaks = this.getPeakIndexes(this.width);\n      var peakBagging = [];\n      var cursor = 0;\n      for (var i = 0; i < peaks.length; i++) {\n        // collect the hash of all peaks\n        peakBagging[i] = this.hashes[peaks[i]];\n        // find the peak which includes the target index\n        if (peaks[i] >= index && cursor === 0) {\n          cursor = peaks[i];\n        }\n      }\n      var left = 0;\n      var right = 0;\n      // get hashes of the siblings in the mountain which the index belgons to.\n      // it moves the cursor from the summit of the mountain down to the target index\n      var height = this.heightAt(cursor);\n      var siblings = [];\n      while (cursor !== index) {\n        height--;\n        // move the cursor down to the left size or right size\n        var _this$getChildren = this.getChildren(cursor);\n        var _this$getChildren2 = _slicedToArray(_this$getChildren, 2);\n        left = _this$getChildren2[0];\n        right = _this$getChildren2[1];\n        cursor = index <= left ? left : right;\n        // remaining node is the sibling\n        siblings[height - 1] = this.hashes[index <= left ? right : left];\n      }\n      return {\n        root: root,\n        width: width,\n        peakBagging: peakBagging,\n        siblings: siblings\n      };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(root, width, index, value, peaks, siblings) {\n      value = this.bufferify(value);\n      var size = this.getSize(width);\n      if (size < index) {\n        throw new Error('index is out of range');\n      }\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n      // find the mountain where the target index belongs to\n      var cursor = 0;\n      var targetPeak;\n      var peakIndexes = this.getPeakIndexes(width);\n      for (var i = 0; i < peakIndexes.length; i++) {\n        if (peakIndexes[i] >= index) {\n          targetPeak = peaks[i];\n          cursor = peakIndexes[i];\n          break;\n        }\n      }\n      if (!targetPeak) {\n        throw new Error('target not found');\n      }\n      // find the path climbing down\n      var height = siblings.length + 1;\n      var path = new Array(height);\n      var left = 0;\n      var right = 0;\n      while (height > 0) {\n        // record the current cursor and climb down\n        path[--height] = cursor;\n        if (cursor === index) {\n          // on the leaf node. Stop climbing down\n          break;\n        } else {\n          // on the parent node. Go left or right\n          var _this$getChildren3 = this.getChildren(cursor);\n          var _this$getChildren4 = _slicedToArray(_this$getChildren3, 2);\n          left = _this$getChildren4[0];\n          right = _this$getChildren4[1];\n          cursor = index > left ? right : left;\n          continue;\n        }\n      }\n      // calculate the summit hash climbing up again\n      var node;\n      while (height < path.length) {\n        // move cursor\n        cursor = path[height];\n        if (height === 0) {\n          // cusor is on the leaf\n          node = this.hashLeaf(cursor, this.hashFn(value));\n        } else if (cursor - 1 === path[height - 1]) {\n          // cursor is on a parent and a siblings is on the left\n          node = this.hashBranch(cursor, siblings[height - 1], node);\n        } else {\n          // cursor is on a parent and a siblings is on the right\n          node = this.hashBranch(cursor, node, siblings[height - 1]);\n        }\n        // climb up\n        height++;\n      }\n      // computed hash value of the summit should equal to the target peak hash\n      if (!node.equals(targetPeak)) {\n        throw new Error('hashed peak is invalid');\n      }\n      return true;\n    }\n  }, {\n    key: \"peaksToPeakMap\",\n    value: function peaksToPeakMap(width, peaks) {\n      var peakMap = {};\n      var bitIndex = 0;\n      var peakRef = 0;\n      var count = peaks.length;\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        peakRef = 1 << height - 1;\n        if ((width & peakRef) !== 0) {\n          peakMap[bitIndex] = peaks[--count];\n        } else {\n          peakMap[bitIndex] = 0;\n        }\n      }\n      if (count !== 0) {\n        throw new Error('invalid number of peaks');\n      }\n      return peakMap;\n    }\n  }, {\n    key: \"peakMapToPeaks\",\n    value: function peakMapToPeaks(width, peakMap) {\n      var arrLength = this.numOfPeaks(width);\n      var peaks = new Array(arrLength);\n      var count = 0;\n      for (var i = 0; i < 32; i++) {\n        if (peakMap[i] !== 0) {\n          peaks[count++] = peakMap[i];\n        }\n      }\n      if (count !== arrLength) {\n        throw new Error('invalid number of peaks');\n      }\n      return peaks;\n    }\n  }, {\n    key: \"peakUpdate\",\n    value: function peakUpdate(width, prevPeakMap, itemHash) {\n      var nextPeakMap = {};\n      var newWidth = width + 1;\n      var cursorIndex = this.getLeafIndex(newWidth);\n      var cursorNode = this.hashLeaf(cursorIndex, itemHash);\n      var bitIndex = 0;\n      var peakRef = 0;\n      var prevPeakExist = false;\n      var nextPeakExist = false;\n      var obtained = false;\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        if (obtained) {\n          nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n        } else {\n          peakRef = 1 << height - 1;\n          prevPeakExist = (width & peakRef) !== 0;\n          nextPeakExist = (newWidth & peakRef) !== 0;\n          // get new cursor node with hashing the peak and the current cursor\n          cursorIndex++;\n          if (prevPeakExist) {\n            cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n          }\n          // if new peak exists for the bit index\n          if (nextPeakExist) {\n            // if prev peak exists for the bit index\n            if (prevPeakExist) {\n              nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n              nextPeakMap[bitIndex] = cursorNode;\n            }\n            obtained = true;\n          } else {\n            nextPeakMap[bitIndex] = 0;\n          }\n        }\n      }\n      return nextPeakMap;\n    }\n  }, {\n    key: \"rollUp\",\n    value: function rollUp(root, width, peaks, itemHashes) {\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n      var tmpWidth = width;\n      var tmpPeakMap = this.peaksToPeakMap(width, peaks);\n      for (var i = 0; i < itemHashes.length; i++) {\n        tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n        tmpWidth++;\n      }\n      return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n  }, {\n    key: \"_getOrCreateNode\",\n    value: function _getOrCreateNode(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n      if (!this.hashes[index]) {\n        var _this$getChildren5 = this.getChildren(index),\n          _this$getChildren6 = _slicedToArray(_this$getChildren5, 2),\n          leftIndex = _this$getChildren6[0],\n          rightIndex = _this$getChildren6[1];\n        var leftHash = this._getOrCreateNode(leftIndex);\n        var rightHash = this._getOrCreateNode(rightIndex);\n        this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n      }\n      return this.hashes[index];\n    }\n  }]);\n  return MerkleMountainRange;\n}(Base_1.default);\nexports.MerkleMountainRange = MerkleMountainRange;\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleMountainRange = MerkleMountainRange;\n}\nexports.default = MerkleMountainRange;","map":null,"metadata":{},"sourceType":"script"}