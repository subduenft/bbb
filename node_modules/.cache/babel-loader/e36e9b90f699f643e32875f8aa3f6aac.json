{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/nicholasschepisi/Desktop/code/bbb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\nvar buffer_1 = require(\"buffer\");\nvar buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar treeify_1 = __importDefault(require(\"treeify\"));\nvar Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nvar MerkleTree = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleTree, _Base_1$default);\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  function MerkleTree(leaves) {\n    var _this;\n    var hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, MerkleTree);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MerkleTree).call(this));\n    _this.duplicateOdd = false;\n    _this.concatenator = buffer_1.Buffer.concat;\n    _this.hashLeaves = false;\n    _this.isBitcoinTree = false;\n    _this.leaves = [];\n    _this.layers = [];\n    _this.sortLeaves = false;\n    _this.sortPairs = false;\n    _this.sort = false;\n    _this.fillDefaultHash = null;\n    _this.complete = false;\n    if (options.complete) {\n      if (options.isBitcoinTree) {\n        throw new Error('option \"complete\" is incompatible with \"isBitcoinTree\"');\n      }\n      if (options.duplicateOdd) {\n        throw new Error('option \"complete\" is incompatible with \"duplicateOdd\"');\n      }\n    }\n    _this.isBitcoinTree = !!options.isBitcoinTree;\n    _this.hashLeaves = !!options.hashLeaves;\n    _this.sortLeaves = !!options.sortLeaves;\n    _this.sortPairs = !!options.sortPairs;\n    _this.complete = !!options.complete;\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        _this.fillDefaultHash = options.fillDefaultHash;\n      } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        _this.fillDefaultHash = function (idx, hashFn) {\n          return options.fillDefaultHash;\n        };\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n    _this.sort = !!options.sort;\n    if (_this.sort) {\n      _this.sortLeaves = true;\n      _this.sortPairs = true;\n    }\n    _this.duplicateOdd = !!options.duplicateOdd;\n    if (options.concatenator) {\n      _this.concatenator = options.concatenator;\n    }\n    _this.hashFn = _this.bufferifyFn(hashFn);\n    _this.processLeaves(leaves);\n    return _this;\n  }\n  _createClass(MerkleTree, [{\n    key: \"getOptions\",\n    value: function getOptions() {\n      var _a, _b;\n      return {\n        complete: this.complete,\n        isBitcoinTree: this.isBitcoinTree,\n        hashLeaves: this.hashLeaves,\n        sortLeaves: this.sortLeaves,\n        sortPairs: this.sortPairs,\n        sort: this.sort,\n        fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,\n        duplicateOdd: this.duplicateOdd\n      };\n    }\n  }, {\n    key: \"processLeaves\",\n    value: function processLeaves(leaves) {\n      if (this.hashLeaves) {\n        leaves = leaves.map(this.hashFn);\n      }\n      this.leaves = leaves.map(this.bufferify);\n      if (this.sortLeaves) {\n        this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n      }\n      if (this.fillDefaultHash) {\n        for (var i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n          this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n        }\n      }\n      this.createHashes(this.leaves);\n    }\n  }, {\n    key: \"createHashes\",\n    value: function createHashes(nodes) {\n      this.layers = [nodes];\n      while (nodes.length > 1) {\n        var layerIndex = this.layers.length;\n        this.layers.push([]);\n        var layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - Math.pow(2, Math.ceil(Math.log2(nodes.length))) : nodes.length;\n        for (var i = 0; i < nodes.length; i += 2) {\n          if (i >= layerLimit) {\n            var _this$layers$layerInd;\n            (_this$layers$layerInd = this.layers[layerIndex]).push.apply(_this$layers$layerInd, _toConsumableArray(nodes.slice(layerLimit)));\n            break;\n          } else if (i + 1 === nodes.length) {\n            if (nodes.length % 2 === 1) {\n              var data = nodes[nodes.length - 1];\n              var _hash = data;\n              // is bitcoin tree\n              if (this.isBitcoinTree) {\n                // Bitcoin method of duplicating the odd ending nodes\n                _hash = this.hashFn(this.concatenator([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]));\n                _hash = buffer_reverse_1.default(this.hashFn(_hash));\n                this.layers[layerIndex].push(_hash);\n                continue;\n              } else {\n                if (this.duplicateOdd) {\n                  // continue with creating layer\n                } else {\n                  // push copy of hash and continue iteration\n                  this.layers[layerIndex].push(nodes[i]);\n                  continue;\n                }\n              }\n            }\n          }\n          var left = nodes[i];\n          var right = i + 1 === nodes.length ? left : nodes[i + 1];\n          var combined = null;\n          if (this.isBitcoinTree) {\n            combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n          } else {\n            combined = [left, right];\n          }\n          if (this.sortPairs) {\n            combined.sort(buffer_1.Buffer.compare);\n          }\n          var hash = this.hashFn(this.concatenator(combined));\n          // double hash if bitcoin tree\n          if (this.isBitcoinTree) {\n            hash = buffer_reverse_1.default(this.hashFn(hash));\n          }\n          this.layers[layerIndex].push(hash);\n        }\n        nodes = this.layers[layerIndex];\n      }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n  }, {\n    key: \"addLeaf\",\n    value: function addLeaf(leaf) {\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (shouldHash) {\n        leaf = this.hashFn(leaf);\n      }\n      this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n  }, {\n    key: \"addLeaves\",\n    value: function addLeaves(leaves) {\n      var shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (shouldHash) {\n        leaves = leaves.map(this.hashFn);\n      }\n      this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n  }, {\n    key: \"getLeaves\",\n    value: function getLeaves(values) {\n      var _this2 = this;\n      if (Array.isArray(values)) {\n        if (this.hashLeaves) {\n          values = values.map(this.hashFn);\n          if (this.sortLeaves) {\n            values = values.sort(buffer_1.Buffer.compare);\n          }\n        }\n        return this.leaves.filter(function (leaf) {\n          return _this2.bufferIndexOf(values, leaf, _this2.sortLeaves) !== -1;\n        });\n      }\n      return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n  }, {\n    key: \"getLeaf\",\n    value: function getLeaf(index) {\n      if (index < 0 || index > this.leaves.length - 1) {\n        return buffer_1.Buffer.from([]);\n      }\n      return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(target) {\n      target = this.bufferify(target);\n      var leaves = this.getLeaves();\n      for (var i = 0; i < leaves.length; i++) {\n        var leaf = leaves[i];\n        if (leaf.equals(target)) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n  }, {\n    key: \"getLeafCount\",\n    value: function getLeafCount() {\n      return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n  }, {\n    key: \"getHexLeaves\",\n    value: function getHexLeaves() {\n      var _this3 = this;\n      return this.leaves.map(function (leaf) {\n        return _this3.bufferToHex(leaf);\n      });\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n  }, {\n    key: \"getLayers\",\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[][]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    value: function getLayers() {\n      return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[][]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n  }, {\n    key: \"getHexLayers\",\n    value: function getHexLayers() {\n      var _this4 = this;\n      return this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.push(item.map(function (layer) {\n            return _this4.bufferToHex(layer);\n          }));\n        } else {\n          acc.push(item);\n        }\n        return acc;\n      }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n  }, {\n    key: \"getLayersFlat\",\n    value: function getLayersFlat() {\n      var layers = this.layers.reduce(function (acc, item) {\n        if (Array.isArray(item)) {\n          acc.unshift.apply(acc, _toConsumableArray(item));\n        } else {\n          acc.unshift(item);\n        }\n        return acc;\n      }, []);\n      layers.unshift(buffer_1.Buffer.from([0]));\n      return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n  }, {\n    key: \"getHexLayersFlat\",\n    value: function getHexLayersFlat() {\n      var _this5 = this;\n      return this.getLayersFlat().map(function (layer) {\n        return _this5.bufferToHex(layer);\n      });\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n  }, {\n    key: \"getLayerCount\",\n    value: function getLayerCount() {\n      return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      if (this.layers.length === 0) {\n        return buffer_1.Buffer.from([]);\n      }\n      return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n  }, {\n    key: \"getProof\",\n    value: function getProof(leaf, index) {\n      if (typeof leaf === 'undefined') {\n        throw new Error('leaf is required');\n      }\n      leaf = this.bufferify(leaf);\n      var proof = [];\n      if (!Number.isInteger(index)) {\n        index = -1;\n        for (var i = 0; i < this.leaves.length; i++) {\n          if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n            index = i;\n          }\n        }\n      }\n      if (index <= -1) {\n        return [];\n      }\n      for (var _i = 0; _i < this.layers.length; _i++) {\n        var layer = this.layers[_i];\n        var isRightNode = index % 2;\n        var pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && _i < this.layers.length - 1\n        // Proof Generation for Bitcoin Trees\n        ? index\n        // Proof Generation for Non-Bitcoin Trees\n        : index + 1;\n        if (pairIndex < layer.length) {\n          proof.push({\n            position: isRightNode ? 'left' : 'right',\n            data: layer[pairIndex]\n          });\n        }\n        // set index to parent index\n        index = index / 2 | 0;\n      }\n      return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n  }, {\n    key: \"getHexProof\",\n    value: function getHexProof(leaf, index) {\n      var _this6 = this;\n      return this.getProof(leaf, index).map(function (item) {\n        return _this6.bufferToHex(item.data);\n      });\n    }\n    /**\n     * getProofs\n     * @desc Returns the proofs for all leaves.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.\n     * @example\n     * ```js\n     *const proofs = tree.getProofs()\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proofs = tree.getProofs()\n     *```\n     */\n  }, {\n    key: \"getProofs\",\n    value: function getProofs() {\n      var proof = [];\n      var proofs = [];\n      this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);\n      return proofs;\n    }\n    /**\n     * getProofsDFS\n     * @desc Get all proofs through single traverse\n     * @param {Number} currentLayer - Current layer index in traverse.\n     * @param {Number} index - Current tarvese node index in traverse.\n     * @param {Object[]} proof - Proof chain for single leaf.\n     * @param {Object[]} proofs - Proofs for all leaves\n     * @example\n     * ```js\n     *const layers = tree.getLayers()\n     *const index = 0;\n     *let proof = [];\n     *let proofs = [];\n     *const proof = tree.getProofsDFS(layers, index, proof, proofs)\n     *```\n     */\n  }, {\n    key: \"getProofsDFS\",\n    value: function getProofsDFS(currentLayer, index, proof, proofs) {\n      var isRightNode = index % 2;\n      if (currentLayer === -1) {\n        if (!isRightNode) proofs.push(_toConsumableArray(proof).reverse());\n        return;\n      }\n      if (index >= this.layers[currentLayer].length) return;\n      var layer = this.layers[currentLayer];\n      var pairIndex = isRightNode ? index - 1 : index + 1;\n      var pushed = false;\n      if (pairIndex < layer.length) {\n        pushed = true;\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      }\n      var leftchildIndex = index * 2;\n      var rightchildIndex = index * 2 + 1;\n      this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);\n      this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);\n      if (pushed) proof.splice(proof.length - 1, 1);\n    }\n    /**\n     * getHexProofs\n     * @desc Returns the proofs for all leaves as hex strings.\n     * @return {String[]} - Proofs array as hex strings.\n     * @example\n     * ```js\n     *const proofs = tree.getHexProofs()\n     *```\n     */\n  }, {\n    key: \"getHexProofs\",\n    value: function getHexProofs() {\n      var _this7 = this;\n      return this.getProofs().map(function (item) {\n        return _this7.bufferToHex(item.data);\n      });\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n  }, {\n    key: \"getPositionalHexProof\",\n    value: function getPositionalHexProof(leaf, index) {\n      var _this8 = this;\n      return this.getProof(leaf, index).map(function (item) {\n        return [item.position === 'left' ? 0 : 1, _this8.bufferToHex(item.data)];\n      });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n  }, {\n    key: \"getProofIndices\",\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    value: function getProofIndices(treeIndices, depth) {\n      var leafCount = Math.pow(2, depth);\n      var maximalIndices = new Set();\n      var _iterator = _createForOfIteratorHelper(treeIndices),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          var x = leafCount + index;\n          while (x > 1) {\n            maximalIndices.add(x ^ 1);\n            x = x / 2 | 0;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var a = treeIndices.map(function (index) {\n        return leafCount + index;\n      });\n      var b = Array.from(maximalIndices).sort(function (a, b) {\n        return a - b;\n      }).reverse();\n      maximalIndices = a.concat(b);\n      var redundantIndices = new Set();\n      var proof = [];\n      var _iterator2 = _createForOfIteratorHelper(maximalIndices),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _index = _step2.value;\n          if (!redundantIndices.has(_index)) {\n            proof.push(_index);\n            while (_index > 1) {\n              redundantIndices.add(_index);\n              if (!redundantIndices.has(_index ^ 1)) break;\n              _index = _index / 2 | 0;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return proof.filter(function (index) {\n        return !treeIndices.includes(index - leafCount);\n      });\n    }\n  }, {\n    key: \"getProofIndicesForUnevenTree\",\n    value: function getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n      var depth = Math.ceil(Math.log2(leavesCount));\n      var unevenLayers = [];\n      for (var index = 0; index < depth; index++) {\n        var unevenLayer = leavesCount % 2 !== 0;\n        if (unevenLayer) {\n          unevenLayers.push({\n            index: index,\n            leavesCount: leavesCount\n          });\n        }\n        leavesCount = Math.ceil(leavesCount / 2);\n      }\n      var proofIndices = [];\n      var layerNodes = sortedLeafIndices;\n      var _loop = function _loop(layerIndex) {\n        var siblingIndices = layerNodes.map(function (index) {\n          if (index % 2 === 0) {\n            return index + 1;\n          }\n          return index - 1;\n        });\n        var proofNodeIndices = siblingIndices.filter(function (index) {\n          return !layerNodes.includes(index);\n        });\n        var unevenLayer = unevenLayers.find(function (_ref) {\n          var index = _ref.index;\n          return index === layerIndex;\n        });\n        if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n          proofNodeIndices = proofNodeIndices.slice(0, -1);\n        }\n        proofIndices.push(proofNodeIndices);\n        layerNodes = _toConsumableArray(new Set(layerNodes.map(function (index) {\n          if (index % 2 === 0) {\n            return index / 2;\n          }\n          if (index % 2 === 0) {\n            return (index + 1) / 2;\n          }\n          return (index - 1) / 2;\n        })));\n      };\n      for (var layerIndex = 0; layerIndex < depth; layerIndex++) {\n        _loop(layerIndex);\n      }\n      return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var _this9 = this;\n      if (!this.complete) {\n        console.warn('Warning: For correct multiProofs it\\'s strongly recommended to set complete: true');\n      }\n      if (!indices) {\n        indices = tree;\n        tree = this.getLayersFlat();\n      }\n      var isUneven = this.isUnevenTree();\n      if (isUneven) {\n        if (indices.every(Number.isInteger)) {\n          return this.getMultiProofForUnevenTree(indices);\n        }\n      }\n      if (!indices.every(Number.isInteger)) {\n        var els = indices;\n        if (this.sortPairs) {\n          els = els.sort(buffer_1.Buffer.compare);\n        }\n        var ids = els.map(function (el) {\n          return _this9.bufferIndexOf(_this9.leaves, el, _this9.sortLeaves);\n        }).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        });\n        if (!ids.every(function (idx) {\n          return idx !== -1;\n        })) {\n          throw new Error('Element does not exist in Merkle tree');\n        }\n        var hashes = [];\n        var proof = [];\n        var nextIds = [];\n        for (var i = 0; i < this.layers.length; i++) {\n          var layer = this.layers[i];\n          for (var j = 0; j < ids.length; j++) {\n            var idx = ids[j];\n            var pairElement = this.getPairNode(layer, idx);\n            hashes.push(layer[idx]);\n            if (pairElement) {\n              proof.push(pairElement);\n            }\n            nextIds.push(idx / 2 | 0);\n          }\n          ids = nextIds.filter(function (value, i, self) {\n            return self.indexOf(value) === i;\n          });\n          nextIds = [];\n        }\n        return proof.filter(function (value) {\n          return !hashes.includes(value);\n        });\n      }\n      return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(function (index) {\n        return tree[index];\n      });\n    }\n  }, {\n    key: \"getMultiProofForUnevenTree\",\n    value: function getMultiProofForUnevenTree(tree, indices) {\n      if (!indices) {\n        indices = tree;\n        tree = this.getLayers();\n      }\n      var proofHashes = [];\n      var currentLayerIndices = indices;\n      var _iterator3 = _createForOfIteratorHelper(tree),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var treeLayer = _step3.value;\n          var siblings = [];\n          var _iterator4 = _createForOfIteratorHelper(currentLayerIndices),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var index = _step4.value;\n              if (index % 2 === 0) {\n                var _idx = index + 1;\n                if (!currentLayerIndices.includes(_idx)) {\n                  if (treeLayer[_idx]) {\n                    siblings.push(treeLayer[_idx]);\n                    continue;\n                  }\n                }\n              }\n              var idx = index - 1;\n              if (!currentLayerIndices.includes(idx)) {\n                if (treeLayer[idx]) {\n                  siblings.push(treeLayer[idx]);\n                  continue;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          proofHashes = proofHashes.concat(siblings);\n          var uniqueIndices = new Set();\n          var _iterator5 = _createForOfIteratorHelper(currentLayerIndices),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _index2 = _step5.value;\n              if (_index2 % 2 === 0) {\n                uniqueIndices.add(_index2 / 2);\n                continue;\n              }\n              if (_index2 % 2 === 0) {\n                uniqueIndices.add((_index2 + 1) / 2);\n                continue;\n              }\n              uniqueIndices.add((_index2 - 1) / 2);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          currentLayerIndices = Array.from(uniqueIndices);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n  }, {\n    key: \"getHexMultiProof\",\n    value: function getHexMultiProof(tree, indices) {\n      var _this10 = this;\n      return this.getMultiProof(tree, indices).map(function (x) {\n        return _this10.bufferToHex(x);\n      });\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n  }, {\n    key: \"getProofFlags\",\n    value: function getProofFlags(leaves, proofs) {\n      var _this11 = this;\n      if (!Array.isArray(leaves) || leaves.length <= 0) {\n        throw new Error('Invalid Inputs!');\n      }\n      var ids;\n      if (leaves.every(Number.isInteger)) {\n        ids = _toConsumableArray(leaves).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        }); // Indices where passed\n      } else {\n        ids = leaves.map(function (el) {\n          return _this11.bufferIndexOf(_this11.leaves, el, _this11.sortLeaves);\n        }).sort(function (a, b) {\n          return a === b ? 0 : a > b ? 1 : -1;\n        });\n      }\n      if (!ids.every(function (idx) {\n        return idx !== -1;\n      })) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n      var _proofs = proofs.map(function (item) {\n        return _this11.bufferify(item);\n      });\n      var tested = [];\n      var flags = [];\n      var _loop2 = function _loop2() {\n        var layer = _this11.layers[index];\n        ids = ids.reduce(function (ids, idx) {\n          var skipped = tested.includes(layer[idx]);\n          if (!skipped) {\n            var pairElement = _this11.getPairNode(layer, idx);\n            var proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n            pairElement && flags.push(!proofUsed);\n            tested.push(layer[idx]);\n            tested.push(pairElement);\n          }\n          ids.push(idx / 2 | 0);\n          return ids;\n        }, []);\n      };\n      for (var index = 0; index < this.layers.length; index++) {\n        _loop2();\n      }\n      return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hash = this.bufferify(targetNode);\n      root = this.bufferify(root);\n      if (!Array.isArray(proof) || !targetNode || !root) {\n        return false;\n      }\n      for (var i = 0; i < proof.length; i++) {\n        var node = proof[i];\n        var data = null;\n        var isLeftNode = null;\n        // case for when proof is hex values only\n        if (typeof node === 'string') {\n          data = this.bufferify(node);\n          isLeftNode = true;\n        } else if (Array.isArray(node)) {\n          isLeftNode = node[0] === 0;\n          data = this.bufferify(node[1]);\n        } else if (buffer_1.Buffer.isBuffer(node)) {\n          data = node;\n          isLeftNode = true;\n        } else if (node instanceof Object) {\n          data = this.bufferify(node.data);\n          isLeftNode = node.position === 'left';\n        } else {\n          throw new Error('Expected node to be of type string or object');\n        }\n        var buffers = [];\n        if (this.isBitcoinTree) {\n          buffers.push(buffer_reverse_1.default(hash));\n          buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n          hash = this.hashFn(this.concatenator(buffers));\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        } else {\n          if (this.sortPairs) {\n            if (buffer_1.Buffer.compare(hash, data) === -1) {\n              buffers.push(hash, data);\n              hash = this.hashFn(this.concatenator(buffers));\n            } else {\n              buffers.push(data, hash);\n              hash = this.hashFn(this.concatenator(buffers));\n            }\n          } else {\n            buffers.push(hash);\n            buffers[isLeftNode ? 'unshift' : 'push'](data);\n            hash = this.hashFn(this.concatenator(buffers));\n          }\n        }\n      }\n      return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n  }, {\n    key: \"verifyMultiProof\",\n    value: function verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n      var _this12 = this;\n      var isUneven = this.isUnevenTree();\n      if (isUneven) {\n        // TODO: combine these functions and simplify\n        return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n      }\n      var depth = Math.ceil(Math.log2(leavesCount));\n      root = this.bufferify(root);\n      proofLeaves = proofLeaves.map(function (leaf) {\n        return _this12.bufferify(leaf);\n      });\n      proof = proof.map(function (leaf) {\n        return _this12.bufferify(leaf);\n      });\n      var tree = {};\n      var _iterator6 = _createForOfIteratorHelper(this.zip(proofIndices, proofLeaves)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n            _index3 = _step6$value[0],\n            leaf = _step6$value[1];\n          tree[Math.pow(2, depth) + _index3] = leaf;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var _iterator7 = _createForOfIteratorHelper(this.zip(this.getProofIndices(proofIndices, depth), proof)),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n            _index4 = _step7$value[0],\n            proofitem = _step7$value[1];\n          tree[_index4] = proofitem;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var indexqueue = Object.keys(tree).map(function (value) {\n        return +value;\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n      var i = 0;\n      while (i < indexqueue.length) {\n        var index = indexqueue[i];\n        if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n          var pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n          if (this.sortPairs) {\n            pair = pair.sort(buffer_1.Buffer.compare);\n          }\n          var hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];\n          tree[index / 2 | 0] = hash;\n          indexqueue.push(index / 2 | 0);\n        }\n        i += 1;\n      }\n      return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n    }\n  }, {\n    key: \"verifyMultiProofWithFlags\",\n    value: function verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n      root = this.bufferify(root);\n      leaves = leaves.map(this.bufferify);\n      proofs = proofs.map(this.bufferify);\n      var leavesLen = leaves.length;\n      var totalHashes = proofFlag.length;\n      var hashes = [];\n      var leafPos = 0;\n      var hashPos = 0;\n      var proofPos = 0;\n      for (var i = 0; i < totalHashes; i++) {\n        var bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n        var bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n        var buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n        hashes[i] = this.hashFn(this.concatenator(buffers));\n      }\n      return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n  }, {\n    key: \"verifyMultiProofForUnevenTree\",\n    value: function verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n      var _this13 = this;\n      root = this.bufferify(root);\n      leaves = leaves.map(function (leaf) {\n        return _this13.bufferify(leaf);\n      });\n      proof = proof.map(function (leaf) {\n        return _this13.bufferify(leaf);\n      });\n      var computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n      return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n  }, {\n    key: \"getDepth\",\n    value: function getDepth() {\n      return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n  }, {\n    key: \"getLayersAsObject\",\n    value: function getLayersAsObject() {\n      var _this14 = this;\n      var layers = this.getLayers().map(function (layer) {\n        return layer.map(function (value) {\n          return _this14.bufferToHex(value, false);\n        });\n      });\n      var objs = [];\n      for (var i = 0; i < layers.length; i++) {\n        var arr = [];\n        for (var j = 0; j < layers[i].length; j++) {\n          var obj = _defineProperty({}, layers[i][j], null);\n          if (objs.length) {\n            obj[layers[i][j]] = {};\n            var a = objs.shift();\n            var akey = Object.keys(a)[0];\n            obj[layers[i][j]][akey] = a[akey];\n            if (objs.length) {\n              var b = objs.shift();\n              var bkey = Object.keys(b)[0];\n              obj[layers[i][j]][bkey] = b[bkey];\n            }\n          }\n          arr.push(obj);\n        }\n        objs.push.apply(objs, arr);\n      }\n      return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n  }, {\n    key: \"resetTree\",\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    value: function resetTree() {\n      this.leaves = [];\n      this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n  }, {\n    key: \"getPairNode\",\n    value: function getPairNode(layer, idx) {\n      var pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n      if (pairIdx < layer.length) {\n        return layer[pairIdx];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n  }, {\n    key: \"toTreeString\",\n    value: function toTreeString() {\n      var obj = this.getLayersAsObject();\n      return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toTreeString();\n    }\n  }, {\n    key: \"isUnevenTree\",\n    value: function isUnevenTree(treeLayers) {\n      var depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n      return !this.isPowOf2(depth);\n    }\n  }, {\n    key: \"isPowOf2\",\n    value: function isPowOf2(v) {\n      return v && !(v & v - 1);\n    }\n  }, {\n    key: \"calculateRootForUnevenTree\",\n    value: function calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n      var leafTuples = this.zip(leafIndices, leafHashes).sort(function (_ref2, _ref3) {\n        var _ref4 = _slicedToArray(_ref2, 1),\n          indexA = _ref4[0];\n        var _ref5 = _slicedToArray(_ref3, 1),\n          indexB = _ref5[0];\n        return indexA - indexB;\n      });\n      var leafTupleIndices = leafTuples.map(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 1),\n          index = _ref7[0];\n        return index;\n      });\n      var proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n      var nextSliceStart = 0;\n      var proofTuplesByLayers = [];\n      for (var i = 0; i < proofIndices.length; i++) {\n        var indices = proofIndices[i];\n        var sliceStart = nextSliceStart;\n        nextSliceStart += indices.length;\n        proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n      }\n      var tree = [leafTuples];\n      for (var layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n        var currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(function (_ref8, _ref9) {\n          var _ref10 = _slicedToArray(_ref8, 1),\n            indexA = _ref10[0];\n          var _ref11 = _slicedToArray(_ref9, 1),\n            indexB = _ref11[0];\n          return indexA - indexB;\n        }).map(function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n            hash = _ref13[1];\n          return hash;\n        });\n        var s = tree[layerIndex].map(function (_ref14) {\n          var _ref15 = _slicedToArray(_ref14, 1),\n            layerIndex = _ref15[0];\n          return layerIndex;\n        });\n        var parentIndices = _toConsumableArray(new Set(s.map(function (index) {\n          if (index % 2 === 0) {\n            return index / 2;\n          }\n          if (index % 2 === 0) {\n            return (index + 1) / 2;\n          }\n          return (index - 1) / 2;\n        })));\n        var parentLayer = [];\n        for (var _i2 = 0; _i2 < parentIndices.length; _i2++) {\n          var parentNodeTreeIndex = parentIndices[_i2];\n          var bufA = currentLayer[_i2 * 2];\n          var bufB = currentLayer[_i2 * 2 + 1];\n          var hash = bufB ? this.hashFn(this.concatenator([bufA, bufB])) : bufA;\n          parentLayer.push([parentNodeTreeIndex, hash]);\n        }\n        tree.push(parentLayer);\n      }\n      return tree[tree.length - 1][0][1];\n    }\n  }], [{\n    key: \"marshalLeaves\",\n    value: function marshalLeaves(leaves) {\n      return JSON.stringify(leaves.map(function (leaf) {\n        return MerkleTree.bufferToHex(leaf);\n      }), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n  }, {\n    key: \"unmarshalLeaves\",\n    value: function unmarshalLeaves(jsonStr) {\n      var parsed = null;\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n      if (!parsed) {\n        return [];\n      }\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n      return parsed.map(MerkleTree.bufferify);\n    }\n  }, {\n    key: \"marshalProof\",\n    value: function marshalProof(proof) {\n      var json = proof.map(function (item) {\n        if (typeof item === 'string') {\n          return item;\n        }\n        if (buffer_1.Buffer.isBuffer(item)) {\n          return MerkleTree.bufferToHex(item);\n        }\n        return {\n          position: item.position,\n          data: MerkleTree.bufferToHex(item.data)\n        };\n      });\n      return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n  }, {\n    key: \"unmarshalProof\",\n    value: function unmarshalProof(jsonStr) {\n      var parsed = null;\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n      if (!parsed) {\n        return [];\n      }\n      if (!Array.isArray(parsed)) {\n        throw new Error('Expected JSON string to be array');\n      }\n      return parsed.map(function (item) {\n        if (typeof item === 'string') {\n          return MerkleTree.bufferify(item);\n        } else if (item instanceof Object) {\n          return {\n            position: item.position,\n            data: MerkleTree.bufferify(item.data)\n          };\n        } else {\n          throw new Error('Expected item to be of type string or object');\n        }\n      });\n    }\n  }, {\n    key: \"marshalTree\",\n    value: function marshalTree(tree) {\n      var root = tree.getHexRoot();\n      var leaves = tree.leaves.map(function (leaf) {\n        return MerkleTree.bufferToHex(leaf);\n      });\n      var layers = tree.getHexLayers();\n      var options = tree.getOptions();\n      return JSON.stringify({\n        options: options,\n        root: root,\n        layers: layers,\n        leaves: leaves\n      }, null, 2);\n    }\n  }, {\n    key: \"unmarshalTree\",\n    value: function unmarshalTree(jsonStr) {\n      var hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var parsed = null;\n      if (typeof jsonStr === 'string') {\n        parsed = JSON.parse(jsonStr);\n      } else if (jsonStr instanceof Object) {\n        parsed = jsonStr;\n      } else {\n        throw new Error('Expected type of string or object');\n      }\n      if (!parsed) {\n        throw new Error('could not parse json');\n      }\n      options = Object.assign({}, parsed.options || {}, options);\n      return new MerkleTree(parsed.leaves, hashFn, options);\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(proof, targetNode, root) {\n      var hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var tree = new MerkleTree([], hashFn, options);\n      return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n  }, {\n    key: \"getMultiProof\",\n    value: function getMultiProof(tree, indices) {\n      var t = new MerkleTree([]);\n      return t.getMultiProof(tree, indices);\n    }\n  }]);\n  return MerkleTree;\n}(Base_1.default);\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;","map":null,"metadata":{},"sourceType":"script"}