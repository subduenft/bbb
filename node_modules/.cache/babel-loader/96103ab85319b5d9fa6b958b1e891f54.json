{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrivateListingFulfillments = exports.constructPrivateListingCounterOrder = exports.getPrivateListingConsiderations = void 0;\nvar item_1 = require(\"@opensea/seaport-js/lib/utils/item\");\nvar order_1 = require(\"@opensea/seaport-js/lib/utils/order\");\nvar ethers_1 = require(\"ethers\");\nvar getPrivateListingConsiderations = function getPrivateListingConsiderations(offer, privateSaleRecipient) {\n  return offer.map(function (item) {\n    return __assign(__assign({}, item), {\n      recipient: privateSaleRecipient\n    });\n  });\n};\nexports.getPrivateListingConsiderations = getPrivateListingConsiderations;\nvar constructPrivateListingCounterOrder = function constructPrivateListingCounterOrder(order, privateSaleRecipient) {\n  // Counter order offers up all the items in the private listing consideration\n  // besides the items that are going to the private listing recipient\n  var paymentItems = order.parameters.consideration.filter(function (item) {\n    return item.recipient.toLowerCase() !== privateSaleRecipient.toLowerCase();\n  });\n  if (!paymentItems.every(function (item) {\n    return (0, item_1.isCurrencyItem)(item);\n  })) {\n    throw new Error(\"The consideration for the private listing did not contain only currency items\");\n  }\n  if (!paymentItems.every(function (item) {\n    return item.itemType === paymentItems[0].itemType;\n  })) {\n    throw new Error(\"Not all currency items were the same for private order\");\n  }\n  var _a = paymentItems.reduce(function (_a, item) {\n      var aggregatedStartAmount = _a.aggregatedStartAmount,\n        aggregatedEndAmount = _a.aggregatedEndAmount;\n      return {\n        aggregatedStartAmount: aggregatedStartAmount.add(item.startAmount),\n        aggregatedEndAmount: aggregatedEndAmount.add(item.endAmount)\n      };\n    }, {\n      aggregatedStartAmount: ethers_1.BigNumber.from(0),\n      aggregatedEndAmount: ethers_1.BigNumber.from(0)\n    }),\n    aggregatedStartAmount = _a.aggregatedStartAmount,\n    aggregatedEndAmount = _a.aggregatedEndAmount;\n  var counterOrder = {\n    parameters: __assign(__assign({}, order.parameters), {\n      offerer: privateSaleRecipient,\n      offer: [{\n        itemType: paymentItems[0].itemType,\n        token: paymentItems[0].token,\n        identifierOrCriteria: paymentItems[0].identifierOrCriteria,\n        startAmount: aggregatedStartAmount.toString(),\n        endAmount: aggregatedEndAmount.toString()\n      }],\n      // The consideration here is empty as the original private listing order supplies\n      // the taker address to receive the desired items.\n      consideration: [],\n      salt: (0, order_1.generateRandomSalt)(),\n      totalOriginalConsiderationItems: 0\n    }),\n    signature: \"0x\"\n  };\n  return counterOrder;\n};\nexports.constructPrivateListingCounterOrder = constructPrivateListingCounterOrder;\nvar getPrivateListingFulfillments = function getPrivateListingFulfillments(privateListingOrder) {\n  var nftRelatedFulfillments = [];\n  // For the original order, we need to match everything offered with every consideration item\n  // on the original order that's set to go to the private listing recipient\n  privateListingOrder.parameters.offer.forEach(function (offerItem, offerIndex) {\n    var considerationIndex = privateListingOrder.parameters.consideration.findIndex(function (considerationItem) {\n      return considerationItem.itemType === offerItem.itemType && considerationItem.token === offerItem.token && considerationItem.identifierOrCriteria === offerItem.identifierOrCriteria;\n    });\n    if (considerationIndex === -1) {\n      throw new Error(\"Could not find matching offer item in the consideration for private listing\");\n    }\n    nftRelatedFulfillments.push({\n      offerComponents: [{\n        orderIndex: 0,\n        itemIndex: offerIndex\n      }],\n      considerationComponents: [{\n        orderIndex: 0,\n        itemIndex: considerationIndex\n      }]\n    });\n  });\n  var currencyRelatedFulfillments = [];\n  // For the original order, we need to match everything offered with every consideration item\n  // on the original order that's set to go to the private listing recipient\n  privateListingOrder.parameters.consideration.forEach(function (considerationItem, considerationIndex) {\n    if (!(0, item_1.isCurrencyItem)(considerationItem)) {\n      return;\n    }\n    // We always match the offer item (index 0) of the counter order (index 1)\n    // with all of the payment items on the private listing\n    currencyRelatedFulfillments.push({\n      offerComponents: [{\n        orderIndex: 1,\n        itemIndex: 0\n      }],\n      considerationComponents: [{\n        orderIndex: 0,\n        itemIndex: considerationIndex\n      }]\n    });\n  });\n  return __spreadArray(__spreadArray([], nftRelatedFulfillments, true), currencyRelatedFulfillments, true);\n};\nexports.getPrivateListingFulfillments = getPrivateListingFulfillments;","map":null,"metadata":{},"sourceType":"script"}