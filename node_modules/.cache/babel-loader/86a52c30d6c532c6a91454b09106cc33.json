{"ast":null,"code":"var _require = require('ethereumjs-util'),\n  BN = _require.BN,\n  keccak = _require.keccak,\n  keccak256 = _require.keccak256,\n  rlphash = _require.rlphash,\n  zeros = _require.zeros,\n  bufferToInt = _require.bufferToInt,\n  TWO_POW256 = _require.TWO_POW256;\nvar ethHashUtil = require('./util.js');\nvar xor = require('buffer-xor');\nvar async = require('async');\nvar Ethash = module.exports = function (cacheDB) {\n  this.dbOpts = {\n    valueEncoding: 'json'\n  };\n  this.cacheDB = cacheDB;\n  this.cache = false;\n};\nEthash.prototype.mkcache = function (cacheSize, seed) {\n  // console.log('generating cache')\n  // console.log('size: ' + cacheSize)\n  // console.log('seed: ' + seed.toString('hex'))\n  var n = Math.floor(cacheSize / ethHashUtil.params.HASH_BYTES);\n  var o = [keccak(seed, 512)];\n  var i;\n  for (i = 1; i < n; i++) {\n    o.push(keccak(o[o.length - 1], 512));\n  }\n  for (var _ = 0; _ < ethHashUtil.params.CACHE_ROUNDS; _++) {\n    for (i = 0; i < n; i++) {\n      var v = o[i].readUInt32LE(0) % n;\n      o[i] = keccak(xor(o[(i - 1 + n) % n], o[v]), 512);\n    }\n  }\n  this.cache = o;\n  return this.cache;\n};\nEthash.prototype.calcDatasetItem = function (i) {\n  var n = this.cache.length;\n  var r = Math.floor(ethHashUtil.params.HASH_BYTES / ethHashUtil.params.WORD_BYTES);\n  var mix = Buffer.from(this.cache[i % n]);\n  mix.writeInt32LE(mix.readUInt32LE(0) ^ i, 0);\n  mix = keccak(mix, 512);\n  for (var j = 0; j < ethHashUtil.params.DATASET_PARENTS; j++) {\n    var cacheIndex = ethHashUtil.fnv(i ^ j, mix.readUInt32LE(j % r * 4));\n    mix = ethHashUtil.fnvBuffer(mix, this.cache[cacheIndex % n]);\n  }\n  return keccak(mix, 512);\n};\nEthash.prototype.run = function (val, nonce, fullSize) {\n  fullSize = fullSize || this.fullSize;\n  var n = Math.floor(fullSize / ethHashUtil.params.HASH_BYTES);\n  var w = Math.floor(ethHashUtil.params.MIX_BYTES / ethHashUtil.params.WORD_BYTES);\n  var s = keccak(Buffer.concat([val, ethHashUtil.bufReverse(nonce)]), 512);\n  var mixhashes = Math.floor(ethHashUtil.params.MIX_BYTES / ethHashUtil.params.HASH_BYTES);\n  var mix = Buffer.concat(Array(mixhashes).fill(s));\n  var i;\n  for (i = 0; i < ethHashUtil.params.ACCESSES; i++) {\n    var p = ethHashUtil.fnv(i ^ s.readUInt32LE(0), mix.readUInt32LE(i % w * 4)) % Math.floor(n / mixhashes) * mixhashes;\n    var newdata = [];\n    for (var j = 0; j < mixhashes; j++) {\n      newdata.push(this.calcDatasetItem(p + j));\n    }\n    newdata = Buffer.concat(newdata);\n    mix = ethHashUtil.fnvBuffer(mix, newdata);\n  }\n  var cmix = Buffer.alloc(mix.length / 4);\n  for (i = 0; i < mix.length / 4; i = i + 4) {\n    var a = ethHashUtil.fnv(mix.readUInt32LE(i * 4), mix.readUInt32LE((i + 1) * 4));\n    var b = ethHashUtil.fnv(a, mix.readUInt32LE((i + 2) * 4));\n    var c = ethHashUtil.fnv(b, mix.readUInt32LE((i + 3) * 4));\n    cmix.writeUInt32LE(c, i);\n  }\n  return {\n    mix: cmix,\n    hash: keccak256(Buffer.concat([s, cmix]))\n  };\n};\nEthash.prototype.cacheHash = function () {\n  return keccak256(Buffer.concat(this.cache));\n};\nEthash.prototype.headerHash = function (header) {\n  return rlphash(header.slice(0, -2));\n};\n\n/**\n * Loads the seed and the cache given a block nnumber\n * @method loadEpoc\n * @param number Number\n * @param cm function\n */\nEthash.prototype.loadEpoc = function (number, cb) {\n  var self = this;\n  var epoc = ethHashUtil.getEpoc(number);\n  if (this.epoc === epoc) {\n    return cb();\n  }\n  this.epoc = epoc;\n\n  // gives the seed the first epoc found\n  function findLastSeed(epoc, cb2) {\n    if (epoc === 0) {\n      return cb2(zeros(32), 0);\n    }\n    self.cacheDB.get(epoc, self.dbOpts, function (err, data) {\n      if (!err) {\n        cb2(data.seed, epoc);\n      } else {\n        findLastSeed(epoc - 1, cb2);\n      }\n    });\n  }\n\n  /* eslint-disable handle-callback-err */\n  self.cacheDB.get(epoc, self.dbOpts, function (err, data) {\n    if (!data) {\n      self.cacheSize = ethHashUtil.getCacheSize(epoc);\n      self.fullSize = ethHashUtil.getFullSize(epoc);\n      findLastSeed(epoc, function (seed, foundEpoc) {\n        self.seed = ethHashUtil.getSeed(seed, foundEpoc, epoc);\n        var cache = self.mkcache(self.cacheSize, self.seed);\n        // store the generated cache\n        self.cacheDB.put(epoc, {\n          cacheSize: self.cacheSize,\n          fullSize: self.fullSize,\n          seed: self.seed,\n          cache: cache\n        }, self.dbOpts, cb);\n      });\n    } else {\n      // Object.assign(self, data)\n      self.cache = data.cache.map(function (a) {\n        return Buffer.from(a);\n      });\n      self.cacheSize = data.cacheSize;\n      self.fullSize = data.fullSize;\n      self.seed = Buffer.from(data.seed);\n      cb();\n    }\n  });\n  /* eslint-enable handle-callback-err */\n};\n\nEthash.prototype._verifyPOW = function (header, cb) {\n  var self = this;\n  var headerHash = this.headerHash(header.raw);\n  var number = bufferToInt(header.number);\n  this.loadEpoc(number, function () {\n    var a = self.run(headerHash, Buffer.from(header.nonce, 'hex'));\n    var result = new BN(a.hash);\n    /* eslint-disable standard/no-callback-literal */\n    cb(a.mix.toString('hex') === header.mixHash.toString('hex') && TWO_POW256.div(new BN(header.difficulty)).cmp(result) === 1);\n    /* eslint-enable standard/no-callback-literal */\n  });\n};\n\nEthash.prototype.verifyPOW = function (block, cb) {\n  var self = this;\n  var valid = true;\n\n  // don't validate genesis blocks\n  if (block.header.isGenesis()) {\n    cb(true); // eslint-disable-line standard/no-callback-literal\n    return;\n  }\n  this._verifyPOW(block.header, function (valid2) {\n    valid &= valid2;\n    if (!valid) {\n      return cb(valid);\n    }\n    async.eachSeries(block.uncleHeaders, function (uheader, cb2) {\n      self._verifyPOW(uheader, function (valid3) {\n        valid &= valid3;\n        if (!valid) {\n          cb2(Boolean(valid));\n        } else {\n          cb2();\n        }\n      });\n    }, function () {\n      cb(Boolean(valid));\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}