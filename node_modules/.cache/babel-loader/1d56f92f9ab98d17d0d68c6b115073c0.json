{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidProtocol = exports.feesToBasisPoints = exports.getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = exports.getAssetItemType = exports.hasErrorCode = exports.getMaxOrderExpirationTimestamp = exports.merkleValidatorByNetwork = exports.getNonCompliantApprovalAddress = exports.onDeprecated = exports.validateAndFormatWalletAddress = exports.delay = exports.assignOrdersToSides = exports.getOrderHash = exports.getWyvernBundle = exports.getWyvernAsset = exports.estimateCurrentPrice = exports.getTransferFeeSettings = exports.getCurrentGasPrice = exports.estimateGas = exports.rawCall = exports.sendRawTransaction = exports.makeBigNumber = exports.isContractAddress = exports.signTypedDataAsync = exports.personalSignAsync = exports.orderToJSON = exports.orderFromJSON = exports.tokenFromJSON = exports.collectionFromJSON = exports.assetContractFromJSON = exports.assetBundleFromJSON = exports.userFromJSON = exports.accountFromJSON = exports.transactionFromJSON = exports.assetEventFromJSON = exports.assetFromJSON = exports.confirmTransaction = exports.promisifyCall = exports.annotateERC20TransferABI = exports.annotateERC721TransferABI = exports.WyvernProtocol = void 0;\nvar constants_1 = require(\"@opensea/seaport-js/lib/constants\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar ethUtil = __importStar(require(\"ethereumjs-util\"));\nvar _ = __importStar(require(\"lodash\"));\nvar web3_1 = __importDefault(require(\"web3\"));\nvar wyvern_js_1 = require(\"wyvern-js\");\nObject.defineProperty(exports, \"WyvernProtocol\", {\n  enumerable: true,\n  get: function get() {\n    return wyvern_js_1.WyvernProtocol;\n  }\n});\nvar types_1 = require(\"wyvern-schemas/dist/types\");\nvar constants_2 = require(\"../constants\");\nvar contracts_1 = require(\"../contracts\");\nvar types_2 = require(\"../types\");\nvar annotateERC721TransferABI = function annotateERC721TransferABI(asset) {\n  return {\n    constant: false,\n    inputs: [{\n      name: \"_to\",\n      type: \"address\",\n      kind: types_1.FunctionInputKind.Replaceable\n    }, {\n      name: \"_tokenId\",\n      type: \"uint256\",\n      kind: types_1.FunctionInputKind.Asset,\n      value: asset.id\n    }],\n    target: asset.address,\n    name: \"transfer\",\n    outputs: [],\n    payable: false,\n    stateMutability: types_1.StateMutability.Nonpayable,\n    type: ethereum_types_1.AbiType.Function\n  };\n};\nexports.annotateERC721TransferABI = annotateERC721TransferABI;\nvar annotateERC20TransferABI = function annotateERC20TransferABI(asset) {\n  return {\n    constant: false,\n    inputs: [{\n      name: \"_to\",\n      type: \"address\",\n      kind: types_1.FunctionInputKind.Replaceable\n    }, {\n      name: \"_amount\",\n      type: \"uint256\",\n      kind: types_1.FunctionInputKind.Count,\n      value: asset.quantity\n    }],\n    target: asset.address,\n    name: \"transfer\",\n    outputs: [{\n      name: \"success\",\n      type: \"bool\",\n      kind: types_1.FunctionOutputKind.Other\n    }],\n    payable: false,\n    stateMutability: types_1.StateMutability.Nonpayable,\n    type: ethereum_types_1.AbiType.Function\n  };\n};\nexports.annotateERC20TransferABI = annotateERC20TransferABI;\n// OTHER\nvar txCallbacks = {};\n/**\n * Promisify a callback-syntax web3 function\n * @param inner callback function that accepts a Web3 callback function and passes\n * it to the Web3 function\n */\nfunction promisify(inner) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/, new Promise(function (resolve, reject) {\n        return inner(function (err, res) {\n          if (err) {\n            reject(err);\n          }\n          resolve(res);\n        });\n      })];\n    });\n  });\n}\n/**\n * Promisify a call a method on a contract,\n * handling Parity errors. Returns '0x' if error.\n * Note that if T is not \"string\", this may return a falsey\n * value when the contract doesn't support the method (e.g. `isApprovedForAll`).\n * @param callback An anonymous function that takes a web3 callback\n * and returns a Web3 Contract's call result, e.g. `c => erc721.ownerOf(3, c)`\n * @param onError callback when user denies transaction\n */\nfunction promisifyCall(callback, onError) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 2,, 3]);\n          return [4 /*yield*/, promisify(callback)];\n        case 1:\n          result = _a.sent();\n          if (typeof result === \"string\" && result == \"0x\") {\n            // Geth compatibility\n            return [2 /*return*/, undefined];\n          }\n          return [2 /*return*/, result];\n        case 2:\n          error_1 = _a.sent();\n          // Probably method not found, and web3 is a Parity node\n          if (onError) {\n            onError(error_1);\n          } else {\n            console.error(error_1);\n          }\n          return [2 /*return*/, undefined];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.promisifyCall = promisifyCall;\nvar track = function track(web3, txHash, onFinalized) {\n  if (txCallbacks[txHash]) {\n    txCallbacks[txHash].push(onFinalized);\n  } else {\n    txCallbacks[txHash] = [onFinalized];\n    var poll_1 = function poll_1() {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var tx, receipt, status_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, web3.eth.getTransaction(txHash)];\n            case 1:\n              tx = _a.sent();\n              if (!(tx && tx.blockHash && tx.blockHash !== constants_2.NULL_BLOCK_HASH)) return [3 /*break*/, 3];\n              return [4 /*yield*/, web3.eth.getTransactionReceipt(txHash)];\n            case 2:\n              receipt = _a.sent();\n              if (!receipt) {\n                // Hack: assume success if no receipt\n                console.warn(\"No receipt found for \", txHash);\n              }\n              status_1 = receipt.status;\n              txCallbacks[txHash].map(function (f) {\n                return f(status_1);\n              });\n              delete txCallbacks[txHash];\n              return [3 /*break*/, 4];\n            case 3:\n              setTimeout(poll_1, 1000);\n              _a.label = 4;\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    poll_1().catch();\n  }\n};\nvar confirmTransaction = function confirmTransaction(web3, txHash) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/, new Promise(function (resolve, reject) {\n        track(web3, txHash, function (didSucceed) {\n          if (didSucceed) {\n            resolve(\"Transaction complete!\");\n          } else {\n            reject(new Error(\"Transaction failed :( You might have already completed this action. See more on the mainnet at etherscan.io/tx/\".concat(txHash)));\n          }\n        });\n      })];\n    });\n  });\n};\nexports.confirmTransaction = confirmTransaction;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar assetFromJSON = function assetFromJSON(asset) {\n  var isAnimated = asset.image_url && asset.image_url.endsWith(\".gif\");\n  var isSvg = asset.image_url && asset.image_url.endsWith(\".svg\");\n  var fromJSON = {\n    tokenId: asset.token_id.toString(),\n    tokenAddress: asset.asset_contract.address,\n    name: asset.name,\n    description: asset.description,\n    owner: asset.owner,\n    assetContract: (0, exports.assetContractFromJSON)(asset.asset_contract),\n    collection: (0, exports.collectionFromJSON)(asset.collection),\n    orders: asset.orders ? asset.orders.map(exports.orderFromJSON) : null,\n    sellOrders: asset.sell_orders ? asset.sell_orders.map(exports.orderFromJSON) : null,\n    buyOrders: asset.buy_orders ? asset.buy_orders.map(exports.orderFromJSON) : null,\n    isPresale: asset.is_presale,\n    // Don't use previews if it's a special image\n    imageUrl: isAnimated || isSvg ? asset.image_url : asset.image_preview_url || asset.image_url,\n    imagePreviewUrl: asset.image_preview_url,\n    imageUrlOriginal: asset.image_original_url,\n    imageUrlThumbnail: asset.image_thumbnail_url,\n    externalLink: asset.external_link,\n    openseaLink: asset.permalink,\n    traits: asset.traits,\n    numSales: asset.num_sales,\n    lastSale: asset.last_sale ? (0, exports.assetEventFromJSON)(asset.last_sale) : null,\n    backgroundColor: asset.background_color ? \"#\".concat(asset.background_color) : null\n  };\n  // If orders were included, put them in sell/buy order groups\n  if (fromJSON.orders && !fromJSON.sellOrders) {\n    fromJSON.sellOrders = fromJSON.orders.filter(function (o) {\n      return o.side == types_2.OrderSide.Sell;\n    });\n  }\n  if (fromJSON.orders && !fromJSON.buyOrders) {\n    fromJSON.buyOrders = fromJSON.orders.filter(function (o) {\n      return o.side == types_2.OrderSide.Buy;\n    });\n  }\n  return fromJSON;\n};\nexports.assetFromJSON = assetFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar assetEventFromJSON = function assetEventFromJSON(assetEvent) {\n  return {\n    eventType: assetEvent.event_type,\n    eventTimestamp: assetEvent.event_timestamp,\n    auctionType: assetEvent.auction_type,\n    totalPrice: assetEvent.total_price,\n    transaction: assetEvent.transaction ? (0, exports.transactionFromJSON)(assetEvent.transaction) : null,\n    paymentToken: assetEvent.payment_token ? (0, exports.tokenFromJSON)(assetEvent.payment_token) : null\n  };\n};\nexports.assetEventFromJSON = assetEventFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar transactionFromJSON = function transactionFromJSON(transaction) {\n  return {\n    fromAccount: (0, exports.accountFromJSON)(transaction.from_account),\n    toAccount: (0, exports.accountFromJSON)(transaction.to_account),\n    createdDate: new Date(\"\".concat(transaction.created_date, \"Z\")),\n    modifiedDate: new Date(\"\".concat(transaction.modified_date, \"Z\")),\n    transactionHash: transaction.transaction_hash,\n    transactionIndex: transaction.transaction_index,\n    blockNumber: transaction.block_number,\n    blockHash: transaction.block_hash,\n    timestamp: new Date(\"\".concat(transaction.timestamp, \"Z\"))\n  };\n};\nexports.transactionFromJSON = transactionFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar accountFromJSON = function accountFromJSON(account) {\n  return {\n    address: account.address,\n    config: account.config,\n    profileImgUrl: account.profile_img_url,\n    user: account.user ? (0, exports.userFromJSON)(account.user) : null\n  };\n};\nexports.accountFromJSON = accountFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar userFromJSON = function userFromJSON(user) {\n  return {\n    username: user.username\n  };\n};\nexports.userFromJSON = userFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar assetBundleFromJSON = function assetBundleFromJSON(asset_bundle) {\n  var fromJSON = {\n    maker: asset_bundle.maker,\n    assets: asset_bundle.assets ? asset_bundle.assets.map(exports.assetFromJSON) : [],\n    assetContract: asset_bundle.asset_contract ? (0, exports.assetContractFromJSON)(asset_bundle.asset_contract) : undefined,\n    name: asset_bundle.name,\n    slug: asset_bundle.slug,\n    description: asset_bundle.description,\n    externalLink: asset_bundle.external_link,\n    permalink: asset_bundle.permalink,\n    sellOrders: asset_bundle.sell_orders ? asset_bundle.sell_orders.map(exports.orderFromJSON) : null\n  };\n  return fromJSON;\n};\nexports.assetBundleFromJSON = assetBundleFromJSON;\nvar assetContractFromJSON = function assetContractFromJSON(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasset_contract) {\n  return {\n    name: asset_contract.name,\n    description: asset_contract.description,\n    type: asset_contract.asset_contract_type,\n    schemaName: asset_contract.schema_name,\n    address: asset_contract.address,\n    tokenSymbol: asset_contract.symbol,\n    buyerFeeBasisPoints: +asset_contract.buyer_fee_basis_points,\n    sellerFeeBasisPoints: +asset_contract.seller_fee_basis_points,\n    openseaBuyerFeeBasisPoints: +asset_contract.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +asset_contract.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +asset_contract.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +asset_contract.dev_seller_fee_basis_points,\n    imageUrl: asset_contract.image_url,\n    externalLink: asset_contract.external_link,\n    wikiLink: asset_contract.wiki_link\n  };\n};\nexports.assetContractFromJSON = assetContractFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar collectionFromJSON = function collectionFromJSON(collection) {\n  var createdDate = new Date(\"\".concat(collection.created_date, \"Z\"));\n  return {\n    createdDate: createdDate,\n    name: collection.name,\n    description: collection.description,\n    slug: collection.slug,\n    editors: collection.editors,\n    hidden: collection.hidden,\n    featured: collection.featured,\n    featuredImageUrl: collection.featured_image_url,\n    displayData: collection.display_data,\n    paymentTokens: (collection.payment_tokens || []).map(exports.tokenFromJSON),\n    openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,\n    payoutAddress: collection.payout_address,\n    imageUrl: collection.image_url,\n    largeImageUrl: collection.large_image_url,\n    stats: collection.stats,\n    traitStats: collection.traits,\n    externalLink: collection.external_url,\n    wikiLink: collection.wiki_url,\n    fees: {\n      openseaFees: new Map(Object.entries(collection.fees.opensea_fees || {})),\n      sellerFees: new Map(Object.entries(collection.fees.seller_fees || {}))\n    }\n  };\n};\nexports.collectionFromJSON = collectionFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar tokenFromJSON = function tokenFromJSON(token) {\n  var fromJSON = {\n    name: token.name,\n    symbol: token.symbol,\n    decimals: token.decimals,\n    address: token.address,\n    imageUrl: token.image_url,\n    ethPrice: token.eth_price,\n    usdPrice: token.usd_price\n  };\n  return fromJSON;\n};\nexports.tokenFromJSON = tokenFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar orderFromJSON = function orderFromJSON(order) {\n  var createdDate = new Date(\"\".concat(order.created_date, \"Z\"));\n  var fromJSON = {\n    hash: order.order_hash || order.hash,\n    cancelledOrFinalized: order.cancelled || order.finalized,\n    markedInvalid: order.marked_invalid,\n    metadata: order.metadata,\n    quantity: new bignumber_js_1.default(order.quantity || 1),\n    exchange: order.exchange,\n    makerAccount: order.maker,\n    takerAccount: order.taker,\n    // Use string address to conform to Wyvern Order schema\n    maker: order.maker.address,\n    taker: order.taker.address,\n    makerRelayerFee: new bignumber_js_1.default(order.maker_relayer_fee),\n    takerRelayerFee: new bignumber_js_1.default(order.taker_relayer_fee),\n    makerProtocolFee: new bignumber_js_1.default(order.maker_protocol_fee),\n    takerProtocolFee: new bignumber_js_1.default(order.taker_protocol_fee),\n    makerReferrerFee: new bignumber_js_1.default(order.maker_referrer_fee || 0),\n    waitingForBestCounterOrder: order.fee_recipient.address == constants_2.NULL_ADDRESS,\n    feeMethod: order.fee_method,\n    feeRecipientAccount: order.fee_recipient,\n    feeRecipient: order.fee_recipient.address,\n    side: order.side,\n    saleKind: order.sale_kind,\n    target: order.target,\n    howToCall: order.how_to_call,\n    calldata: order.calldata,\n    replacementPattern: order.replacement_pattern,\n    staticTarget: order.static_target,\n    staticExtradata: order.static_extradata,\n    paymentToken: order.payment_token,\n    basePrice: new bignumber_js_1.default(order.base_price),\n    extra: new bignumber_js_1.default(order.extra),\n    currentBounty: new bignumber_js_1.default(order.current_bounty || 0),\n    currentPrice: new bignumber_js_1.default(order.current_price || 0),\n    createdTime: new bignumber_js_1.default(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new bignumber_js_1.default(order.listing_time),\n    expirationTime: new bignumber_js_1.default(order.expiration_time),\n    salt: new bignumber_js_1.default(order.salt),\n    v: parseInt(order.v),\n    r: order.r,\n    s: order.s,\n    paymentTokenContract: order.payment_token_contract ? (0, exports.tokenFromJSON)(order.payment_token_contract) : undefined,\n    asset: order.asset ? (0, exports.assetFromJSON)(order.asset) : undefined,\n    assetBundle: order.asset_bundle ? (0, exports.assetBundleFromJSON)(order.asset_bundle) : undefined\n  };\n  // Use client-side price calc, to account for buyer fee (not added by server) and latency\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\nexports.orderFromJSON = orderFromJSON;\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nvar orderToJSON = function orderToJSON(order) {\n  var asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce\n  };\n  return asJSON;\n};\nexports.orderToJSON = orderToJSON;\n/**\n * Sign messages using web3 personal signatures\n * @param web3 Web3 instance\n * @param message message to sign\n * @param signerAddress web3 address signing the message\n * @returns A signature if provider can sign, otherwise null\n */\nfunction personalSignAsync(web3, message, signerAddress) {\n  return __awaiter(this, void 0, void 0, function () {\n    var signature, error;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, promisify(function (c) {\n            return web3.currentProvider.sendAsync({\n              method: \"personal_sign\",\n              params: [message, signerAddress],\n              from: signerAddress,\n              id: new Date().getTime()\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, c);\n          })];\n        case 1:\n          signature = _a.sent();\n          error = signature.error;\n          if (error) {\n            throw new Error(error);\n          }\n          return [2 /*return*/, parseSignatureHex(signature === null || signature === void 0 ? void 0 : signature.result)];\n      }\n    });\n  });\n}\nexports.personalSignAsync = personalSignAsync;\n/**\n * Sign messages using web3 signTypedData signatures\n * @param web3 Web3 instance\n * @param message message to sign\n * @param signerAddress web3 address signing the message\n * @returns A signature if provider can sign, otherwise null\n */\nfunction signTypedDataAsync(web3, message, signerAddress) {\n  return __awaiter(this, void 0, void 0, function () {\n    var signature, _a, error;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _b.trys.push([0, 2,, 4]);\n          return [4 /*yield*/, promisify(function (c) {\n            return web3.currentProvider.sendAsync({\n              method: \"eth_signTypedData_v4\",\n              params: [signerAddress, JSON.stringify(message)],\n              from: signerAddress,\n              id: new Date().getTime()\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, c);\n          })];\n        case 1:\n          // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n          signature = _b.sent();\n          return [3 /*break*/, 4];\n        case 2:\n          _a = _b.sent();\n          return [4 /*yield*/, promisify(function (c) {\n            return web3.currentProvider.sendAsync({\n              method: \"eth_signTypedData\",\n              params: [signerAddress, message],\n              from: signerAddress,\n              id: new Date().getTime()\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }, c);\n          })];\n        case 3:\n          // Fallback to normal sign typed data for node providers, without using stringified message\n          // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n          signature = _b.sent();\n          return [3 /*break*/, 4];\n        case 4:\n          error = signature.error;\n          if (error) {\n            throw new Error(error);\n          }\n          return [2 /*return*/, parseSignatureHex(signature === null || signature === void 0 ? void 0 : signature.result)];\n      }\n    });\n  });\n}\nexports.signTypedDataAsync = signTypedDataAsync;\n/**\n * Checks whether a given address contains any code\n * @param web3 Web3 instance\n * @param address input address\n */\nfunction isContractAddress(web3, address) {\n  return __awaiter(this, void 0, void 0, function () {\n    var code;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, web3.eth.getCode(address)];\n        case 1:\n          code = _a.sent();\n          return [2 /*return*/, code !== \"0x\"];\n      }\n    });\n  });\n}\nexports.isContractAddress = isContractAddress;\n/**\n * Special fixes for making BigNumbers using web3 results\n * @param arg An arg or the result of a web3 call to turn into a BigNumber\n */\nfunction makeBigNumber(arg) {\n  // Zero sometimes returned as 0x from contracts\n  if (arg === \"0x\") {\n    arg = 0;\n  }\n  // fix \"new BigNumber() number type has more than 15 significant digits\"\n  arg = arg.toString();\n  return new bignumber_js_1.default(arg);\n}\nexports.makeBigNumber = makeBigNumber;\n/**\n * Send a transaction to the blockchain and optionally confirm it\n * @param web3 Web3 instance\n * @param param0 __namedParameters\n * @param from address sending transaction\n * @param to destination contract address\n * @param data data to send to contract\n * @param gasPrice gas price to use. If unspecified, uses web3 default (mean gas price)\n * @param value value in ETH to send with data. Defaults to 0\n * @param onError callback when user denies transaction\n */\nfunction sendRawTransaction(web3, _a, onError) {\n  var from = _a.from,\n    to = _a.to,\n    data = _a.data,\n    gasPrice = _a.gasPrice,\n    _b = _a.value,\n    value = _b === void 0 ? 0 : _b,\n    gas = _a.gas;\n  return __awaiter(this, void 0, void 0, function () {\n    var txHashRes, error_2;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          if (!(gas == null)) return [3 /*break*/, 2];\n          return [4 /*yield*/, estimateGas(web3, {\n            from: from,\n            to: to,\n            data: data,\n            value: value\n          })];\n        case 1:\n          // This gas cannot be increased due to an ethjs error\n          gas = _c.sent();\n          _c.label = 2;\n        case 2:\n          _c.trys.push([2, 4,, 5]);\n          return [4 /*yield*/, promisify(function (c) {\n            return web3.eth.sendTransaction({\n              from: from,\n              to: to,\n              value: value.toString(),\n              data: data,\n              gas: gas === null || gas === void 0 ? void 0 : gas.toString(),\n              gasPrice: gasPrice === null || gasPrice === void 0 ? void 0 : gasPrice.toString()\n            }, c);\n          })];\n        case 3:\n          txHashRes = _c.sent();\n          return [2 /*return*/, txHashRes];\n        case 4:\n          error_2 = _c.sent();\n          onError(error_2);\n          throw error_2;\n        case 5:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.sendRawTransaction = sendRawTransaction;\n/**\n * Call a method on a contract, sending arbitrary data and\n * handling Parity errors. Returns '0x' if error.\n * @param web3 Web3 instance\n * @param param0 __namedParameters\n * @param from address sending call\n * @param to destination contract address\n * @param data data to send to contract\n * @param onError callback when user denies transaction\n */\nfunction rawCall(web3, _a, onError) {\n  var from = _a.from,\n    to = _a.to,\n    data = _a.data;\n  return __awaiter(this, void 0, void 0, function () {\n    var result, error_3;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _b.trys.push([0, 2,, 3]);\n          return [4 /*yield*/, web3.eth.call({\n            from: from,\n            to: to,\n            data: data\n          })];\n        case 1:\n          result = _b.sent();\n          return [2 /*return*/, result];\n        case 2:\n          error_3 = _b.sent();\n          // Probably method not found, and web3 is a Parity node\n          if (onError) {\n            onError(error_3);\n          }\n          // Backwards compatibility with Geth nodes\n          return [2 /*return*/, \"0x\"];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.rawCall = rawCall;\n/**\n * Estimate Gas usage for a transaction\n * @param web3 Web3 instance\n * @param from address sending transaction\n * @param to destination contract address\n * @param data data to send to contract\n * @param value value in ETH to send with data\n */\nfunction estimateGas(web3, _a) {\n  var from = _a.from,\n    to = _a.to,\n    data = _a.data,\n    _b = _a.value,\n    value = _b === void 0 ? 0 : _b;\n  return __awaiter(this, void 0, void 0, function () {\n    var amount;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4 /*yield*/, web3.eth.estimateGas({\n            from: from,\n            to: to,\n            value: value.toString(),\n            data: data\n          })];\n        case 1:\n          amount = _c.sent();\n          return [2 /*return*/, amount];\n      }\n    });\n  });\n}\nexports.estimateGas = estimateGas;\n/**\n * Get mean gas price for sending a txn, in wei\n * @param web3 Web3 instance\n */\nfunction getCurrentGasPrice(web3) {\n  return __awaiter(this, void 0, void 0, function () {\n    var gasPrice;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, web3.eth.getGasPrice()];\n        case 1:\n          gasPrice = _a.sent();\n          return [2 /*return*/, new bignumber_js_1.default(gasPrice)];\n      }\n    });\n  });\n}\nexports.getCurrentGasPrice = getCurrentGasPrice;\n/**\n * Get current transfer fees for an asset\n * @param web3 Web3 instance\n * @param asset The asset to check for transfer fees\n */\nfunction getTransferFeeSettings(web3, _a) {\n  var asset = _a.asset,\n    accountAddress = _a.accountAddress;\n  return __awaiter(this, void 0, void 0, function () {\n    var transferFee, transferFeeTokenAddress, feeContract, params;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (!(asset.tokenAddress.toLowerCase() == constants_2.ENJIN_ADDRESS.toLowerCase())) return [3 /*break*/, 2];\n          feeContract = new web3.eth.Contract(contracts_1.ERC1155, asset.tokenAddress);\n          return [4 /*yield*/, feeContract.methods.transferSettings(asset.tokenId).call({\n            from: accountAddress\n          })];\n        case 1:\n          params = _b.sent();\n          if (params) {\n            transferFee = makeBigNumber(params[3]);\n            if (params[2] === \"0\") {\n              transferFeeTokenAddress = constants_2.ENJIN_COIN_ADDRESS;\n            }\n          }\n          _b.label = 2;\n        case 2:\n          return [2 /*return*/, {\n            transferFee: transferFee,\n            transferFeeTokenAddress: transferFeeTokenAddress\n          }];\n      }\n    });\n  });\n}\nexports.getTransferFeeSettings = getTransferFeeSettings;\n// sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\nfunction parseSignatureHex(signature) {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  var validVParamValues = [27, 28];\n  var ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  }\n  // For older clients\n  var ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n  throw new Error(\"Invalid signature\");\n  function _parseSignatureHexAsVRS(signatureHex) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var signatureBuffer = ethUtil.toBuffer(signatureHex);\n    var v = signatureBuffer[0];\n    if (v < 27) {\n      v += 27;\n    }\n    var r = signatureBuffer.slice(1, 33);\n    var s = signatureBuffer.slice(33, 65);\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n  function _parseSignatureHexAsRSV(signatureHex) {\n    var _a = ethUtil.fromRpcSig(signatureHex),\n      v = _a.v,\n      r = _a.r,\n      s = _a.s;\n    var ecSignature = {\n      v: v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n}\n/**\n * Estimates the price of an order\n * @param order The order to estimate price on\n * @param secondsToBacktrack The number of seconds to subtract on current time,\n *  to fix race conditions\n * @param shouldRoundUp Whether to round up fractional wei\n */\nfunction estimateCurrentPrice(order, secondsToBacktrack, shouldRoundUp) {\n  if (secondsToBacktrack === void 0) {\n    secondsToBacktrack = 30;\n  }\n  if (shouldRoundUp === void 0) {\n    shouldRoundUp = true;\n  }\n  var basePrice = order.basePrice,\n    listingTime = order.listingTime,\n    expirationTime = order.expirationTime,\n    extra = order.extra;\n  var side = order.side,\n    takerRelayerFee = order.takerRelayerFee,\n    saleKind = order.saleKind;\n  var now = new bignumber_js_1.default(Math.round(Date.now() / 1000)).minus(secondsToBacktrack);\n  basePrice = new bignumber_js_1.default(basePrice);\n  listingTime = new bignumber_js_1.default(listingTime);\n  expirationTime = new bignumber_js_1.default(expirationTime);\n  extra = new bignumber_js_1.default(extra);\n  var exactPrice = basePrice;\n  if (saleKind === types_2.SaleKind.FixedPrice) {\n    // Do nothing, price is correct\n  } else if (saleKind === types_2.SaleKind.DutchAuction) {\n    var diff = extra.times(now.minus(listingTime)).dividedBy(expirationTime.minus(listingTime));\n    exactPrice = side == types_2.OrderSide.Sell ? /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n    basePrice.minus(diff) : /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n    basePrice.plus(diff);\n  }\n  // Add taker fee only for buyers\n  if (side === types_2.OrderSide.Sell && !order.waitingForBestCounterOrder) {\n    // Buyer fee increases sale price\n    exactPrice = exactPrice.times(+takerRelayerFee / constants_2.INVERSE_BASIS_POINT + 1);\n  }\n  return shouldRoundUp ? exactPrice.integerValue(bignumber_js_1.default.ROUND_CEIL) : exactPrice;\n}\nexports.estimateCurrentPrice = estimateCurrentPrice;\n/**\n * Get the Wyvern representation of a fungible asset\n * @param schema The WyvernSchema needed to access this asset\n * @param asset The asset to trade\n * @param quantity The number of items to trade\n */\nfunction getWyvernAsset(schema, asset, quantity) {\n  if (quantity === void 0) {\n    quantity = new bignumber_js_1.default(1);\n  }\n  var tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\nexports.getWyvernAsset = getWyvernAsset;\n/**\n * Get the Wyvern representation of a group of assets\n * Sort order is enforced here. Throws if there's a duplicate.\n * @param assets Assets to bundle\n * @param schemas The WyvernSchemas needed to access each asset, respectively\n * @param quantities The quantity of each asset to bundle, respectively\n */\nfunction getWyvernBundle(assets, schemas, quantities) {\n  if (assets.length != quantities.length) {\n    throw new Error(\"Bundle must have a quantity for every asset\");\n  }\n  if (assets.length != schemas.length) {\n    throw new Error(\"Bundle must have a schema for every asset\");\n  }\n  var wyAssets = assets.map(function (asset, i) {\n    return getWyvernAsset(schemas[i], asset, quantities[i]);\n  });\n  var sorters = [function (assetAndSchema) {\n    return assetAndSchema.asset.address;\n  }, function (assetAndSchema) {\n    return assetAndSchema.asset.id || 0;\n  }];\n  var wyAssetsAndSchemas = wyAssets.map(function (asset, i) {\n    return {\n      asset: asset,\n      schema: schemas[i].name\n    };\n  });\n  var uniqueAssets = _.uniqBy(wyAssetsAndSchemas, function (group) {\n    return \"\".concat(sorters[0](group), \"-\").concat(sorters[1](group));\n  });\n  if (uniqueAssets.length != wyAssetsAndSchemas.length) {\n    throw new Error(\"Bundle can't contain duplicate assets\");\n  }\n  var sortedWyAssetsAndSchemas = _.sortBy(wyAssetsAndSchemas, sorters);\n  return {\n    assets: sortedWyAssetsAndSchemas.map(function (group) {\n      return group.asset;\n    }),\n    schemas: sortedWyAssetsAndSchemas.map(function (group) {\n      return group.schema;\n    })\n  };\n}\nexports.getWyvernBundle = getWyvernBundle;\n/**\n * Get the non-prefixed hash for the order\n * (Fixes a Wyvern typescript issue and casing issue)\n * @param order order to hash\n */\nfunction getOrderHash(order) {\n  var orderWithStringTypes = __assign(__assign({}, order), {\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString()\n  });\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return wyvern_js_1.WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\nexports.getOrderHash = getOrderHash;\n/**\n * Assign an order and a new matching order to their buy/sell sides\n * @param order Original order\n * @param matchingOrder The result of _makeMatchingOrder\n */\nfunction assignOrdersToSides(order, matchingOrder) {\n  var isSellOrder = order.side == types_2.OrderSide.Sell;\n  var buy;\n  var sell;\n  if (!isSellOrder) {\n    buy = order;\n    sell = __assign(__assign({}, matchingOrder), {\n      v: buy.v,\n      r: buy.r,\n      s: buy.s\n    });\n  } else {\n    sell = order;\n    buy = __assign(__assign({}, matchingOrder), {\n      v: sell.v,\n      r: sell.r,\n      s: sell.s\n    });\n  }\n  return {\n    buy: buy,\n    sell: sell\n  };\n}\nexports.assignOrdersToSides = assignOrdersToSides;\n/**\n * Delay using setTimeout\n * @param ms milliseconds to wait\n */\nfunction delay(ms) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/, new Promise(function (res) {\n        return setTimeout(res, ms);\n      })];\n    });\n  });\n}\nexports.delay = delay;\n/**\n * Validates that an address exists, isn't null, and is properly\n * formatted for Wyvern and OpenSea\n * @param address input address\n */\nfunction validateAndFormatWalletAddress(web3, address) {\n  if (!address) {\n    throw new Error(\"No wallet address found\");\n  }\n  if (!web3.utils.isAddress(address)) {\n    throw new Error(\"Invalid wallet address\");\n  }\n  if (address == constants_2.NULL_ADDRESS) {\n    throw new Error(\"Wallet cannot be the null address\");\n  }\n  return address.toLowerCase();\n}\nexports.validateAndFormatWalletAddress = validateAndFormatWalletAddress;\n/**\n * Notify developer when a pattern will be deprecated\n * @param msg message to log to console\n */\nfunction onDeprecated(msg) {\n  console.warn(\"DEPRECATION NOTICE: \".concat(msg));\n}\nexports.onDeprecated = onDeprecated;\n/**\n * Get special-case approval addresses for an erc721 contract\n * @param erc721Contract contract to check\n */\nfunction getNonCompliantApprovalAddress(erc721Contract, tokenId, _accountAddress) {\n  return __awaiter(this, void 0, void 0, function () {\n    var results;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, Promise.allSettled([\n          // CRYPTOKITTIES check\n          erc721Contract.methods.kittyIndexToApproved(tokenId).call(),\n          // Etherbots check\n          erc721Contract.methods.partIndexToApproved(tokenId).call()])];\n        case 1:\n          results = _a.sent();\n          return [2 /*return*/, _.compact(results)[0].status];\n      }\n    });\n  });\n}\nexports.getNonCompliantApprovalAddress = getNonCompliantApprovalAddress;\nexports.merkleValidatorByNetwork = (_a = {}, _a[types_1.Network.Main] = constants_2.MERKLE_VALIDATOR_MAINNET, _a[types_1.Network.Rinkeby] = constants_2.MERKLE_VALIDATOR_RINKEBY, _a[types_1.Network.Goerli] = null, _a);\n/**\n * The longest time that an order is valid for is six months from the current date\n * @returns unix timestamp\n */\nvar getMaxOrderExpirationTimestamp = function getMaxOrderExpirationTimestamp() {\n  var maxExpirationDate = new Date();\n  maxExpirationDate.setMonth(maxExpirationDate.getMonth() + constants_2.MAX_EXPIRATION_MONTHS);\n  maxExpirationDate.setDate(maxExpirationDate.getDate() - 1);\n  return Math.round(maxExpirationDate.getTime() / 1000);\n};\nexports.getMaxOrderExpirationTimestamp = getMaxOrderExpirationTimestamp;\nvar hasErrorCode = function hasErrorCode(error) {\n  var untypedError = error;\n  return !!untypedError.code;\n};\nexports.hasErrorCode = hasErrorCode;\nvar getAssetItemType = function getAssetItemType(schemaName) {\n  switch (schemaName) {\n    case \"ERC20\":\n      return constants_1.ItemType.ERC20;\n    case \"ERC721\":\n      return constants_1.ItemType.ERC721;\n    case \"ERC1155\":\n      return constants_1.ItemType.ERC1155;\n    default:\n      throw new Error(\"Unknown schema name: \".concat(schemaName));\n  }\n};\nexports.getAssetItemType = getAssetItemType;\nvar SHARED_STOREFRONT_ADDRESSES = new Set([constants_2.SHARED_STORE_FRONT_ADDRESS_MAINNET.toLowerCase(), constants_2.SHARED_STORE_FRONT_ADDRESS_RINKEBY.toLowerCase()]);\n/**\n * Checks if the token address is the shared storefront address and if so replaces\n * that address with the lazy mint adapter addres. Otherwise, returns the input token address\n * @param tokenAddress token address\n * @returns input token address or lazy mint adapter address\n */\nvar getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = function getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress(tokenAddress) {\n  return SHARED_STOREFRONT_ADDRESSES.has(tokenAddress.toLowerCase()) ? constants_2.SHARED_STOREFRONT_LAZY_MINT_ADAPTER_ADDRESS : tokenAddress;\n};\nexports.getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress;\n/**\n * Sums up the basis points for an Opensea or seller fee map and returns the\n * single numeric value if the map is not empty. Otherwise, it returns 0\n * @param fees a `Fees` submap holding fees (either Fees.openseaFees\n *  or Fees.sellerFees)\n * @returns sum of basis points in a fee map\n */\nvar feesToBasisPoints = function feesToBasisPoints(fees) {\n  if (!fees) {\n    return 0;\n  }\n  return Array.from(fees.values()).reduce(function (sum, basisPoints) {\n    return basisPoints + sum;\n  }, 0);\n};\nexports.feesToBasisPoints = feesToBasisPoints;\n/**\n * checks protocol address\n * @param protocolAddress a protocol address\n */\nvar isValidProtocol = function isValidProtocol(protocolAddress) {\n  var checkSumAddress = web3_1.default.utils.toChecksumAddress(protocolAddress);\n  var validProtocolAddresses = [constants_1.CROSS_CHAIN_SEAPORT_ADDRESS, constants_1.CROSS_CHAIN_SEAPORT_V1_4_ADDRESS].map(function (address) {\n    return web3_1.default.utils.toChecksumAddress(address);\n  });\n  return validProtocolAddresses.includes(checkSumAddress);\n};\nexports.isValidProtocol = isValidProtocol;","map":null,"metadata":{},"sourceType":"script"}