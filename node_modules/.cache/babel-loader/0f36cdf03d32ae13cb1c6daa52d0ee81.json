{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Set = require('core-js-pure/es/set');\nvar Trie = require('merkle-patricia-tree/secure.js');\nvar asyncLib = require('async');\nvar utils = require(\"ethereumjs-util\");\nvar BN = require(\"bn.js\");\nvar rlp_1 = require(\"rlp\");\nvar ethereumjs_common_1 = require(\"ethereumjs-common\");\nvar genesisStates_1 = require(\"ethereumjs-common/dist/genesisStates\");\nvar ethereumjs_account_1 = require(\"ethereumjs-account\");\nvar cache_1 = require(\"./cache\");\nvar precompiles_1 = require(\"../evm/precompiles\");\n/**\n * Interface for getting and setting data from an underlying\n * state trie.\n */\nvar StateManager = /** @class */function () {\n  /**\n   * Instantiate the StateManager interface.\n   */\n  function StateManager(opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    var common = opts.common;\n    if (!common) {\n      common = new ethereumjs_common_1.default('mainnet', 'petersburg');\n    }\n    this._common = common;\n    this._trie = opts.trie || new Trie();\n    this._storageTries = {}; // the storage trie cache\n    this._cache = new cache_1.default(this._trie);\n    this._touched = new Set();\n    this._touchedStack = [];\n    this._checkpointCount = 0;\n    this._originalStorageCache = new Map();\n  }\n  /**\n   * Copies the current instance of the `StateManager`\n   * at the last fully committed point, i.e. as if all current\n   * checkpoints were reverted.\n   */\n  StateManager.prototype.copy = function () {\n    return new StateManager({\n      trie: this._trie.copy(),\n      common: this._common\n    });\n  };\n  /**\n   * Callback for `getAccount` method.\n   * @callback getAccount~callback\n   * @param error - an error that may have happened or `null`\n   * @param account - An [`ethereumjs-account`](https://github.com/ethereumjs/ethereumjs-account)\n   * instance corresponding to the provided `address`\n   */\n  /**\n   * Gets the [`ethereumjs-account`](https://github.com/ethereumjs/ethereumjs-account)\n   * associated with `address`. Returns an empty account if the account does not exist.\n   * @param address - Address of the `account` to get\n   * @param {getAccount~callback} cb\n   */\n  StateManager.prototype.getAccount = function (address, cb) {\n    this._cache.getOrLoad(address, cb);\n  };\n  /**\n   * Saves an [`ethereumjs-account`](https://github.com/ethereumjs/ethereumjs-account)\n   * into state under the provided `address`.\n   * @param address - Address under which to store `account`\n   * @param account - The [`ethereumjs-account`](https://github.com/ethereumjs/ethereumjs-account) to store\n   * @param cb - Callback function\n   */\n  StateManager.prototype.putAccount = function (address, account, cb) {\n    // TODO: dont save newly created accounts that have no balance\n    // if (toAccount.balance.toString('hex') === '00') {\n    // if they have money or a non-zero nonce or code, then write to tree\n    this._cache.put(address, account);\n    this.touchAccount(address);\n    // self._trie.put(addressHex, account.serialize(), cb)\n    cb();\n  };\n  /**\n   * Marks an account as touched, according to the definition\n   * in [EIP-158](https://eips.ethereum.org/EIPS/eip-158).\n   * This happens when the account is triggered for a state-changing\n   * event. Touched accounts that are empty will be cleared\n   * at the end of the tx.\n   */\n  StateManager.prototype.touchAccount = function (address) {\n    this._touched.add(address.toString('hex'));\n  };\n  /**\n   * Adds `value` to the state trie as code, and sets `codeHash` on the account\n   * corresponding to `address` to reference this.\n   * @param address - Address of the `account` to add the `code` for\n   * @param value - The value of the `code`\n   * @param cb - Callback function\n   */\n  StateManager.prototype.putContractCode = function (address, value, cb) {\n    var _this = this;\n    this.getAccount(address, function (err, account) {\n      if (err) {\n        return cb(err);\n      }\n      // TODO: setCode use trie.setRaw which creates a storage leak\n      account.setCode(_this._trie, value, function (err) {\n        if (err) {\n          return cb(err);\n        }\n        _this.putAccount(address, account, cb);\n      });\n    });\n  };\n  /**\n   * Callback for `getContractCode` method\n   * @callback getContractCode~callback\n   * @param error - an error that may have happened or `null`\n   * @param code - The code corresponding to the provided address.\n   * Returns an empty `Buffer` if the account has no associated code.\n   */\n  /**\n   * Gets the code corresponding to the provided `address`.\n   * @param address - Address to get the `code` for\n   * @param {getContractCode~callback} cb\n   */\n  StateManager.prototype.getContractCode = function (address, cb) {\n    var _this = this;\n    this.getAccount(address, function (err, account) {\n      if (err) {\n        return cb(err);\n      }\n      account.getCode(_this._trie, cb);\n    });\n  };\n  /**\n   * Creates a storage trie from the primary storage trie\n   * for an account and saves this in the storage cache.\n   * @private\n   */\n  StateManager.prototype._lookupStorageTrie = function (address, cb) {\n    var _this = this;\n    // from state trie\n    this.getAccount(address, function (err, account) {\n      if (err) {\n        return cb(err);\n      }\n      var storageTrie = _this._trie.copy();\n      storageTrie.root = account.stateRoot;\n      storageTrie._checkpoints = [];\n      cb(null, storageTrie);\n    });\n  };\n  /**\n   * Gets the storage trie for an account from the storage\n   * cache or does a lookup.\n   * @private\n   */\n  StateManager.prototype._getStorageTrie = function (address, cb) {\n    var storageTrie = this._storageTries[address.toString('hex')];\n    // from storage cache\n    if (storageTrie) {\n      return cb(null, storageTrie);\n    }\n    // lookup from state\n    this._lookupStorageTrie(address, cb);\n  };\n  /**\n   * Callback for `getContractStorage` method\n   * @callback getContractStorage~callback\n   * @param {Error} error an error that may have happened or `null`\n   * @param {Buffer} storageValue The storage value for the account\n   * corresponding to the provided address at the provided key.\n   * If this does not exists an empty `Buffer` is returned\n   */\n  /**\n   * Gets the storage value associated with the provided `address` and `key`. This method returns\n   * the shortest representation of the stored value.\n   * @param address -  Address of the account to get the storage for\n   * @param key - Key in the account's storage to get the value for. Must be 32 bytes long.\n   * @param {getContractCode~callback} cb.\n   */\n  StateManager.prototype.getContractStorage = function (address, key, cb) {\n    if (key.length !== 32) {\n      return cb(new Error('Storage key must be 32 bytes long'));\n    }\n    this._getStorageTrie(address, function (err, trie) {\n      if (err) {\n        return cb(err);\n      }\n      trie.get(key, function (err, value) {\n        if (err) {\n          return cb(err);\n        }\n        var decoded = rlp_1.decode(value);\n        cb(null, decoded);\n      });\n    });\n  };\n  /**\n   * Caches the storage value associated with the provided `address` and `key`\n   * on first invocation, and returns the cached (original) value from then\n   * onwards. This is used to get the original value of a storage slot for\n   * computing gas costs according to EIP-1283.\n   * @param address - Address of the account to get the storage for\n   * @param key - Key in the account's storage to get the value for. Must be 32 bytes long.\n   */\n  StateManager.prototype.getOriginalContractStorage = function (address, key, cb) {\n    if (key.length !== 32) {\n      return cb(new Error('Storage key must be 32 bytes long'));\n    }\n    var addressHex = address.toString('hex');\n    var keyHex = key.toString('hex');\n    var map;\n    if (!this._originalStorageCache.has(addressHex)) {\n      map = new Map();\n      this._originalStorageCache.set(addressHex, map);\n    } else {\n      map = this._originalStorageCache.get(addressHex);\n    }\n    if (map.has(keyHex)) {\n      cb(null, map.get(keyHex));\n    } else {\n      this.getContractStorage(address, key, function (err, current) {\n        if (err) return cb(err);\n        map.set(keyHex, current);\n        cb(null, current);\n      });\n    }\n  };\n  /**\n   * Modifies the storage trie of an account\n   * @private\n   * @param address -  Address of the account whose storage is to be modified\n   * @param modifyTrie - Function to modify the storage trie of the account\n   */\n  StateManager.prototype._modifyContractStorage = function (address, modifyTrie, cb) {\n    var _this = this;\n    this._getStorageTrie(address, function (err, storageTrie) {\n      if (err) {\n        return cb(err);\n      }\n      modifyTrie(storageTrie, function (err) {\n        if (err) return cb(err);\n        // update storage cache\n        _this._storageTries[address.toString('hex')] = storageTrie;\n        // update contract stateRoot\n        var contract = _this._cache.get(address);\n        contract.stateRoot = storageTrie.root;\n        _this.putAccount(address, contract, cb);\n        _this.touchAccount(address);\n      });\n    });\n  };\n  /**\n   * Adds value to the state trie for the `account`\n   * corresponding to `address` at the provided `key`.\n   * @param address -  Address to set a storage value for\n   * @param key - Key to set the value at. Must be 32 bytes long.\n   * @param value - Value to set at `key` for account corresponding to `address`\n   * @param cb - Callback function\n   */\n  StateManager.prototype.putContractStorage = function (address, key, value, cb) {\n    if (key.length !== 32) {\n      return cb(new Error('Storage key must be 32 bytes long'));\n    }\n    this._modifyContractStorage(address, function (storageTrie, done) {\n      if (value && value.length) {\n        // format input\n        var encodedValue = rlp_1.encode(value);\n        storageTrie.put(key, encodedValue, done);\n      } else {\n        // deleting a value\n        storageTrie.del(key, done);\n      }\n    }, cb);\n  };\n  /**\n   * Clears all storage entries for the account corresponding to `address`.\n   * @param address -  Address to clear the storage of\n   * @param cb - Callback function\n   */\n  StateManager.prototype.clearContractStorage = function (address, cb) {\n    this._modifyContractStorage(address, function (storageTrie, done) {\n      storageTrie.root = storageTrie.EMPTY_TRIE_ROOT;\n      done();\n    }, cb);\n  };\n  /**\n   * Checkpoints the current state of the StateManager instance.\n   * State changes that follow can then be committed by calling\n   * `commit` or `reverted` by calling rollback.\n   * @param cb - Callback function\n   */\n  StateManager.prototype.checkpoint = function (cb) {\n    this._trie.checkpoint();\n    this._cache.checkpoint();\n    this._touchedStack.push(new Set(Array.from(this._touched)));\n    this._checkpointCount++;\n    cb();\n  };\n  /**\n   * Commits the current change-set to the instance since the\n   * last call to checkpoint.\n   * @param cb - Callback function\n   */\n  StateManager.prototype.commit = function (cb) {\n    var _this = this;\n    // setup trie checkpointing\n    this._trie.commit(function () {\n      // setup cache checkpointing\n      _this._cache.commit();\n      _this._touchedStack.pop();\n      _this._checkpointCount--;\n      if (_this._checkpointCount === 0) _this._cache.flush(cb);else cb();\n    });\n  };\n  /**\n   * Reverts the current change-set to the instance since the\n   * last call to checkpoint.\n   * @param cb - Callback function\n   */\n  StateManager.prototype.revert = function (cb) {\n    // setup trie checkpointing\n    this._trie.revert();\n    // setup cache checkpointing\n    this._cache.revert();\n    this._storageTries = {};\n    var touched = this._touchedStack.pop();\n    if (!touched) {\n      throw new Error('Reverting to invalid state checkpoint failed');\n    }\n    // Exceptional case due to consensus issue in Geth and Parity.\n    // See [EIP issue #716](https://github.com/ethereum/EIPs/issues/716) for context.\n    // The RIPEMD precompile has to remain *touched* even when the call reverts,\n    // and be considered for deletion.\n    if (this._touched.has(precompiles_1.ripemdPrecompileAddress)) {\n      touched.add(precompiles_1.ripemdPrecompileAddress);\n    }\n    this._touched = touched;\n    this._checkpointCount--;\n    if (this._checkpointCount === 0) this._cache.flush(cb);else cb();\n  };\n  /**\n   * Callback for `getStateRoot` method\n   * @callback getStateRoot~callback\n   * @param {Error} error an error that may have happened or `null`.\n   * Will be an error if the un-committed checkpoints on the instance.\n   * @param {Buffer} stateRoot The state-root of the `StateManager`\n   */\n  /**\n   * Gets the state-root of the Merkle-Patricia trie representation\n   * of the state of this StateManager. Will error if there are uncommitted\n   * checkpoints on the instance.\n   * @param {getStateRoot~callback} cb\n   */\n  StateManager.prototype.getStateRoot = function (cb) {\n    var _this = this;\n    if (this._checkpointCount !== 0) {\n      return cb(new Error('Cannot get state root with uncommitted checkpoints'));\n    }\n    this._cache.flush(function (err) {\n      if (err) {\n        return cb(err);\n      }\n      var stateRoot = _this._trie.root;\n      cb(null, stateRoot);\n    });\n  };\n  /**\n   * Sets the state of the instance to that represented\n   * by the provided `stateRoot`. Will error if there are uncommitted\n   * checkpoints on the instance or if the state root does not exist in\n   * the state trie.\n   * @param stateRoot - The state-root to reset the instance to\n   * @param cb - Callback function\n   */\n  StateManager.prototype.setStateRoot = function (stateRoot, cb) {\n    var _this = this;\n    if (this._checkpointCount !== 0) {\n      return cb(new Error('Cannot set state root with uncommitted checkpoints'));\n    }\n    this._cache.flush(function (err) {\n      if (err) {\n        return cb(err);\n      }\n      if (stateRoot === _this._trie.EMPTY_TRIE_ROOT) {\n        _this._trie.root = stateRoot;\n        _this._cache.clear();\n        _this._storageTries = {};\n        return cb();\n      }\n      _this._trie.checkRoot(stateRoot, function (err, hasRoot) {\n        if (err || !hasRoot) {\n          cb(err || new Error('State trie does not contain state root'));\n        } else {\n          _this._trie.root = stateRoot;\n          _this._cache.clear();\n          _this._storageTries = {};\n          cb();\n        }\n      });\n    });\n  };\n  /**\n   * Callback for `dumpStorage` method\n   * @callback dumpStorage~callback\n   * @param {Error} error an error that may have happened or `null`\n   * @param {Object} accountState The state of the account as an `Object` map.\n   * Keys are are the storage keys, values are the storage values as strings.\n   * Both are represented as hex strings without the `0x` prefix.\n   */\n  /**\n   * Dumps the the storage values for an `account` specified by `address`.\n   * @param address - The address of the `account` to return storage for\n   * @param {dumpStorage~callback} cb\n   */\n  StateManager.prototype.dumpStorage = function (address, cb) {\n    this._getStorageTrie(address, function (err, trie) {\n      if (err) {\n        return cb(err);\n      }\n      var storage = {};\n      var stream = trie.createReadStream();\n      stream.on('data', function (val) {\n        storage[val.key.toString('hex')] = val.value.toString('hex');\n      });\n      stream.on('end', function () {\n        cb(storage);\n      });\n    });\n  };\n  /**\n   * Callback for `hasGenesisState` method\n   * @callback hasGenesisState~callback\n   * @param {Error} error an error that may have happened or `null`\n   * @param {Boolean} hasGenesisState Whether the storage trie contains the\n   * canonical genesis state for the configured chain parameters.\n   */\n  /**\n   * Checks whether the current instance has the canonical genesis state\n   * for the configured chain parameters.\n   * @param {hasGenesisState~callback} cb\n   */\n  StateManager.prototype.hasGenesisState = function (cb) {\n    var root = this._common.genesis().stateRoot;\n    this._trie.checkRoot(root, cb);\n  };\n  /**\n   * Generates a canonical genesis state on the instance based on the\n   * configured chain parameters. Will error if there are uncommitted\n   * checkpoints on the instance.\n   * @param cb - Callback function\n   */\n  StateManager.prototype.generateCanonicalGenesis = function (cb) {\n    var _this = this;\n    if (this._checkpointCount !== 0) {\n      return cb(new Error('Cannot create genesis state with uncommitted checkpoints'));\n    }\n    this.hasGenesisState(function (err, genesis) {\n      if (!genesis && !err) {\n        _this.generateGenesis(genesisStates_1.genesisStateByName(_this._common.chainName()), cb);\n      } else {\n        cb(err);\n      }\n    });\n  };\n  /**\n   * Initializes the provided genesis state into the state trie\n   * @param initState - Object (address -> balance)\n   * @param cb - Callback function\n   */\n  StateManager.prototype.generateGenesis = function (initState, cb) {\n    var _this = this;\n    if (this._checkpointCount !== 0) {\n      return cb(new Error('Cannot create genesis state with uncommitted checkpoints'));\n    }\n    var addresses = Object.keys(initState);\n    asyncLib.eachSeries(addresses, function (address, done) {\n      var account = new ethereumjs_account_1.default();\n      if (initState[address].slice(0, 2) === '0x') {\n        account.balance = new BN(initState[address].slice(2), 16).toArrayLike(Buffer);\n      } else {\n        account.balance = new BN(initState[address]).toArrayLike(Buffer);\n      }\n      var addressBuffer = utils.toBuffer(address);\n      _this._trie.put(addressBuffer, account.serialize(), done);\n    }, cb);\n  };\n  /**\n   * Callback for `accountIsEmpty` method\n   * @callback accountIsEmpty~callback\n   * @param {Error} error an error that may have happened or `null`\n   * @param {Boolean} empty True if the account is empty false otherwise\n   */\n  /**\n   * Checks if the `account` corresponding to `address` is empty as defined in\n   * EIP-161 (https://eips.ethereum.org/EIPS/eip-161).\n   * @param address - Address to check\n   * @param {accountIsEmpty~callback} cb\n   */\n  StateManager.prototype.accountIsEmpty = function (address, cb) {\n    this.getAccount.bind(this)(address, function (err, account) {\n      if (err) {\n        return cb(err);\n      }\n      // should be replaced by account.isEmpty() once updated\n      cb(null, account.nonce.toString('hex') === '' && account.balance.toString('hex') === '' && account.codeHash.toString('hex') === utils.KECCAK256_NULL_S);\n    });\n  };\n  /**\n   * Removes accounts form the state trie that have been touched,\n   * as defined in EIP-161 (https://eips.ethereum.org/EIPS/eip-161).\n   * @param cb - Callback function\n   */\n  StateManager.prototype.cleanupTouchedAccounts = function (cb) {\n    var _this = this;\n    var touchedArray = Array.from(this._touched);\n    asyncLib.forEach(touchedArray, function (addressHex, next) {\n      var address = Buffer.from(addressHex, 'hex');\n      _this.accountIsEmpty(address, function (err, empty) {\n        if (err) {\n          next(err);\n          return;\n        }\n        if (empty) {\n          _this._cache.del(address);\n        }\n        next(null);\n      });\n    }, function () {\n      _this._touched.clear();\n      cb();\n    });\n  };\n  /**\n   * Clears the original storage cache. Refer to [[getOriginalContractStorage]]\n   * for more explanation.\n   * @ignore\n   */\n  StateManager.prototype._clearOriginalStorageCache = function () {\n    this._originalStorageCache = new Map();\n  };\n  return StateManager;\n}();\nexports.default = StateManager;","map":null,"metadata":{},"sourceType":"script"}