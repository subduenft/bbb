{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.safeDecodeNumericValue = exports.decodeNumericValue = exports.safeEncodeNumericValue = exports.encodeNumericValue = void 0;\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\nvar constants_1 = require(\"../utils/constants\");\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(\"Tried to assign value of \".concat(value, \", which exceeds max value of \").concat(maxValue));\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(\"Tried to assign value of \".concat(value, \", which exceeds min value of \").concat(minValue));\n  } else if (value.isNaN()) {\n    throw new Error(\"Tried to assign NaN value\");\n  }\n}\nfunction bigNumberToPaddedBuffer(value) {\n  return ethUtil.setLengthLeft(ethUtil.toBuffer(new ethUtil.BN(value.toFixed(0))), constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n}\n/**\n * Takes a numeric value and returns its ABI-encoded value\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction encodeNumericValue(value_) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n  // Case 1/2: value is non-negative\n  if (value.isGreaterThanOrEqualTo(0)) {\n    var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  }\n  // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n  var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE);\n  // Step 2/3: Invert binary value\n  var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n  // Step 3/3: Add 1 to inverted value\n  var negativeValue = invertedValue.plus(1);\n  var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\nexports.encodeNumericValue = encodeNumericValue;\n/**\n * Takes a numeric value and returns its ABI-encoded value.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param value_    The value to encode.\n * @return ABI Encoded value\n */\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  var encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction decodeNumericValue(encodedValue, minValue) {\n  var valueHex = ethUtil.bufferToHex(encodedValue);\n  // Case 1/3: value is definitely non-negative because of numeric boundaries\n  var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n  if (!minValue.isLessThan(0)) {\n    return value;\n  }\n  // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n  var valueBin = value.toString(constants_1.constants.BIN_BASE);\n  var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n  if (!isValueNegative) {\n    return value;\n  }\n  // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n  var invertedValueBin = '';\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\n  // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n  var positiveValue = invertedValue.plus(1);\n  // Step 3/3: Invert positive value to get the negative value\n  var negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\nexports.decodeNumericValue = decodeNumericValue;\n/**\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\n * Performs an additional sanity check, given the min/max allowed value.\n * @param encodedValue    The encoded numeric value.\n * @param minValue        The minimum possible decoded value.\n * @return ABI Decoded value\n */\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  var value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":null,"metadata":{},"sourceType":"script"}