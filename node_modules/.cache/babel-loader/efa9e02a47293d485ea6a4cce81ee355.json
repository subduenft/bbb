{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar evm_1 = require(\"../evm\");\nvar assert = require('assert');\nfunction multComplexity(x) {\n  var fac1;\n  var fac2;\n  if (x.lten(64)) {\n    return x.sqr();\n  } else if (x.lten(1024)) {\n    // return Math.floor(Math.pow(x, 2) / 4) + 96 * x - 3072\n    fac1 = x.sqr().divn(4);\n    fac2 = x.muln(96);\n    return fac1.add(fac2).subn(3072);\n  } else {\n    // return Math.floor(Math.pow(x, 2) / 16) + 480 * x - 199680\n    fac1 = x.sqr().divn(16);\n    fac2 = x.muln(480);\n    return fac1.add(fac2).subn(199680);\n  }\n}\nfunction getAdjustedExponentLength(data) {\n  var expBytesStart;\n  try {\n    var baseLen = new BN(data.slice(0, 32)).toNumber();\n    expBytesStart = 96 + baseLen; // 96 for base length, then exponent length, and modulus length, then baseLen for the base data, then exponent bytes start\n  } catch (e) {\n    expBytesStart = Number.MAX_SAFE_INTEGER - 32;\n  }\n  var expLen = new BN(data.slice(32, 64));\n  var firstExpBytes = Buffer.from(data.slice(expBytesStart, expBytesStart + 32)); // first word of the exponent data\n  firstExpBytes = ethereumjs_util_1.setLengthRight(firstExpBytes, 32); // reading past the data reads virtual zeros\n  var firstExpBN = new BN(firstExpBytes);\n  var max32expLen = 0;\n  if (expLen.ltn(32)) {\n    max32expLen = 32 - expLen.toNumber();\n  }\n  firstExpBN = firstExpBN.shrn(8 * Math.max(max32expLen, 0));\n  var bitLen = -1;\n  while (firstExpBN.gtn(0)) {\n    bitLen = bitLen + 1;\n    firstExpBN = firstExpBN.ushrn(1);\n  }\n  var expLenMinus32OrZero = expLen.subn(32);\n  if (expLenMinus32OrZero.ltn(0)) {\n    expLenMinus32OrZero = new BN(0);\n  }\n  var eightTimesExpLenMinus32OrZero = expLenMinus32OrZero.muln(8);\n  var adjustedExpLen = eightTimesExpLenMinus32OrZero;\n  if (bitLen > 0) {\n    adjustedExpLen.iaddn(bitLen);\n  }\n  return adjustedExpLen;\n}\nfunction expmod(B, E, M) {\n  if (E.isZero()) return new BN(1).mod(M);\n  // Red asserts M > 1\n  if (M.lten(1)) return new BN(0);\n  var red = BN.red(M);\n  var redB = B.toRed(red);\n  var res = redB.redPow(E);\n  return res.fromRed();\n}\nfunction default_1(opts) {\n  assert(opts.data);\n  var data = opts.data;\n  var adjustedELen = getAdjustedExponentLength(data);\n  if (adjustedELen.ltn(1)) {\n    adjustedELen = new BN(1);\n  }\n  var bLen = new BN(data.slice(0, 32));\n  var eLen = new BN(data.slice(32, 64));\n  var mLen = new BN(data.slice(64, 96));\n  var maxLen = bLen;\n  if (maxLen.lt(mLen)) {\n    maxLen = mLen;\n  }\n  var Gquaddivisor = opts._common.param('gasPrices', 'modexpGquaddivisor');\n  var gasUsed = adjustedELen.mul(multComplexity(maxLen)).divn(Gquaddivisor);\n  if (opts.gasLimit.lt(gasUsed)) {\n    return evm_1.OOGResult(opts.gasLimit);\n  }\n  if (bLen.isZero()) {\n    return {\n      gasUsed: gasUsed,\n      returnValue: new BN(0).toArrayLike(Buffer, 'be', 1)\n    };\n  }\n  if (mLen.isZero()) {\n    return {\n      gasUsed: gasUsed,\n      returnValue: Buffer.alloc(0)\n    };\n  }\n  var maxInt = new BN(Number.MAX_SAFE_INTEGER);\n  var maxSize = new BN(2147483647); // ethereumjs-util setLengthRight limitation\n  if (bLen.gt(maxSize) || eLen.gt(maxSize) || mLen.gt(maxSize)) {\n    return evm_1.OOGResult(opts.gasLimit);\n  }\n  var bStart = new BN(96);\n  var bEnd = bStart.add(bLen);\n  var eStart = bEnd;\n  var eEnd = eStart.add(eLen);\n  var mStart = eEnd;\n  var mEnd = mStart.add(mLen);\n  if (mEnd.gt(maxInt)) {\n    return evm_1.OOGResult(opts.gasLimit);\n  }\n  var B = new BN(ethereumjs_util_1.setLengthRight(data.slice(bStart.toNumber(), bEnd.toNumber()), bLen.toNumber()));\n  var E = new BN(ethereumjs_util_1.setLengthRight(data.slice(eStart.toNumber(), eEnd.toNumber()), eLen.toNumber()));\n  var M = new BN(ethereumjs_util_1.setLengthRight(data.slice(mStart.toNumber(), mEnd.toNumber()), mLen.toNumber()));\n  var R;\n  if (M.isZero()) {\n    R = new BN(0);\n  } else {\n    R = expmod(B, E, M);\n  }\n  return {\n    gasUsed: gasUsed,\n    returnValue: R.toArrayLike(Buffer, 'be', mLen.toNumber())\n  };\n}\nexports.default = default_1;","map":null,"metadata":{},"sourceType":"script"}